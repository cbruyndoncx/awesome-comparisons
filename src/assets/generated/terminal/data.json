[{"type":"header","level":1,"content":"Aider - https://aider.chat","children":[{"type":"text","content":"Aider is the first popular AI Coding CLI, with a fairly recently added webbased gui.\nAider is a python package and frequently updated with a mass following and an active Discord community."},{"type":"header","level":2,"content":"General Info","children":[{"type":"header","level":3,"content":"Classification","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Code/Terminal","plainChildren":""}]}]},{"type":"header","level":3,"content":"Version","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Unknown (2025-10-18)","plainChildren":""},{"type":"item","level":3,"content":"Actively maintained open-source project; check https://github.com/Aider-AI/aider for current version","plainChildren":""}]}]},{"type":"header","level":3,"content":"Repo","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"https://github.com/Aider-AI/aider","plainChildren":""}]}]},{"type":"header","level":3,"content":"Rating","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"[4] Popular, actively maintained OSS CLI with a large community","plainChildren":""},{"type":"item","level":3,"content":"[4] Strong Git integration and multi-LLM support; good for whole-repo edits","plainChildren":""}]}]},{"type":"header","level":3,"content":"Short Description","children":[{"type":"text","content":"A terminal-first AI pair-programming CLI (with optional browser UI) that provides repo-aware, multi-file edits, automatic Git commits, and support for multiple remote and local LLM backends."}]},{"type":"header","level":3,"content":"Description","children":[{"type":"text","content":"Aider is an open-source AI pair-programming tool focused on the terminal-first developer workflow. It allows developers to chat with LLMs, make multi-file edits, run linters/tests, and commit changes automatically via Git — all from the CLI (with an optional web GUI). Aider works across languages and large codebases by building and using a code-map of the repository to provide context-aware edits. It supports multiple remote LLM providers and local models, enabling private and offline workflows."}]},{"type":"header","level":3,"content":"Languages","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Any","plainChildren":""}]}]},{"type":"header","level":3,"content":"Notes","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"BYOK model: users supply API keys for whichever LLM provider they choose (OpenAI, Anthropic, DeepSeek, etc.), allowing control over costs and provider choice.","plainChildren":""},{"type":"item","level":3,"content":"Local/model support: Aider can connect to local LLMs (self-hosted or via local runtimes), enabling fully offline workflows and private model usage.","plainChildren":""},{"type":"item","level":3,"content":"Cost optimization: Supports prompt-caching patterns and lets you choose cheaper models or local models to reduce usage costs.","plainChildren":""},{"type":"item","level":3,"content":"Workflow strengths: deep Git integration (auto-commit with sensible commit messages, undo commit, diff), in-chat file management (/add, /drop), lint/test runs, and automatic retries/fixes when tests fail.","plainChildren":""},{"type":"item","level":3,"content":"UX features: terminal-first chat, optional web GUI, voice input, ability to ingest web pages/images for context, and pointing to CONVENTIONS.md to enforce project-specific rules.","plainChildren":""},{"type":"item","level":3,"content":"Installation: pip-based installer (e.g., python -m pip install aider-install; then run aider-install), then run aider in a repo with your chosen model and API key.","plainChildren":""},{"type":"item","level":3,"content":"Good fit for: teams wanting repo-aware AI edits, those requiring private/local model runs, developers who prefer CLI workflows and Git-backed safety for AI edits.","plainChildren":""},{"type":"item","level":3,"content":"Limitations/considerations: Aider is a thin orchestration layer — actual model behavior, costs, and availability depend on chosen LLM provider or local runtime; evaluate model performance and token costs for your use case before large-scale adoption.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Last Update","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"2025-10-18","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Licensing","children":[{"type":"header","level":3,"content":"Opensource","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"License","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"MIT","plainChildren":""}]}]},{"type":"header","level":3,"content":"Free Trial","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"N/A","plainChildren":""},{"type":"item","level":3,"content":"Open-source tool (permanently free); users pay their own LLM provider for API usage, not a time-limited trial","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"header","level":3,"content":"MCP-Client","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]},{"type":"header","level":3,"content":"Prompts","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Supports configurable prompt templates, system-level prompts, and prompt caching to reduce costs and speed up repeated tasks.","plainChildren":""},{"type":"item","level":3,"content":"Prompts can be adjusted during chat and model selection is switchable in-session.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Tools","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"In-chat commands and workflow tooling: runs linters/tests, shows diffs, and commits changes to Git automatically.","plainChildren":""},{"type":"item","level":3,"content":"Common in-chat commands include: /add (include files), /drop (remove files from context), /model (switch model), /undo (revert last AI change), and /reasoning-effort (control model reasoning depth).","plainChildren":""}]}]},{"type":"header","level":3,"content":"Resources","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Builds a repo code-map for contextual awareness and can ingest files, folders, URLs and images to provide rich contextual resources to the model.","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Deployment","children":[{"type":"header","level":3,"content":"BYOK","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"LocalOffline","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Supports local model usage via adapters (community integrations exist for local runtimes such as Ollama and other self-hosted LLMs)","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Developer Experience","children":[{"type":"header","level":3,"content":"ContextManagement","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Maintains a repository code-map to provide broad context and supports targeted context injection via @file, @folder, URLs, and by adding files to the chat.","plainChildren":""},{"type":"item","level":3,"content":"Supports prompt caching and selective file inclusion to manage token usage and focus the model.","plainChildren":""}]}]},{"type":"header","level":3,"content":"DirectFileReferences","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Use @file / @folder references and the in-chat /add command to include specific files or folders in the session for precise edits.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Checkpoints","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Uses Git commits as checkpoints; Aider auto-commits changes with sensible messages and provides /undo and standard git tooling to revert or inspect history.","plainChildren":""}]}]},{"type":"header","level":3,"content":"GitSupport","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"header","level":3,"content":"Extensible","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Supports multiple LLM backends and local model adapters; configurable via model adapters and API-key settings","plainChildren":""}]}]},{"type":"header","level":3,"content":"Plugins","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""},{"type":"item","level":3,"content":"No formal plugin marketplace or plugin API; extensibility is achieved through model adapters, configuration, and local runtime integrations.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Hooks","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""},{"type":"item","level":3,"content":"No documented lifecycle hooks API for third-party plugins; automation is typically handled via configuration, scripts and Git workflows.","plainChildren":""}]}]},{"type":"header","level":3,"content":"SlashCommands","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Provides reusable in-chat slash commands for workflow control (e.g., /add, /drop, /model, /undo, /reasoning-effort, /help).","plainChildren":""}]}]},{"type":"header","level":3,"content":"Custom Modes","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Built-in chat modes to tailor behavior: code (direct edits), architect (design/planning), ask (questions about code), help (explain Aider features).","plainChildren":""}]}]},{"type":"header","level":3,"content":"Subagents","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""},{"type":"item","level":3,"content":"Does not expose a named subagent framework; supports autonomous execution modes (auto-approve) but not first-class subagent definitions.","plainChildren":""}]}]}]}],"sourcePath":"aider.md"},{"type":"header","level":1,"content":"Auggie CLI - https://www.augmentcode.com/changelog/auggie-cli","children":[{"type":"text","content":"Auggie is Augment's agentic coding CLI that runs in your terminal. It understands your codebase and helps you ship faster by analyzing code, making safe edits, and automating routine tasks — all via natural language.\n\n**Dataset ID:** terminal"},{"type":"header","level":2,"content":"General Info","children":[{"type":"header","level":3,"content":"Classification","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Code/Terminal","plainChildren":""}]}]},{"type":"header","level":3,"content":"Version","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"1.0 (2025)","plainChildren":""}]}]},{"type":"header","level":3,"content":"Repo","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"https://github.com/augmentcode/auggie","plainChildren":""}]}]},{"type":"header","level":3,"content":"Rating","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"-","plainChildren":""}]}]},{"type":"header","level":3,"content":"Short Description","children":[{"type":"text","content":"An AI agent that brings Augment Code's power to the terminal, featuring advanced context awareness and flexible integration into developer workflows."}]},{"type":"header","level":3,"content":"Description","children":[{"type":"text","content":"Auggie CLI is an agentic coding assistant designed to integrate into every part of your development workflow. Using Augment's leading context engine, it maps project structure, dependencies, and patterns without manual context selection. The tool supports both interactive and non-interactive use, making it flexible for one-off commands, piped input, or integration into build systems.\n\nAuggie can handle up to 10,000 commit histories, ensuring accurate code suggestions and modifications even in large codebases. The tool is positioned as a competitor to Claude Code, Gemini CLI, and other terminal-based AI coding agents."}]},{"type":"header","level":3,"content":"Languages","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Any","plainChildren":""}]}]},{"type":"header","level":3,"content":"Notes","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Installation: Available via npm for Node.js 22 or later (`npm install -g @augmentcode/auggie`)","plainChildren":""},{"type":"item","level":3,"content":"Context Engine: Automatically maps project structure and dependencies without manual context selection","plainChildren":""},{"type":"item","level":3,"content":"Flexible Usage: Supports interactive and non-interactive modes, piped input, and build system integration","plainChildren":""},{"type":"item","level":3,"content":"Codebase Scale: Can handle up to 10,000 commit histories","plainChildren":""},{"type":"item","level":3,"content":"Competition: Positioned as an alternative to Claude Code, Gemini CLI, and OpenAI's Codex CLI","plainChildren":""},{"type":"item","level":3,"content":"Released: 2025","plainChildren":""}]}]},{"type":"header","level":3,"content":"Last Update","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"2025-11-18","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Licensing","children":[{"type":"header","level":3,"content":"Opensource","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]},{"type":"header","level":3,"content":"License","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Proprietary","plainChildren":""}]}]},{"type":"header","level":3,"content":"Free Trial","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"header","level":3,"content":"MCP-Client","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"-","plainChildren":""}]}]},{"type":"header","level":3,"content":"Prompts","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Natural language prompts for code generation, analysis, and modifications","plainChildren":""}]}]},{"type":"header","level":3,"content":"Tools","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Terminal-based tools for code analysis, editing, and automation","plainChildren":""}]}]},{"type":"header","level":3,"content":"Resources","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Official documentation: https://docs.augmentcode.com/cli/overview","plainChildren":""},{"type":"item","level":3,"content":"GitHub repository: https://github.com/augmentcode/auggie","plainChildren":""},{"type":"item","level":3,"content":"Product page: https://www.augmentcode.com/product/CLI","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Deployment","children":[{"type":"header","level":3,"content":"BYOK","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"-","plainChildren":""}]}]},{"type":"header","level":3,"content":"LocalOffline","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""},{"type":"item","level":3,"content":"Requires connection to Augment's cloud services for AI capabilities","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Developer Experience","children":[{"type":"header","level":3,"content":"ContextManagement","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Advanced context engine that automatically maps project structure, dependencies, and patterns","plainChildren":""},{"type":"item","level":3,"content":"Handles up to 10,000 commit histories","plainChildren":""}]}]},{"type":"header","level":3,"content":"DirectFileReferences","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Can reference and edit specific files based on natural language requests","plainChildren":""}]}]},{"type":"header","level":3,"content":"Checkpoints","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"-","plainChildren":""}]}]},{"type":"header","level":3,"content":"GitSupport","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Integrates with git repositories and understands commit history","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"header","level":3,"content":"Plugins","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"-","plainChildren":""}]}]},{"type":"header","level":3,"content":"Hooks","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"-","plainChildren":""}]}]},{"type":"header","level":3,"content":"SlashCommands","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"-","plainChildren":""}]}]},{"type":"header","level":3,"content":"Custom Modes","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Supports both interactive and non-interactive modes","plainChildren":""},{"type":"item","level":3,"content":"Can be integrated into build systems and automated workflows","plainChildren":""}]}]},{"type":"header","level":3,"content":"Subagents","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"-","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Ungrouped Criteria","children":[{"type":"header","level":3,"content":"Terminal","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]}]}],"sourcePath":"auggie-cli.md"},{"type":"header","level":1,"content":"Claude Code - https://claude.ai/code","children":[{"type":"text","content":"Claude Code is Anthropic's command-line, agentic developer assistant that integrates Claude models into terminal workflows to help write, refactor, and manage code across repositories."},{"type":"header","level":2,"content":"General Info","children":[{"type":"header","level":3,"content":"Classification","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Code/Terminal","plainChildren":""}]}]},{"type":"header","level":3,"content":"Version","children":[{"type":"text","content":"v1.0 (2025-10-18)"}]},{"type":"header","level":3,"content":"Repo","children":[{"type":"text","content":"-"}]},{"type":"header","level":3,"content":"Rating","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"[4] Strong reasoning and long-context handling","plainChildren":""},{"type":"item","level":3,"content":"[3] Can be costly at the highest-capability model tiers","plainChildren":""},{"type":"item","level":3,"content":"[4] Excellent for multi-file refactors and end-to-end developer workflows","plainChildren":""}]}]},{"type":"header","level":3,"content":"Short Description","children":[{"type":"text","content":"Claude Code is a terminal-first CLI that exposes Anthropic's Claude models to developer workflows for interactive code generation, multi-file refactors, automated testing, and scripted agentic tasks. It lets developers run prompts, apply edits, execute shell commands, and integrate with git from the terminal while preserving interactive safeguards (permission prompts and commit/checkpoint workflows).\n\n-"}]},{"type":"header","level":3,"content":"Description","children":[{"type":"text","content":"Claude Code is a low-level, terminal-first developer tool from Anthropic that exposes Claude family models (Opus, Sonnet, Haiku tiers) to developer workflows. It is intentionally unopinionated and scriptable: it runs in the terminal, integrates with Git and other CLI tools, and can be wired into CI/CD, deployment systems, and custom automation. Claude Code asks permission before making file edits or running commands, and it can be configured to use Anthropic's public API, cloud-hosted model endpoints (e.g., Bedrock, Vertex AI), or organization-managed keys.\n\nThe tool is focused on large-context reasoning, multi-file code transformations, automated testing and verification, and agentic workflows where the assistant can run sequences of commands, apply patches, and validate results. It is suitable for both single developers and teams; for the latter it is offered as part of Anthropic's Team/Enterprise plans with central administration and enhanced security controls."}]},{"type":"header","level":3,"content":"Languages","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Any","plainChildren":""}]}]},{"type":"header","level":3,"content":"Notes","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Models: Offers multiple model tiers (commonly referenced as Opus (highest capability), Sonnet (workhorse), and Haiku (cost-efficient)). Opus is aimed at deep reasoning and large refactors; Sonnet balances cost and capability; Haiku is optimized for high-volume, lower-complexity tasks.","plainChildren":""},{"type":"item","level":3,"content":"Pricing: Available as seat-based subscriptions (Pro, Max tiers) and pay-as-you-go API token pricing. High-capability models (Opus) carry premium token costs; Sonnet often provides a better cost/performance tradeoff for everyday coding.","plainChildren":""},{"type":"item","level":3,"content":"Context window: Claude-family models marketed with very large context windows (useful for large repositories and multi-file edits).","plainChildren":""},{"type":"item","level":3,"content":"Platform support: macOS, Linux, Windows (CLI-first). Windows usage commonly requires Git for Windows for full CLI feature parity.","plainChildren":""},{"type":"item","level":3,"content":"Use cases: automated refactors, multi-file PR generation, test generation and repair, code review assistance, automated CI hooks, developer productivity automation.","plainChildren":""},{"type":"item","level":3,"content":"Safety & controls: interactive permission prompts, enterprise controls for data handling, and options to route through organization-managed endpoints.","plainChildren":""},{"type":"item","level":3,"content":"Ecosystem: community tooling and integrations exist (context engineers, wrappers, \"awesome\" lists) though the official product is closed-source.","plainChildren":""},{"type":"item","level":3,"content":"Further reading: consult the official Claude documentation at <https://claude.ai/> and the Claude Code overview at <https://claude.ai/code> for up-to-date pricing, model names, and deployment options.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Last Update","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"2025-11-16","plainChildren":""},{"type":"item","level":3,"content":"Note: This date may reflect documentation update; actively maintained product from Anthropic","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Licensing","children":[{"type":"header","level":3,"content":"Opensource","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]},{"type":"header","level":3,"content":"License","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Proprietary","plainChildren":""}]}]},{"type":"header","level":3,"content":"Free Trial","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"header","level":3,"content":"MCP-Client","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"Prompts","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Claude Code is prompt-driven and exposes CLI flags and short-form prompts for interactive and scripted use. The root project file (CLAUDE.md) is automatically included in session context and is used to encode project conventions, common commands, and guardrails. See: <https://claude.ai/code>","plainChildren":""}]}]},{"type":"header","level":3,"content":"Tools","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"The CLI supports running shell commands, file edits, git operations, and configurable \"allowed tools\" for scripted agent runs. It can be configured to allow or require confirmation before making changes.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Resources","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Official documentation and overview: <https://claude.ai/code>","plainChildren":""},{"type":"item","level":3,"content":"Anthropic developer docs and API references: <https://www.anthropic.com/> and the Anthropic docs pages","plainChildren":""},{"type":"item","level":3,"content":"Community examples and third-party wrappers are available in blog posts and community repos (search \"Claude Code CLI\").","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Deployment","children":[{"type":"header","level":3,"content":"BYOK","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"LocalOffline","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""},{"type":"item","level":3,"content":"Claude Code relies on remote model endpoints by default. Anthropic and enterprise customers can route requests through cloud provider-hosted model deployments or organization-managed endpoints, but a fully offline/local model runtime is not provided as a standard option.","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Developer Experience","children":[{"type":"header","level":3,"content":"ContextManagement","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Claude Code manages context via large-model context windows, automatic inclusion of a repository-level CLAUDE.md, and explicit file-injection/piping. Users can also supply files via stdin or configure the CLI to read specific paths into the session context.","plainChildren":""}]}]},{"type":"header","level":3,"content":"DirectFileReferences","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"The CLI can read files from the working tree, and its workflow includes asking permission to edit files or run commands. Project conventions (CLAUDE.md and .claude command files) are used to teach the assistant about frequently referenced files and commands.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Checkpoints","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Claude Code integrates with git workflows and presents interactive prompts before making edits; typical usage includes creating commits, reviewable patches, or requiring user confirmation to apply changes so that git history acts as a checkpoint/undo mechanism.","plainChildren":""}]}]},{"type":"header","level":3,"content":"GitSupport","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"header","level":3,"content":"Extensible","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"Plugins","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Claude Code supports project-level extensibility via the .claude directory (custom commands and scripts). Users can author reusable command files that become slash-style commands in the CLI, enabling repeatable automations.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Hooks","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Project configuration and command files allow lifecycle-like behaviors (preflight instructions and custom scripts) that the CLI will surface during interactive sessions. Users can document expected behaviors in CLAUDE.md and trigger scripted sequences via custom commands.","plainChildren":""}]}]},{"type":"header","level":3,"content":"SlashCommands","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Custom project commands placed under .claude/commands are surfaced as slash-style commands and can be invoked from the CLI to run specialized workflows (for example, /project:fix-github-issue).","plainChildren":""}]}]},{"type":"header","level":3,"content":"Custom Modes","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"The CLI allows model selection and configurable behaviors (e.g., read-only analysis, aggressive edit mode, or restricted tool sets). Users can create and store project-specific command templates and flags to emulate specialist modes for common tasks.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Subagents","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Claude Code supports agentic, multi-step workflows where the assistant can run sequences of commands, apply edits, run tests, and re-evaluate results. Project scripts and MCP-style integrations can be used to orchestrate more complex subagent behaviors.","plainChildren":""}]}]}]}],"sourcePath":"claude-code.md"},{"type":"header","level":1,"content":"Codex CLI - https://github.com/openai/codex/","children":[{"type":"text","content":"Codex CLI is an open-source command-line interface for interacting with OpenAI's Codex model and other compatible LLM providers."},{"type":"header","level":2,"content":"General Info","children":[{"type":"header","level":3,"content":"Classification","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Code/Terminal","plainChildren":""}]}]},{"type":"header","level":3,"content":"Version","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Unknown (2025-10-19)","plainChildren":""},{"type":"item","level":3,"content":"Version information not available for OpenAI Codex CLI","plainChildren":""}]}]},{"type":"header","level":3,"content":"Repo","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"https://github.com/openai/codex","plainChildren":""}]}]},{"type":"header","level":3,"content":"Rating","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"[4] Strong community and practitioner assessments","plainChildren":""},{"type":"item","level":3,"content":"[4] Effective terminal-first coding agent with configurable approval modes","plainChildren":""}]}]},{"type":"header","level":3,"content":"Short Description","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"A terminal-first coding agent that reads, edits, and executes code using LLMs with configurable approval/sandbox modes and provider gateways.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Description","children":[{"type":"text","content":"Codex CLI provides a lightweight, terminal-first agent that lets developers read, modify, and execute code using large language models. It runs tasks in sandboxed environments, can run linters/tests, propose edits, and integrate changes back into a local repository or create pull requests. The CLI supports multiple operation modes (suggest, auto-edit, full-auto) which control how much automation is allowed without user approval."}]},{"type":"header","level":3,"content":"Languages","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Any","plainChildren":""}]}]},{"type":"header","level":3,"content":"Notes","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Supports multiple model providers (OpenAI, OpenRouter, Gemini, Ollama, Mistral, DeepSeek, xAI, Groq and other OpenAI-compatible endpoints) via configuration and gateways.","plainChildren":""},{"type":"item","level":3,"content":"Configuration stored in ~/.codex/config.toml; users can create reusable prompts and agent settings per-repo.","plainChildren":""},{"type":"item","level":3,"content":"Operational modes:","plainChildren":""},{"type":"item","level":3,"content":"Suggest (default): proposes edits and commands; requires user approval before applying changes.","plainChildren":""},{"type":"item","level":3,"content":"Auto Edit: autonomously reads/writes files, but asks before executing shell commands.","plainChildren":""},{"type":"item","level":3,"content":"Full Auto: performs reads, writes, and executes commands in a sandboxed, network-disabled environment without additional prompts.","plainChildren":""},{"type":"item","level":3,"content":"AGENTS.md: repository-level guidance files can be added to help the agent understand project structure, test commands, and conventions.","plainChildren":""},{"type":"item","level":3,"content":"Useful for exploratory code tasks, automated refactors, running test-fix cycles, and generating PR-ready diffs; best results when the repository includes clear tests and documentation.","plainChildren":""}]},{"type":"text","content":"Sources: GitHub repository (https://github.com/openai/codex) and project documentation/examples aggregated from public write-ups about Codex CLI and its configuration."}]},{"type":"header","level":3,"content":"Last Update","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"2025-10-19","plainChildren":""},{"type":"item","level":3,"content":"Date reflects the most recent project metadata checked during this update.","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Licensing","children":[{"type":"header","level":3,"content":"Opensource","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"License","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"MIT","plainChildren":""}]}]},{"type":"header","level":3,"content":"Free Trial","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Availability depends on chosen model provider (OpenAI, Ollama, etc.)","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"header","level":3,"content":"MCP-Client","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"Prompts","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Codex CLI supports reusable prompts, per-repo agent settings and prompt templates via configuration files (e.g., ~/.codex/config.toml and repository AGENTS.md).","plainChildren":""}]}]},{"type":"header","level":3,"content":"Tools","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Integrates with local tools (linters, test runners, build commands) and can propose/execute shell commands (subject to approval mode and sandboxing).","plainChildren":""}]}]},{"type":"header","level":3,"content":"Resources","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Can ingest repository files, AGENTS.md guidance, and external web search or provider-specific context when configured.","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Deployment","children":[{"type":"header","level":3,"content":"BYOK","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Uses API keys for model providers; supports configuring different gateways and provider endpoints.","plainChildren":""}]}]},{"type":"header","level":3,"content":"LocalOffline","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""},{"type":"item","level":3,"content":"Primarily uses remote model providers, though configurations and gateways (e.g., Ollama, LiteLLM proxies) can enable local model endpoints in some setups.","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Developer Experience","children":[{"type":"header","level":3,"content":"ContextManagement","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Supports persistent guidance via AGENTS.md, per-repo config, and prompt templates; can manage context window by ingesting specified files and project documentation.","plainChildren":""}]}]},{"type":"header","level":3,"content":"DirectFileReferences","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Agents operate directly on repository files, can read and propose edits to specific files, and support passing file content or paths into prompts for context.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Checkpoints","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Typical workflow uses git commits/diffs and can prepare commits or PRs; interactive modes ask for approval before applying changes, enabling easy rollback via git.","plainChildren":""}]}]},{"type":"header","level":3,"content":"GitSupport","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Can produce commits and prepare PR diffs (behavior depends on config and approval mode).","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"header","level":3,"content":"Extensible","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes (via provider gateways and config)","plainChildren":""}]}]},{"type":"header","level":3,"content":"Plugins","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""},{"type":"item","level":3,"content":"The project exposes provider gateways and integrations but does not provide a formal \"plugin\" packaging system in the core CLI (as of last review).","plainChildren":""}]}]},{"type":"header","level":3,"content":"Hooks","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""},{"type":"item","level":3,"content":"There is no documented, generic plugin-hook lifecycle API; repository-level AGENTS.md and config provide the primary customization points.","plainChildren":""}]}]},{"type":"header","level":3,"content":"SlashCommands","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"The interactive interface supports internal commands (for example switching models or toggling behavior) and the CLI exposes flags and subcommands to control operation modes.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Custom Modes","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Built-in modes (suggest, auto-edit, full-auto) and approval/sandbox configurations let teams tailor agent autonomy and safety boundaries.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Subagents","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Workflows often include specialized agent roles (e.g., review agents, testing agents) and the CLI supports multi-step plans that can incorporate distinct agent behaviors.","plainChildren":""}]}]}]}],"sourcePath":"codex-cli.md"},{"type":"header","level":1,"content":"Droid CLI - https://factory.ai/product/cli","children":[{"type":"text","content":"Droid CLI is part of Factory AI's developer platform, offering AI assistants (called Droids) inside IDEs and terminals that maintain context across tools and workflows. Droid is the #1 software development agent on Terminal-Bench.\n\n**Dataset ID:** terminal"},{"type":"header","level":2,"content":"General Info","children":[{"type":"header","level":3,"content":"Classification","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Code/Terminal","plainChildren":""},{"type":"item","level":3,"content":"Code/Autonomous agent","plainChildren":""}]}]},{"type":"header","level":3,"content":"Version","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"2025","plainChildren":""}]}]},{"type":"header","level":3,"content":"Repo","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"-","plainChildren":""}]}]},{"type":"header","level":3,"content":"Rating","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"58.75% on Terminal-Bench v0.1.1 (state-of-the-art performance)","plainChildren":""}]}]},{"type":"header","level":3,"content":"Short Description","children":[{"type":"text","content":"AI software engineering agent from Factory AI that operates in terminals and IDEs with persistent contextual memory across workflows."}]},{"type":"header","level":3,"content":"Description","children":[{"type":"text","content":"Droid CLI is Factory AI's autonomous coding agent that provides interactive AI assistants inside IDEs and terminals while maintaining contextual memory across different tools and platforms. With a score of 58.75% on Terminal-Bench, Droid sets the new state-of-the-art for AI agents' ability to complete complex end-to-end tasks in terminal environments.\n\nThe platform offers code completion, PR review suggestions, automated fixes, and can automate workflows from design docs to CI and review. Droid Exec is Factory's headless CLI mode that runs non-interactive commands for automation in CI pipelines, cron jobs, pre-commit hooks, and batch operations. Droids keep their knowledge across tools and platforms, following users through their workflow without losing context."}]},{"type":"header","level":3,"content":"Languages","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Any","plainChildren":""}]}]},{"type":"header","level":3,"content":"Notes","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Terminal-Bench Performance: 58.75% on v0.1.1 (state-of-the-art), testing 80 human-verified, Dockerized tasks","plainChildren":""},{"type":"item","level":3,"content":"Benchmark Coverage: Coding, build/test, dependency management, data/ML workflows, systems, networking, security, and core CLI","plainChildren":""},{"type":"item","level":3,"content":"Free Trial: 20M tokens included","plainChildren":""},{"type":"item","level":3,"content":"Droid Exec: Headless CLI mode for automation (CI pipelines, cron jobs, pre-commit hooks)","plainChildren":""},{"type":"item","level":3,"content":"Persistent Context: Maintains knowledge across tools and platforms","plainChildren":""},{"type":"item","level":3,"content":"Features: Code completion, PR reviews, automated fixes, workflow automation","plainChildren":""},{"type":"item","level":3,"content":"Installation: Simple curl command to get started","plainChildren":""}]}]},{"type":"header","level":3,"content":"Last Update","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"2025-11-18","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Licensing","children":[{"type":"header","level":3,"content":"Opensource","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]},{"type":"header","level":3,"content":"License","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Proprietary","plainChildren":""}]}]},{"type":"header","level":3,"content":"Free Trial","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"20M tokens included","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"header","level":3,"content":"MCP-Client","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"-","plainChildren":""}]}]},{"type":"header","level":3,"content":"Prompts","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"Tools","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Interactive and headless CLI modes","plainChildren":""},{"type":"item","level":3,"content":"Code completion and PR review tools","plainChildren":""},{"type":"item","level":3,"content":"Automated workflow tools","plainChildren":""}]}]},{"type":"header","level":3,"content":"Resources","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Official documentation: https://docs.factory.ai/cli/getting-started/quickstart","plainChildren":""},{"type":"item","level":3,"content":"Product page: https://factory.ai/product/cli","plainChildren":""},{"type":"item","level":3,"content":"Features: https://factorycli.com/features","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Deployment","children":[{"type":"header","level":3,"content":"BYOK","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"-","plainChildren":""}]}]},{"type":"header","level":3,"content":"LocalOffline","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Developer Experience","children":[{"type":"header","level":3,"content":"ContextManagement","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Droids maintain contextual memory across tools and platforms","plainChildren":""},{"type":"item","level":3,"content":"Persistent knowledge throughout workflows","plainChildren":""}]}]},{"type":"header","level":3,"content":"DirectFileReferences","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"Checkpoints","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"-","plainChildren":""}]}]},{"type":"header","level":3,"content":"GitSupport","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"PR review suggestions and automated fixes","plainChildren":""},{"type":"item","level":3,"content":"Workflow automation from design docs to CI","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"header","level":3,"content":"Plugins","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"-","plainChildren":""}]}]},{"type":"header","level":3,"content":"Hooks","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Support for pre-commit hooks via Droid Exec","plainChildren":""}]}]},{"type":"header","level":3,"content":"SlashCommands","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"-","plainChildren":""}]}]},{"type":"header","level":3,"content":"Custom Modes","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Interactive mode for chat-based assistance","plainChildren":""},{"type":"item","level":3,"content":"Droid Exec: Headless mode for automation","plainChildren":""}]}]},{"type":"header","level":3,"content":"Subagents","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Specialized droids for different tasks","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Ungrouped Criteria","children":[{"type":"header","level":3,"content":"Terminal","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]}]}],"sourcePath":"droid-cli.md"},{"type":"header","level":1,"content":"Gemini CLI - https://aistudio.google.com/","children":[{"type":"text","content":"Command-line assistant for Gemini coding workflows, providing terminal-based AI assistance powered by Google's Gemini models. Launched in 2025 to bring AI coding capabilities directly to the command line."},{"type":"header","level":2,"content":"General Info","children":[{"type":"header","level":3,"content":"Classification","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Code/Terminal","plainChildren":""}]}]},{"type":"header","level":3,"content":"Version","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"2025","plainChildren":""}]}]},{"type":"header","level":3,"content":"Repo","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"-","plainChildren":""}]}]},{"type":"header","level":3,"content":"Rating","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"-","plainChildren":""}]}]},{"type":"header","level":3,"content":"Short Description","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Command-line interface for Gemini-powered coding assistance, enabling AI-driven development workflows directly from the terminal.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Description","children":[{"type":"text","content":"Gemini CLI is Google's command-line interface for AI-assisted coding, bringing the power of Gemini models to terminal-based development workflows. It allows developers to interact with Gemini's coding capabilities without leaving their terminal environment, making it ideal for CLI-focused developers and automation workflows. The tool supports natural language prompts for code generation, debugging, and other development tasks."}]},{"type":"header","level":3,"content":"Languages","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Any","plainChildren":""}]}]},{"type":"header","level":3,"content":"Notes","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Terminal-native: Designed specifically for command-line workflows and terminal-based development.","plainChildren":""},{"type":"item","level":3,"content":"Gemini-powered: Leverages Google's Gemini model family for AI capabilities.","plainChildren":""},{"type":"item","level":3,"content":"Developer automation: Particularly useful for scripting and automated development workflows.","plainChildren":""},{"type":"item","level":3,"content":"Launched in 2025 as part of Google's expanded AI coding tools portfolio.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Last Update","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"2025","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Licensing","children":[{"type":"header","level":3,"content":"Opensource","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]},{"type":"header","level":3,"content":"License","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Proprietary","plainChildren":""}]}]},{"type":"header","level":3,"content":"Free Trial","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"header","level":3,"content":"MCP-Client","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]},{"type":"header","level":3,"content":"Prompts","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"Tools","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"Resources","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Deployment","children":[{"type":"header","level":3,"content":"BYOK","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]},{"type":"header","level":3,"content":"LocalOffline","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Developer Experience","children":[{"type":"header","level":3,"content":"ContextManagement","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"DirectFileReferences","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"Checkpoints","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]},{"type":"header","level":3,"content":"GitSupport","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"header","level":3,"content":"Plugins","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]},{"type":"header","level":3,"content":"Hooks","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]},{"type":"header","level":3,"content":"SlashCommands","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"Custom Modes","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]},{"type":"header","level":3,"content":"Subagents","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]}]}],"sourcePath":"gemini-cli.md"},{"type":"header","level":1,"content":"Jules Tools CLI - https://jules.google/","children":[{"type":"text","content":"Jules Tools is Google's command-line interface for Jules, their asynchronous AI coding agent powered by Gemini 2.5 Pro. Launched in October 2025, it brings Jules directly into the developer's terminal for streamlined coding workflows.\n\n**Dataset ID:** terminal"},{"type":"header","level":2,"content":"General Info","children":[{"type":"header","level":3,"content":"Classification","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Code/Terminal","plainChildren":""},{"type":"item","level":3,"content":"Code/Autonomous agent","plainChildren":""}]}]},{"type":"header","level":3,"content":"Version","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Public Beta (October 2025)","plainChildren":""}]}]},{"type":"header","level":3,"content":"Repo","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"-","plainChildren":""}]}]},{"type":"header","level":3,"content":"Rating","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"-","plainChildren":""}]}]},{"type":"header","level":3,"content":"Short Description","children":[{"type":"text","content":"Command-line interface for Google's Jules AI coding agent, enabling terminal-based interaction with Gemini 2.5 Pro-powered asynchronous coding assistance."}]},{"type":"header","level":3,"content":"Description","children":[{"type":"text","content":"Jules Tools is the command-line interface for Jules, Google's asynchronous coding agent launched in October 2025. The CLI lets developers interact with Jules directly from the terminal using commands, streamlining workflows by eliminating the need to switch between the web interface and GitHub.\n\nJules fetches repositories, clones them to a Cloud VM, and develops a plan utilizing the latest Gemini 2.5 Pro model. It operates asynchronously, allowing developers to focus on other tasks while it works in the background on coding tasks such as writing tests, building features, fixing bugs, and bumping dependency versions.\n\nThe tool integrates with existing repositories, understands full project context, and creates pull requests with the changes. Google has also made Jules' API public, allowing developers to integrate Jules into their existing workflows and development environments beyond the CLI."}]},{"type":"header","level":3,"content":"Languages","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Any","plainChildren":""}]}]},{"type":"header","level":3,"content":"Notes","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Model: Powered by Gemini 2.5 Pro","plainChildren":""},{"type":"item","level":3,"content":"Async Operation: Works in background while developers focus on other tasks","plainChildren":""},{"type":"item","level":3,"content":"Launch: Public beta began August 2025, CLI launched October 2025","plainChildren":""},{"type":"item","level":3,"content":"Free Tier: Up to 15 individual daily tasks and 3 concurrent tasks","plainChildren":""},{"type":"item","level":3,"content":"Paid Plans: Google AI Pro ($19.99/month - 5x limits), Ultra ($124.99/month - 20x limits)","plainChildren":""},{"type":"item","level":3,"content":"Features: Test writing, feature building, bug fixing, dependency updates, audio changelogs","plainChildren":""},{"type":"item","level":3,"content":"Integration: Public API available for custom workflow integration","plainChildren":""},{"type":"item","level":3,"content":"Cloud Execution: Clones repositories to Cloud VM for development","plainChildren":""}]}]},{"type":"header","level":3,"content":"Last Update","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"2025-11-18","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Licensing","children":[{"type":"header","level":3,"content":"Opensource","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]},{"type":"header","level":3,"content":"License","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Proprietary","plainChildren":""}]}]},{"type":"header","level":3,"content":"Free Trial","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Free tier: 15 daily tasks, 3 concurrent tasks","plainChildren":""},{"type":"item","level":3,"content":"Available worldwide where Gemini models are accessible","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"header","level":3,"content":"MCP-Client","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"-","plainChildren":""}]}]},{"type":"header","level":3,"content":"Prompts","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Command-line prompts for task assignment","plainChildren":""},{"type":"item","level":3,"content":"Natural language task descriptions","plainChildren":""}]}]},{"type":"header","level":3,"content":"Tools","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"CLI commands for interacting with Jules","plainChildren":""},{"type":"item","level":3,"content":"Public API for custom integrations","plainChildren":""}]}]},{"type":"header","level":3,"content":"Resources","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Official website: https://jules.google/","plainChildren":""},{"type":"item","level":3,"content":"Documentation: https://jules.google/docs/","plainChildren":""},{"type":"item","level":3,"content":"Google Developer Blog: https://developers.googleblog.com/","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Deployment","children":[{"type":"header","level":3,"content":"BYOK","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]},{"type":"header","level":3,"content":"LocalOffline","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""},{"type":"item","level":3,"content":"Requires Cloud VM for repository cloning and execution","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Developer Experience","children":[{"type":"header","level":3,"content":"ContextManagement","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Understands full repository context","plainChildren":""},{"type":"item","level":3,"content":"Powered by Gemini 2.5 Pro's large context window","plainChildren":""}]}]},{"type":"header","level":3,"content":"DirectFileReferences","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"Checkpoints","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Creates pull requests for review before merging","plainChildren":""}]}]},{"type":"header","level":3,"content":"GitSupport","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Direct GitHub integration","plainChildren":""},{"type":"item","level":3,"content":"Automatic PR creation","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"header","level":3,"content":"Plugins","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"-","plainChildren":""}]}]},{"type":"header","level":3,"content":"Hooks","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"-","plainChildren":""}]}]},{"type":"header","level":3,"content":"SlashCommands","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"-","plainChildren":""}]}]},{"type":"header","level":3,"content":"Custom Modes","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Asynchronous background operation mode","plainChildren":""},{"type":"item","level":3,"content":"Available via Google AI Pro and Ultra plans with different capability limits","plainChildren":""}]}]},{"type":"header","level":3,"content":"Subagents","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"-","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Ungrouped Criteria","children":[{"type":"header","level":3,"content":"Terminal","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]}]}],"sourcePath":"jules-tools.md"},{"type":"header","level":1,"content":"Kimi CLI - https://github.com/MoonshotAI/kimi-cli","children":[{"type":"text","content":"Kimi CLI is a command-line coding tool from Moonshot AI that integrates intelligent agents with traditional Shell operations, featuring dual-mode interaction design for seamless switching between Shell and AI agent modes.\n\n**Dataset ID:** terminal"},{"type":"header","level":2,"content":"General Info","children":[{"type":"header","level":3,"content":"Classification","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Code/Terminal","plainChildren":""}]}]},{"type":"header","level":3,"content":"Version","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Technical Preview (2025)","plainChildren":""}]}]},{"type":"header","level":3,"content":"Repo","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"https://github.com/MoonshotAI/kimi-cli","plainChildren":""}]}]},{"type":"header","level":3,"content":"Rating","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"-","plainChildren":""}]}]},{"type":"header","level":3,"content":"Short Description","children":[{"type":"text","content":"Dual-mode CLI coding assistant from Moonshot AI with 128K context window, supporting both traditional Shell operations and AI agent mode with ACP and MCP protocols."}]},{"type":"header","level":3,"content":"Description","children":[{"type":"text","content":"Kimi CLI is a command-line coding tool from Moonshot AI that combines traditional Shell operations with intelligent AI agents. The core innovation is its \"dual-mode interaction\" design, allowing users to work in familiar Shell style while being able to switch to \"intelligent agent mode\" with one click using the Ctrl-K shortcut.\n\nThe tool features a large 128K token context window, making it suitable for working with extensive codebases. Kimi CLI supports Agent Client Protocol (ACP) out of the box and can be used with any ACP-compatible editor or IDE. It also supports the well-established MCP (Model Context Protocol) config convention. The tool is positioned as a competitor to Claude Code and other terminal-based AI coding assistants, with coding performance comparable to Claude 4.5 and GLM 4.6."}]},{"type":"header","level":3,"content":"Languages","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Any","plainChildren":""}]}]},{"type":"header","level":3,"content":"Notes","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Dual-Mode Operation: Seamless switching between Shell and AI agent mode using Ctrl-K","plainChildren":""},{"type":"item","level":3,"content":"Context Window: 128K tokens for large codebase support","plainChildren":""},{"type":"item","level":3,"content":"Protocol Support: Native ACP (Agent Client Protocol) support, MCP config convention","plainChildren":""},{"type":"item","level":3,"content":"Performance: Comparable to Claude 4.5 and GLM 4.6 in coding tasks","plainChildren":""},{"type":"item","level":3,"content":"Installation: Available via Python/PyPI","plainChildren":""},{"type":"item","level":3,"content":"Open Source: Code available on GitHub","plainChildren":""},{"type":"item","level":3,"content":"Release Status: Currently in technical preview","plainChildren":""},{"type":"item","level":3,"content":"IDE Integration: Compatible with any ACP-compatible editor or IDE","plainChildren":""}]}]},{"type":"header","level":3,"content":"Last Update","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"2025-11-18","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Licensing","children":[{"type":"header","level":3,"content":"Opensource","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"License","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"-","plainChildren":""}]}]},{"type":"header","level":3,"content":"Free Trial","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Open source and freely available","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"header","level":3,"content":"MCP-Client","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Supports MCP (Model Context Protocol) config convention","plainChildren":""}]}]},{"type":"header","level":3,"content":"Prompts","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"Tools","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Supports Agent Client Protocol (ACP)","plainChildren":""},{"type":"item","level":3,"content":"Compatible with ACP-compatible tools and IDEs","plainChildren":""}]}]},{"type":"header","level":3,"content":"Resources","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"GitHub repository: https://github.com/MoonshotAI/kimi-cli","plainChildren":""},{"type":"item","level":3,"content":"Installation via Python/PyPI","plainChildren":""},{"type":"item","level":3,"content":"Documentation in repository","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Deployment","children":[{"type":"header","level":3,"content":"BYOK","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"-","plainChildren":""}]}]},{"type":"header","level":3,"content":"LocalOffline","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"-","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Developer Experience","children":[{"type":"header","level":3,"content":"ContextManagement","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"128K token context window","plainChildren":""},{"type":"item","level":3,"content":"Maintains context across Shell and agent modes","plainChildren":""}]}]},{"type":"header","level":3,"content":"DirectFileReferences","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"Checkpoints","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"-","plainChildren":""}]}]},{"type":"header","level":3,"content":"GitSupport","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"header","level":3,"content":"Plugins","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"-","plainChildren":""}]}]},{"type":"header","level":3,"content":"Hooks","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"-","plainChildren":""}]}]},{"type":"header","level":3,"content":"SlashCommands","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"-","plainChildren":""}]}]},{"type":"header","level":3,"content":"Custom Modes","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Dual-mode design: Shell mode and AI agent mode","plainChildren":""},{"type":"item","level":3,"content":"Toggle between modes with Ctrl-K","plainChildren":""}]}]},{"type":"header","level":3,"content":"Subagents","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"-","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Ungrouped Criteria","children":[{"type":"header","level":3,"content":"Terminal","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]}]}],"sourcePath":"kimi-cli.md"},{"type":"header","level":1,"content":"Kiro CLI - https://www.example.com","children":[{"type":"text","content":"<!-- Add the comparison entry name plus canonical URL on first line. -->\n\n<!-- Describe this comparison entry using one or two paragraphs. -->"},{"type":"header","level":2,"content":"General Info","children":[{"type":"text","content":"<!-- General Info -->"},{"type":"header","level":3,"content":"Classification","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Code/Terminal","plainChildren":""},{"type":"item","level":3,"content":"Code/Autonomous agent","plainChildren":""},{"type":"item","level":3,"content":"Product/Prototyping","plainChildren":""},{"type":"item","level":3,"content":"AIE/Model","plainChildren":""},{"type":"item","level":3,"content":"Kiro CLI is the terminal client for AWS's Kiro agentic development platform; it brings agent-driven, spec-driven development flows to the shell and can act autonomously to modify multiple files, run tools, and follow project \"steering\" files.","plainChildren":""}]},{"type":"text","content":"<!-- AI Native Dev ainativedev.io Classification -->\n<!-- Keep only the label values that apply to this comparison. Add any supporting notes using indented \"- \" entries beneath the kept values. -->"}]},{"type":"header","level":3,"content":"Version","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"GA (General Availability)","plainChildren":""},{"type":"item","level":3,"content":"Kiro CLI is the production/GA release of AWS's Kiro platform (the successor to Amazon Q Developer CLI). No single semantic version number is published like an open-source repo; updates are rolled out by AWS.","plainChildren":""}]},{"type":"text","content":"<!-- Latest version used for update -->"}]},{"type":"header","level":3,"content":"Repo","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"-","plainChildren":""},{"type":"item","level":3,"content":"Kiro CLI is an AWS-managed product (no public GitHub repo for the core product). Documentation and download links are published by AWS.","plainChildren":""}]},{"type":"text","content":"<!-- Associated Github repository -->"}]},{"type":"header","level":3,"content":"Rating","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"-","plainChildren":""}]},{"type":"text","content":"<!-- Avg rating based on review comments -->"}]},{"type":"header","level":3,"content":"Short Description","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Terminal client for AWS Kiro — an agentic, spec-driven development assistant that uses steering files, MCP integration, and custom agents to scaffold, modify and debug code from the command line.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Description","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Kiro CLI is the command-line interface for AWS's Kiro platform. It exposes the same agentic development capabilities available in the Kiro IDE to developers who prefer working in a terminal. Key capabilities include spec-driven workflows (spec generation and implementation), project \"steering\" via markdown files in a .kiro/steering/ directory, Model Context Protocol (MCP) integrations to surface external data sources, custom agents tailored to team workflows, and an Auto agent that selects optimal models for tasks.","plainChildren":""},{"type":"item","level":3,"content":"The CLI can open editors for long prompts, accept multimodal inputs (including screenshots in supported workflows), manage MCP servers, create and run agents, and checkpoint/rollback agent actions. It is intended for interactive development tasks (scaffolding, debugging, infra-as-code) and for automations where an agent can operate across multiple files and tools within a repository.","plainChildren":""}]},{"type":"text","content":"<!-- Few paragraphs about the product -->"}]},{"type":"header","level":3,"content":"Languages","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Any","plainChildren":""},{"type":"item","level":3,"content":"Kiro is language-agnostic and can operate on repositories in virtually any language. Commonly used languages include JavaScript/TypeScript, Python, Java, Go, Rust, C#, C/C++, Ruby and others — the agent uses repository context and steering files to follow project conventions rather than being limited to a specific language.","plainChildren":""}]},{"type":"text","content":"<!-- Any or limited list of supported programming Languages -->\n<!-- Keep only the label values that apply to this comparison. Add any supporting notes as indented \"- \" entries beneath the kept values. -->"}]},{"type":"header","level":3,"content":"Notes","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Kiro CLI shares steering files and configuration with the Kiro IDE, enabling consistent behavior across IDE and terminal workflows.","plainChildren":""},{"type":"item","level":3,"content":"The product is a managed AWS offering that uses subscriptions/credits for model usage; teams manage access via AWS Identity Center and related AWS account controls.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Last Update","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"2025-11-24","plainChildren":""},{"type":"item","level":3,"content":"File updated with researched details about Kiro CLI (steering, MCP, Auto agent, CLI features).","plainChildren":""}]},{"type":"text","content":"<!-- Note Date last updated -->"}]}]},{"type":"header","level":2,"content":"Licensing","children":[{"type":"text","content":"<!-- Licensing -->"},{"type":"header","level":3,"content":"Opensource","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""},{"type":"item","level":3,"content":"Kiro CLI is an AWS-managed commercial product; the core product is not published as open source.","plainChildren":""}]},{"type":"text","content":"<!-- Coding tool is released under opensource license -->\n<!-- Keep only the label values that apply to this comparison. Choose either Yes or No and remove the other, or delete both if unknown. Add any supporting notes using indented \"- \" entries beneath the kept values. -->"}]},{"type":"header","level":3,"content":"License","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Proprietary","plainChildren":""},{"type":"item","level":3,"content":"Distributed and operated by AWS under their commercial terms; third-party models accessible via the service are subject to their respective licenses.","plainChildren":""}]},{"type":"text","content":"<!-- Opensource specific license or Proprietary for other commercial licenses -->\n<!-- Keep only the label values that apply to this comparison. Add any supporting notes using indented \"- \" entries beneath the kept values. -->"}]},{"type":"header","level":3,"content":"Free Trial","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"-","plainChildren":""},{"type":"item","level":3,"content":"Pricing and trial/credit offers are managed by AWS; availability of trial credits can vary by account and promotion — refer to AWS Kiro documentation or the Kiro subscription portal for current offers.","plainChildren":""}]},{"type":"text","content":"<!-- Free access (like opensource), or free (potentially limited) trial available -->\n<!-- Keep only the label values that apply to this comparison. Choose either Yes or No and remove the other, or delete both if unknown. Add any supporting notes using indented \"- \" entries beneath the kept values. -->"}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"text","content":"<!-- Coding tool has built-in MCP client so can connect to MCP servers -->"},{"type":"header","level":3,"content":"MCP-Client","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Kiro CLI supports the Model Context Protocol (MCP) and can register/connect to MCP servers to extend context (docs, APIs, data sources). MCP server configuration and management commands are available in the CLI.","plainChildren":""}]},{"type":"text","content":"<!-- Coding tool has built-in MCP client so can connect to MCP servers -->\n<!-- Keep only the label values that apply. Choose either Yes or No and remove the other, or delete both if unknown. Add any supporting notes as indented \"- \" entries beneath the kept values. -->"}]},{"type":"header","level":3,"content":"Prompts","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"The CLI supports both short interactive prompts and longer multi-line prompts (which open the user's configured editor). Prompts may include steering file context and repository files automatically.","plainChildren":""}]},{"type":"text","content":"<!-- Default description for Prompts -->\n<!-- Keep only the label values that apply. Choose either Yes or No and remove the other, or delete both if unknown. Add any supporting notes as indented \"- \" entries beneath the kept values. -->"}]},{"type":"header","level":3,"content":"Tools","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Kiro agents can run pre-approved tools (linters, formatters, test runners, shell commands) and teams can control which tools an agent is permitted to execute.","plainChildren":""}]},{"type":"text","content":"<!-- Default description for Tools -->\n<!-- Keep only the label values that apply. Choose either Yes or No and remove the other, or delete both if unknown. Add any supporting notes as indented \"- \" entries beneath the kept values. -->"}]},{"type":"header","level":3,"content":"Resources","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"The CLI consumes steering files, repository files, MCP server data, and system/workspace metadata as resources to ground agent actions.","plainChildren":""}]},{"type":"text","content":"<!-- Default description for Resources -->\n<!-- Keep only the label values that apply. Choose either Yes or No and remove the other, or delete both if unknown. Add any supporting notes as indented \"- \" entries beneath the kept values. -->"}]}]},{"type":"header","level":2,"content":"Deployment","children":[{"type":"text","content":"<!-- Deployment -->"},{"type":"header","level":3,"content":"BYOK","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""},{"type":"item","level":3,"content":"Kiro is a managed AWS product with models and routing controlled by the service; it does not generally function as a BYOK wrapper for arbitrary external LLM API keys.","plainChildren":""}]},{"type":"text","content":"<!-- Bring Your Own LLM API Key supported -->\n<!-- Keep only the label values that apply. Choose either Yes or No and remove the other, or delete both if unknown. Add any supporting notes as indented \"- \" entries beneath the kept values. -->"}]},{"type":"header","level":3,"content":"LocalOffline","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""},{"type":"item","level":3,"content":"Kiro CLI is designed to integrate with AWS-managed services and models; it is not designed as an offline, self-hosted LLM stack.","plainChildren":""}]},{"type":"text","content":"<!-- Support for local on-site deployment or local offline use -->\n<!-- Keep only the label values that apply. Choose either Yes or No and remove the other, or delete both if unknown. Add any supporting notes as indented \"- \" entries beneath the kept values. -->"}]}]},{"type":"header","level":2,"content":"Developer Experience","children":[{"type":"text","content":"<!-- Developer Experience -->"},{"type":"header","level":3,"content":"ContextManagement","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Context is managed via steering files in .kiro/steering/ (workspace and global scopes), AGENTS.md, MCP servers, and automatic workspace/system context injection.","plainChildren":""}]},{"type":"text","content":"<!-- Methods for managing and updating the context. -->\n<!-- Keep only the label values that apply. Choose either Yes or No and remove the other, or delete both if unknown. Add any supporting notes as indented \"- \" entries beneath the kept values. -->"}]},{"type":"header","level":3,"content":"DirectFileReferences","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Agents can read repository files and steering files; prompts and agent actions can reference files directly so the agent sees the actual source it will modify.","plainChildren":""}]},{"type":"text","content":"<!-- Can with @file or similar provide context. -->\n<!-- Keep only the label values that apply. Choose either Yes or No and remove the other, or delete both if unknown. Add any supporting notes as indented \"- \" entries beneath the kept values. -->"}]},{"type":"header","level":3,"content":"Checkpoints","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"The CLI offers checkpointing/rollback semantics for agent actions so users can revert agent changes or step back through execution stages.","plainChildren":""}]},{"type":"text","content":"<!-- A way to undo using checkpoints or if autocommitted git history -->\n<!-- Keep only the label values that apply. Choose either Yes or No and remove the other, or delete both if unknown. Add any supporting notes as indented \"- \" entries beneath the kept values. -->"}]},{"type":"header","level":3,"content":"GitSupport","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Kiro integrates with Git-based workflows (reads repository state, can create commits/branches as part of agent operations) and is designed to operate inside standard Git repos.","plainChildren":""}]},{"type":"text","content":"<!-- Coding tool is aware of GIT and can work/integrate with GIT repos -->\n<!-- Keep only the label values that apply. Choose either Yes or No and remove the other, or delete both if unknown. Add any supporting notes as indented \"- \" entries beneath the kept values. -->"}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"text","content":"<!-- Is it possible to extend or customize the system in any way -->"},{"type":"header","level":3,"content":"Plugins","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Kiro supports custom agents, hooks and project-specific steering which together provide extensibility similar to plugins. Teams can define agents optimized for particular workflows.","plainChildren":""}]},{"type":"text","content":"<!-- A method of bundling together commands, agents and hooks (claude). -->\n<!-- Keep only the label values that apply. Choose either Yes or No and remove the other, or delete both if unknown. Add any supporting notes as indented \"- \" entries beneath the kept values. -->"}]},{"type":"header","level":3,"content":"Hooks","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Lifecycle hooks can be configured to run tests, linters, or other automation at defined points in agent workflows.","plainChildren":""}]},{"type":"text","content":"<!-- Lifecycle events for the agent. -->\n<!-- Keep only the label values that apply. Choose either Yes or No and remove the other, or delete both if unknown. Add any supporting notes as indented \"- \" entries beneath the kept values. -->"}]},{"type":"header","level":3,"content":"SlashCommands","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""},{"type":"item","level":3,"content":"The CLI exposes subcommands rather than chat-style slash commands; interactive chat in the CLI supports editor invocation and commands but not a separate slash-command registry in the same sense as chat UIs.","plainChildren":""}]},{"type":"text","content":"<!-- Re-usable commands that can be manually triggered by the user. -->\n<!-- Keep only the label values that apply. Choose either Yes or No and remove the other, or delete both if unknown. Add any supporting notes as indented \"- \" entries beneath the kept values. -->"}]},{"type":"header","level":3,"content":"Custom Modes","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Custom agents and steering files create specialist modes for different tasks (e.g., backend agent, frontend agent, devops agent).","plainChildren":""}]},{"type":"text","content":"<!-- Create specialist modes that enable you to tailor the chat experience for specific tasks. -->\n<!-- Keep only the label values that apply. Choose either Yes or No and remove the other, or delete both if unknown. Add any supporting notes as indented \"- \" entries beneath the kept values. -->"}]},{"type":"header","level":3,"content":"Subagents","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Users can create focused agents for specific responsibilities; these agents have pre-approved tools, dedicated steering/context, and can persist configuration across sessions.","plainChildren":""}]},{"type":"text","content":"<!-- Define specialized AI subagents for task-specific workflows. -->\n<!-- Keep only the label values that apply. Choose either Yes or No and remove the other, or delete both if unknown. Add any supporting notes as indented \"- \" entries beneath the kept values. -->"}]}]}],"sourcePath":"kiro-cli.md"},{"type":"header","level":1,"content":"Kiro - https://kiro.run/","children":[{"type":"text","content":"Fast, lightweight CLI coding utility that brings AI-powered development assistance to the terminal. A new terminal-focused coding tool emphasizing speed and developer productivity."},{"type":"header","level":2,"content":"General Info","children":[{"type":"header","level":3,"content":"Classification","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Code/Terminal","plainChildren":""}]}]},{"type":"header","level":3,"content":"Version","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"2025","plainChildren":""}]}]},{"type":"header","level":3,"content":"Repo","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"-","plainChildren":""}]}]},{"type":"header","level":3,"content":"Rating","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"-","plainChildren":""}]}]},{"type":"header","level":3,"content":"Short Description","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Fast, lightweight CLI coding utility designed for terminal-based AI-assisted development workflows.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Description","children":[{"type":"text","content":"Kiro is a new command-line coding utility that focuses on speed and simplicity for terminal-based developers. It provides AI-powered coding assistance directly in the terminal environment, making it easy to generate code, debug issues, and perform development tasks without leaving the command line. Kiro emphasizes a minimal footprint and fast response times, making it ideal for developers who prefer terminal-based workflows."}]},{"type":"header","level":3,"content":"Languages","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Any","plainChildren":""}]}]},{"type":"header","level":3,"content":"Notes","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Speed-focused: Designed for fast response times and minimal latency.","plainChildren":""},{"type":"item","level":3,"content":"Lightweight: Minimal resource footprint for quick startup and operation.","plainChildren":""},{"type":"item","level":3,"content":"Terminal-native: Built specifically for command-line development workflows.","plainChildren":""},{"type":"item","level":3,"content":"New tool released in 2025 targeting CLI-focused developers.","plainChildren":""},{"type":"item","level":3,"content":"Emphasizes developer productivity through simplicity and speed.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Last Update","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"2025","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Licensing","children":[{"type":"header","level":3,"content":"Opensource","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]},{"type":"header","level":3,"content":"License","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Proprietary","plainChildren":""}]}]},{"type":"header","level":3,"content":"Free Trial","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"header","level":3,"content":"MCP-Client","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]},{"type":"header","level":3,"content":"Prompts","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"Tools","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"Resources","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Deployment","children":[{"type":"header","level":3,"content":"BYOK","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]},{"type":"header","level":3,"content":"LocalOffline","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Developer Experience","children":[{"type":"header","level":3,"content":"ContextManagement","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"DirectFileReferences","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"Checkpoints","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]},{"type":"header","level":3,"content":"GitSupport","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"header","level":3,"content":"Plugins","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]},{"type":"header","level":3,"content":"Hooks","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]},{"type":"header","level":3,"content":"SlashCommands","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"Custom Modes","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]},{"type":"header","level":3,"content":"Subagents","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]}]}],"sourcePath":"kiro.md"},{"type":"header","level":1,"content":"OpenCode - https://opencode.ai","children":[{"type":"text","content":"A terminal-native, open-source AI coding assistant that brings LLM-powered code understanding, generation and editing directly into the developer's terminal. OpenCode focuses on privacy (local-first model support), extensibility (custom actions/skills), and deep integration with developer workflows (git, LSP, shell)."},{"type":"header","level":2,"content":"General Info","children":[{"type":"header","level":3,"content":"Classification","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Code/Terminal","plainChildren":""}]}]},{"type":"header","level":3,"content":"Version","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Unknown (2025-10-19)","plainChildren":""},{"type":"item","level":3,"content":"Version information not available; check repository for current version","plainChildren":""}]}]},{"type":"header","level":3,"content":"Repo","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"https://github.com/sst/opencode","plainChildren":""}]}]},{"type":"header","level":3,"content":"Rating","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"[5] Terminal-native, privacy-first design","plainChildren":""},{"type":"item","level":3,"content":"[5] Broad LLM provider support (Models.dev)","plainChildren":""},{"type":"item","level":3,"content":"[4] Rich toolset for file, shell, and repo operations","plainChildren":""}]}]},{"type":"header","level":3,"content":"Short Description","children":[{"type":"text","content":"A terminal-native, local-first AI coding assistant with a TUI for interactive planning and building; supports local and cloud LLMs, LSP integration, git-aware editing, and extensible skills/actions."}]},{"type":"header","level":3,"content":"Description","children":[{"type":"text","content":"OpenCode is an open-source AI assistant designed for use from the terminal. It provides a conversational interface and a suite of programmatic tools (file operations, grep/glob, patch/apply, diagnostics, shell execution, fetch, Sourcegraph search, etc.) that allow the assistant to read, explain, modify and create code in the context of a repository. OpenCode supports both cloud and local LLMs (through Models.dev and adapters such as Ollama), can initialize project context, produce implementation plans, and then switch to a build mode to apply edits. Its architecture supports extensible actions/skills and hierarchical agents for complex tasks."}]},{"type":"header","level":3,"content":"Languages","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Any","plainChildren":""}]}]},{"type":"header","level":3,"content":"Notes","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Strong privacy posture: can run entirely with local models so source code does not need to be uploaded to third-party APIs.","plainChildren":""},{"type":"item","level":3,"content":"Rich tool set that mirrors common CLI developer actions (ls, grep, view, write, edit, patch, bash) so it can operate robustly on repositories.","plainChildren":""},{"type":"item","level":3,"content":"Useful workflow modes: Plan mode (no edits, design/strategy) and Build mode (apply changes). Includes undo/redo for edits.","plainChildren":""},{"type":"item","level":3,"content":"Integrates with LSP/diagnostics for precise error detection and fixes.","plainChildren":""},{"type":"item","level":3,"content":"Extensible via custom actions/skills and supports spawning sub-agents for task decomposition.","plainChildren":""},{"type":"item","level":3,"content":"Good fit for polyglot environments and CI/CD automation where a terminal-first interface and scriptability are advantages.","plainChildren":""},{"type":"item","level":3,"content":"Main website: https://opencode.ai — repo and docs live at https://github.com/sst/opencode","plainChildren":""}]}]},{"type":"header","level":3,"content":"Last Update","children":[{"type":"text","content":"2025-10-19"}]}]},{"type":"header","level":2,"content":"Licensing","children":[{"type":"header","level":3,"content":"Opensource","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"License","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"MIT","plainChildren":""}]}]},{"type":"header","level":3,"content":"Free Trial","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"N/A","plainChildren":""},{"type":"item","level":3,"content":"Open-source software (permanently free), not a time-limited trial","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"header","level":3,"content":"MCP-Client","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"Prompts","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Includes built-in prompt templates and system prompts used by agents (Plan, Build) and subagents.","plainChildren":""},{"type":"item","level":3,"content":"Supports user-customizable prompts/skills and slash-style commands for common workflows (e.g. /init, /undo, /redo).","plainChildren":""},{"type":"item","level":3,"content":"Prompts and agent configurations can be saved and reused as part of session state.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Tools","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Provides a programmatic toolset for repository operations: file read/write/patch, grep/glob, shell execution, diagnostics via LSP, fetch/http, Sourcegraph search, and git-aware actions.","plainChildren":""},{"type":"item","level":3,"content":"Tools are exposed to the assistant for robust, repeatable edits and automated workflows.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Resources","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Official docs and usage guides: https://opencode.ai/docs","plainChildren":""},{"type":"item","level":3,"content":"Repository with examples, configuration and adapters: https://github.com/sst/opencode","plainChildren":""},{"type":"item","level":3,"content":"Community and changelog available via the repo's issues and releases pages.","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Deployment","children":[{"type":"header","level":3,"content":"BYOK","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"LocalOffline","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Supports running with local model backends (e.g. Ollama) and Models.dev adapters.","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Developer Experience","children":[{"type":"header","level":3,"content":"ContextManagement","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"OpenCode builds and maintains repository-aware context by scanning and indexing the project (repository analysis via `/init`) and persisting session state and conversation history in SQLite. It exposes project-scoped sessions, keeps file associations, and uses LSP and file-system reads to surface relevant snippets when answering questions or generating changes. See: https://github.com/sst/opencode and https://opencode.ai/docs","plainChildren":""}]}]},{"type":"header","level":3,"content":"DirectFileReferences","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Files can be directly referenced and manipulated via the CLI/TUI: file explorer panels, explicit read/view/edit actions, patch/apply operations, and path-based prompts. The assistant can open specific files, show diffs, write changes, and apply/revert patches programmatically.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Checkpoints","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"OpenCode supports undo/redo for edits, persistent session history (SQLite), and shows diffs/patches to review before applying. It also integrates with Git workflows so developers can rely on VCS history as an additional checkpoint mechanism.","plainChildren":""}]}]},{"type":"header","level":3,"content":"GitSupport","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"header","level":3,"content":"Extensible","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"Plugins","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Extensible via actions/skills, model adapters, and custom commands. Developers can add new \"skills\" or adapters (e.g., Ollama, Models.dev connectors) and script bespoke tool integrations. There is no single centralized marketplace documented; extensibility is file- and config-driven in the repo.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Hooks","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""},{"type":"item","level":3,"content":"There are no widely-documented lifecycle \"hook\" events for agent-generated actions similar to webhooks or lifecycle callbacks. Extensibility is provided via custom actions/skills and command extensions rather than a formal lifecycle hook system (see actions/skills and custom commands in the docs/repo).","plainChildren":""}]}]},{"type":"header","level":3,"content":"SlashCommands","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"OpenCode provides slash-style commands for common workflows (examples include `/init` to analyze a repo, `/undo` and `/redo` to revert or restore changes). Users can create custom commands/prompts to speed repetitive interactions.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Custom Modes","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"OpenCode provides at least two explicit modes: Plan Mode (read-only design/planning) and Build Mode (apply edits). Modes can be toggled in the TUI (Tab key), enabling different agent behaviours (e.g., generate a plan vs. make changes).","plainChildren":""}]}]},{"type":"header","level":3,"content":"Subagents","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"The architecture supports hierarchical agents and the spawning of sub-agents (subtasks/skills) for decomposing complex work into smaller steps; custom actions/skills can act as specialized subagents for domain tasks.","plainChildren":""}]}]}]}],"sourcePath":"opencode.md"},{"type":"header","level":1,"content":"Warp - https://www.warp.dev","children":[{"type":"text","content":"Modern AI-powered terminal and agentic development environment focused on unifying natural-language agents, terminal commands, and collaborative \"Drive\" features for teams."},{"type":"header","level":2,"content":"General Info","children":[{"type":"header","level":3,"content":"Classification","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Code/Terminal","plainChildren":""}]}]},{"type":"header","level":3,"content":"Version","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"v2.0 (2025-09-01)","plainChildren":""},{"type":"item","level":3,"content":"Specific release date unavailable; major v2.0 release occurred in September 2025","plainChildren":""}]}]},{"type":"header","level":3,"content":"Repo","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"https://www.warp.dev","plainChildren":""}]}]},{"type":"header","level":3,"content":"Rating","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"[5] Best-in-class terminal + AI integration (Agent Mode, Drive, Warp Code)","plainChildren":""},{"type":"item","level":3,"content":"[4] Commercial/proprietary product; some enterprise privacy controls but limited public BYOK/local-offline detail","plainChildren":""}]}]},{"type":"header","level":3,"content":"Short Description","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"AI-powered terminal and Agentic Development Environment (ADE) that combines natural-language Agent Mode, Warp Code (live diffing and stepwise code edits), and Warp Drive (shared Workflows, Notebooks, prompts and environment variables) to enable collaborative, model-driven development workflows within the terminal.### Description","plainChildren":""}]},{"type":"text","content":"Warp is a modern terminal that has evolved into an \"Agentic Development Environment\" (ADE). It tightly integrates large language models and agent workflows with the command line, providing natural-language command generation, an interactive chat/agent interface (Agent Mode), collaborative Drive features (Workflows, Notebooks, shared Environment Variables), and code-focused tooling (Warp Code with diff-tracking). Warp's interface lets developers mix prompts and shell commands in a single input, run multi-step agent plans, review and accept diffs produced by agents, and share/run parameterized Workflows across teams."}]},{"type":"header","level":3,"content":"Languages","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Any","plainChildren":""}]}]},{"type":"header","level":3,"content":"Notes","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Key features: Agent Mode (natural language -> commands), Warp Code (diff-tracking and stepwise code edits by agents), Drive (shared Workflows and Notebooks), Planning Mode and multi-agent orchestration.","plainChildren":""},{"type":"item","level":3,"content":"Privacy controls: granular autonomy settings (allowlists/denylists, pause/approve diffs, control file access), network logging, and zero-data-retention guarantees for enterprise customers.","plainChildren":""},{"type":"item","level":3,"content":"Strengths: Unified UX for prompt + shell input, native diff review for agent-made changes, strong collaboration primitives for teams.","plainChildren":""},{"type":"item","level":3,"content":"Limitations / unknowns: public documentation is limited on BYOK (bring-your-own-key) and fully offline local LLM operation; product is proprietary which may limit on-premise customization for some organizations.","plainChildren":""},{"type":"item","level":3,"content":"Recommended when: you want a first-class terminal with integrated AI agents and team sharing (Drive), and you prefer an opinionated, commercial product with enterprise privacy controls rather than an open-source self-hosted solution.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Last Update","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"2025-11-16","plainChildren":""},{"type":"item","level":3,"content":"Note: This date may reflect documentation update; actively maintained commercial product","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Licensing","children":[{"type":"header","level":3,"content":"Opensource","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]},{"type":"header","level":3,"content":"License","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Proprietary","plainChildren":""}]}]},{"type":"header","level":3,"content":"Free Trial","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"header","level":3,"content":"MCP-Client","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Warp supports selecting/modeling different hosted LLM providers and includes enterprise features like zero-data-retention guarantees and proxying; it exposes autonomy controls for when agents may call MCP servers without human approval.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Prompts","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Supports natural-language input as the primary interface; stored prompt templates and reusable prompts are persisted in Warp Drive and can seed Workflows and agents. Agents present a plan before execution and prompts can be edited or parameterized per Workflow.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Tools","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Agents can invoke shell commands as tools, interact with Git, run code edits via Warp Code, call selected LLM providers via configured MCP/model integrations, and execute Drive Workflows.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Resources","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Warp Drive stores shared resources (Workflows, Notebooks, commands, prompts, and environment variables) that agents can access as contextual artifacts.","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Deployment","children":[{"type":"header","level":3,"content":"BYOK","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Warp allows configuration of LLM providers and supports enterprise proxy/BYOK arrangements (customer-supplied API keys or proxying) in enterprise plans. Public documentation is limited on fully self-hosted/on-prem BYOK flows; contact sales/enterprise docs for details.","plainChildren":""}]}]},{"type":"header","level":3,"content":"LocalOffline","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""},{"type":"item","level":3,"content":"Note: Warp runs a local classifier to detect natural-language input, and some metadata/local processing happens on-device, but AI requests are typically proxied to selected LLM providers (OpenAI, Anthropic/Claude variants) unless explicitly configured via enterprise arrangements. There is no broadly-documented fully-offline LLM mode for the AI assistant as of the latest public releases.","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Developer Experience","children":[{"type":"header","level":3,"content":"ContextManagement","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Methods include attaching files and images, referencing file paths, persisting Drive artifacts (Workflows/Notebooks/Env vars), and allowing agents to request additional context interactively during multi-step plans.","plainChildren":""}]}]},{"type":"header","level":3,"content":"DirectFileReferences","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"You can reference and attach specific files/paths as context for agents; Warp Code surfaces file-level diffs and agents can propose edits to particular files which are shown in the live diff UI.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Checkpoints","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Warp provides live diff review and approval before applying changes; edits from agents can be accepted, rejected or modified and then committed to Git. Drive artifacts also provide shared versions and history for collaborative workflows.","plainChildren":""}]}]},{"type":"header","level":3,"content":"GitSupport","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Git workflows are supported via the terminal and Warp's code/diff UX; the tool is used to author and review code diffs produced by agents.","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"header","level":3,"content":"Extensible","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Support for Workflows, Notebooks, Drive-based sharing and agent configuration enables extensibility of team knowledge and repeatable automation patterns.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Plugins","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""},{"type":"item","level":3,"content":"No public plugin marketplace or documented plugin API; extensibility is primarily via Drive Workflows, Notebook artifacts, and model/agent configuration.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Hooks","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""},{"type":"item","level":3,"content":"No documented lifecycle hook API for agents; control is provided via agent permissions, allowlists/denylists and approval workflows.","plainChildren":""}]}]},{"type":"header","level":3,"content":"SlashCommands","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""},{"type":"item","level":3,"content":"No public global slash-command system documented; parameterized Workflows serve as invocable shortcuts and templates.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Custom Modes","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Built-in modes include Command Mode, Agent Mode, and Planning Mode. Agent autonomy and behavior can be tuned per agent/Workflow (pause-for-approval, review diffs, allowlists/denylists).","plainChildren":""}]}]},{"type":"header","level":3,"content":"Subagents","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Warp supports running multiple agents and orchestrating multi-agent workflows. While there is multi-agent orchestration and task chaining, there is no widely-published \"subagent API\" name — orchestration is handled via the agent management UI and planning features.","plainChildren":""}]}]}]}],"sourcePath":"warp.md"}]