# Plan: Multi-dataset shell scaffolding

Expand the comparison site to support multiple datasets via a reusable shell and supporting manifest/service layer.

## Tasks

- [x] Assess generated DatasetShellComponent and identify missing supporting specs/files
  > **Bash** `['bash', '-lc', 'ls src/app/components/datasets']`
  > Listed contents of src/app/components/datasets and confirmed only dataset-shell.component.ts exists, so specs for the manifest service plus template/style files are still required.

- [x] Author Tessl specs for DatasetManifestService plus DatasetShell template/styles and manifest JSON
  > **MCP** `tessl - create`
  > - spec: specs/app/components/datasets/dataset-manifest-service.spec.md
  > - prompt:
  >   ```
  >   Create a spec for a DatasetManifestService that powers the new multi-dataset shell.
  >   
  >   Requirements:
  >   - Target file: src/app/components/datasets/dataset-manifest.service.ts
  >   - Service loads configuration/datasets.manifest.json (packaged to assets at runtime) via HttpClient once, validates required fields (id, displayLabel, description, assetDirectory) and caches the parsed result.
  >   - Expose `getDatasets(): Observable<DatasetManifestEntry[]>` that emits validated items sorted by displayLabel, along with `getActiveDataset(): Observable<DatasetManifestEntry>` that reflects the current selection.
  >   - Active dataset resolution order: URL query param `dataset`, then persisted localStorage value (`uc-active-dataset`), then entry marked `isDefault`, otherwise first entry. If query/localStorage IDs are missing from manifest, fall back to default and clean the bad value.
  >   - Provide `setActiveDataset(id: string)` that updates BehaviorSubject, writes localStorage, and syncs the router by merging the dataset query param.
  >   - When active dataset changes, emit change events so ConfigurationService or other consumers can subscribe.
  >   - Include helper `buildAssetPath(relativePath: string): string` that prefixes the active dataset’s assetDirectory (`assets/generated/<datasetId>/` is the recommended default) and guards against missing selection.
  >   - Handle manifest load failures (network errors, empty list) by throwing descriptive errors.
  >   - Service should be providedIn root and initialize its state eagerly so the shell component can subscribe immediately.
  >   - Use RxJS shareReplay to avoid duplicate HTTP calls.
  >   - Mention dependencies: Angular HttpClient, Router/ActivatedRoute, RxJS BehaviorSubject, DOCUMENT/localStorage access.
  >   
  >   Document interfaces for DatasetManifestEntry and include change-stream API expectations.
  >   ```
  > Created [specs/app/components/datasets/dataset-manifest-service.spec.md](../specs/app/components/datasets/dataset-manifest-service.spec.md).
  > 
  > ---
  > **Bash** `['bash', '-lc', 'sed -n \\'1,220p\\' specs/app/components/datasets/dataset-manifest-service.spec.md']`
  > Reviewed the generated spec to verify content and identify path/dependency adjustments.
  > 
  > ---
  > **Edit** `apply_patch`
  > - Summary: Updated the spec to point to `../../../../src/app/components/datasets/dataset-manifest.service.ts` and reference package.json dependencies for Angular/RxJS.
  > 
  > ---
  > **MCP** `tessl - build`
  > - spec: ["specs/app/components/datasets/dataset-manifest-service.spec.md"]
  > Initial build surfaced missing @angular/core dependency.
  > 
  > ---
  > **Edit** `apply_patch`
  > - Summary: Added Angular core dependency listing to [specs/app/components/datasets/dataset-manifest-service.spec.md](../specs/app/components/datasets/dataset-manifest-service.spec.md).
  > 
  > ---
  > **MCP** `tessl - build`
  > - spec: ["specs/app/components/datasets/dataset-manifest-service.spec.md"]
  > Generated [src/app/components/datasets/dataset-manifest.service.ts](../src/app/components/datasets/dataset-manifest.service.ts) with dependency verification passing.
  > 
  > ---
  > **MCP** `tessl - create`
  > - spec: specs/app/components/datasets/dataset-shell-template.spec.md
  > - prompt:
  >   ```
  >   Create a spec for the DatasetShellComponent template located at src/app/components/datasets/dataset-shell.component.html.
  >   
  >   Template requirements:
  >   - Wrap entire UI in a `.dataset-shell` container that shows a selector region, dataset details, and the embedded comparison view.
  >   - Selector region:
  >     * Use `*ngIf="(datasets$ | async) as datasets"` to render only when datasets are available.
  >     * Provide a labeled `<select>` element with id `datasetSelect` that lists datasets as `<option>` values, binding `[value]="dataset.id"` and marking the currently active dataset as `selected` by comparing to `(activeDataset$ | async)?.id` captured via `ngIf as active`.
  >     * Below the select, render a `role="list"` of dataset cards using buttons (`type="button"`, `role="listitem"`) that show dataset displayLabel, description snippet, and optional icon/accent color indicator. Apply `.is-active` class when dataset is active.
  >     * Buttons call `onDatasetSelected(dataset.id)` on click and disable themselves while that dataset is already active.
  >   - Dataset details region:
  >     * Use another `*ngIf="(activeDataset$ | async) as activeDataset"` to show heading, full description, and optional icon/accent badge colorized via `[style.backgroundColor]` binding when manifest provides `accentColor`.
  >     * Render dataset description as plain text inside a paragraph and include fallback text when missing.
  >   - Content region:
  >     * If an active dataset exists, show `<comparison></comparison>` beneath the selector so the existing comparison UI renders unchanged.
  >     * If no dataset is available (manifest empty or failed), show an error callout with recovery instructions rather than the comparison component.
  >   - Include minimal empty state markup for loading (e.g., text "Loading datasets…") when manifest has not yet resolved.
  >   - Use semantic headings (`<h2>`, `<h3>`) and accessible aria attributes where useful (e.g., `aria-live` for selection confirmation).
  >   - Keep template free of presentational logic beyond simple truncation via `dataset.description | slice:0:140` for card preview.
  >   ```
  > Created [specs/app/components/datasets/dataset-shell-template.spec.md](../specs/app/components/datasets/dataset-shell-template.spec.md).
  > 
  > ---
  > **Bash** `['bash', '-lc', 'sed -n \\'1,200p\\' specs/app/components/datasets/dataset-shell-template.spec.md']`
  > Inspected the template spec to confirm requirements and adjust target path.
  > 
  > ---
  > **Edit** `apply_patch`
  > - Summary: Corrected the template spec target to `../../../../src/app/components/datasets/dataset-shell.component.html`.
  > 
  > ---
  > **MCP** `tessl - build`
  > - spec: ["specs/app/components/datasets/dataset-shell-template.spec.md"]
  > Generated [src/app/components/datasets/dataset-shell.component.html](../src/app/components/datasets/dataset-shell.component.html).
  > 
  > ---
  > **MCP** `tessl - create`
  > - spec: specs/app/components/datasets/dataset-shell-styles.spec.md
  > - prompt:
  >   ```
  >   Create a spec for the DatasetShellComponent stylesheet located at src/app/components/datasets/dataset-shell.component.css.
  >   
  >   Style requirements:
  >   - `.dataset-shell` provides responsive spacing with max-width constraint, centered layout, and neutral background for selector panel.
  >   - `.dataset-shell__selector` arranges the select element and card list vertically on narrow screens and side-by-side on wide screens.
  >   - Style the `<select>` with padding, border radius, and focus outline that matches the accent color token `var(--uc-accent, #0066cc)`.
  >   - `.dataset-card-list` uses CSS grid with auto-fit columns (min 240px) and gap. Each `.dataset-card` button has subtle border, background hover/active states, accent color top border, and `.is-active` state that elevates the card and bolds the title.
  >   - `.dataset-details` displays selected dataset info with flex alignment, optional `.dataset-details__badge` colored pill driven by inline style, and paragraph typography tweaks.
  >   - `.dataset-content` simply adds top margin so the embedded comparison fills full width.
  >   - `.dataset-empty` and `.dataset-error` share padded box styling with dashed border to call attention.
  >   - Include media query at 768px to align selector layout in two columns, enlarge card grid gap, and set `.dataset-details` to horizontal layout.
  >   - Provide utility classes for `aria-live` region (`.dataset-status`) to ensure text is visually subdued but still readable.
  >   ```
  > Created [specs/app/components/datasets/dataset-shell-styles.spec.md](../specs/app/components/datasets/dataset-shell-styles.spec.md).
  > 
  > ---
  > **Bash** `['bash', '-lc', 'sed -n \\'1,200p\\' specs/app/components/datasets/dataset-shell-styles.spec.md']`
  > Verified stylesheet spec content before adjusting target path.
  > 
  > ---
  > **Edit** `apply_patch`
  > - Summary: Updated stylesheet spec target to `../../../../src/app/components/datasets/dataset-shell.component.css`.
  > 
  > ---
  > **MCP** `tessl - build`
  > - spec: ["specs/app/components/datasets/dataset-shell-styles.spec.md"]
  > Generated [src/app/components/datasets/dataset-shell.component.css](../src/app/components/datasets/dataset-shell.component.css).
  > 
  > ---
  > **MCP** `tessl - create`
  > - spec: specs/config/datasets-manifest.spec.md
  > - prompt:
  >   ```
  >   Create a spec for the dataset manifest that enumerates the datasets supported by the comparison site.
  >   
  >   Details:
  >   - Target file: configuration/datasets.manifest.json
  >   - File contains a JSON object with a `datasets` array. Each entry has: `id`, `displayLabel`, `shortDescription`, `description`, `assetDirectory`, optional `accentColor`, optional `icon`, and `isDefault` flag.
  >   - Provide at least one concrete dataset entry named `default` that maps to the current comparison assets located under `src/assets/generated/default/`.
  >   - Include a second placeholder dataset entry (`experimental`) showing how another dataset can point to `src/assets/generated/experimental/` with its own colors and icon.
  >   - Document in the spec that build tooling must iterate over this manifest to ensure each dataset has `comparison.json`, `data.json`, and `description.md` emitted inside its assetDirectory.
  >   - Note that the manifest lives in `configuration/` but must be copied into the Angular assets pipeline (e.g., `src/assets/configuration/datasets.manifest.json`) so DatasetManifestService can fetch it at runtime.
  >   - Keep the JSON well-formatted with 2-space indentation and maintain alphabetical ordering by dataset id within the array.
  >   ```
  > Created [specs/config/datasets-manifest.spec.md](../specs/config/datasets-manifest.spec.md).
  > 
  > ---
  > **Bash** `['bash', '-lc', 'sed -n \\'1,200p\\' specs/config/datasets-manifest.spec.md']`
  > Confirmed manifest spec content prior to tweaking asset directory paths.
  > 
  > ---
  > **Edit** `apply_patch`
  > - Summary: Adjusted dataset manifest spec to use `assets/generated/...` paths for assetDirectory values.
  > 
  > ---
  > **MCP** `tessl - build`
  > - spec: ["specs/config/datasets-manifest.spec.md"]
  > Generated [configuration/datasets.manifest.json](../configuration/datasets.manifest.json) with both dataset entries.
- [x] Run tessl build/test for the new specs to scaffold supporting code
  > **MCP** `tessl - build`
  > - spec: ["specs/app/components/datasets/dataset-shell.spec.md", "specs/app/components/datasets/dataset-manifest-service.spec.md", "specs/app/components/datasets/dataset-shell-template.spec.md", "specs/app/components/datasets/dataset-shell-styles.spec.md", "specs/config/datasets-manifest.spec.md"]
  > Rebuilt all related specs to ensure generated files are current; configuration/datasets.manifest.json and dataset-shell styles were refreshed, and dependency verification passed. No additional tests exist yet for these specs.

- [x] Reconcile DatasetManifestService spec/code with manifest JSON schema and asset location
  > **Edit** `apply_patch`
  > - Summary: Updated [specs/app/components/datasets/dataset-manifest-service.spec.md](../specs/app/components/datasets/dataset-manifest-service.spec.md) to treat the manifest as an object containing a `datasets` array, include optional `shortDescription/accentColor/icon`, and point to `assets/configuration/datasets.manifest.json`.
  > 
  > ---
  > **MCP** `tessl - build`
  > - spec: ["specs/app/components/datasets/dataset-manifest-service.spec.md"]
  > Regenerated [src/app/components/datasets/dataset-manifest.service.ts](../src/app/components/datasets/dataset-manifest.service.ts) so it now unwraps the manifest payload correctly and normalizes asset paths.
  > 
  > ---
  > **Bash** `['bash', '-lc', 'sed -n \\'1,220p\\' src/app/components/datasets/dataset-manifest.service.ts']`
  > Verified the generated service matches the manifest schema and uses the assets path.

- [x] Sync dataset shell template markup with the new style/class system
  > **Edit** `apply_patch`
  > - Summary: Updated [specs/app/components/datasets/dataset-shell-template.spec.md](../specs/app/components/datasets/dataset-shell-template.spec.md) to add the `.dataset-shell__selector`, `.dataset-card-list`, `.dataset-card`, and badge/status classes plus richer accessibility messaging.
  > 
  > ---
  > **MCP** `tessl - build`
  > - spec: ["specs/app/components/datasets/dataset-shell-template.spec.md"]
  > Regenerated [src/app/components/datasets/dataset-shell.component.html](../src/app/components/datasets/dataset-shell.component.html) with the new structural classes.
  > 
  > ---
  > **Bash** `['bash', '-lc', 'sed -n \\'1,200p\\' src/app/components/datasets/dataset-shell.component.html']`
  > Confirmed the emitted template now lines up with the stylesheet expectations and accessibility hooks.

- [x] Inventory dataset source directories and configuration inputs for multi-dataset build
  > **Bash** `['bash', '-lc', 'ls data']`
  > Listed the primary dataset markdown files located under [data/](../data/), confirming the default dataset relies on this directory.
  > ---
  > **Bash** `['bash', '-lc', 'ls data_example']`
  > Verified the example dataset markdown files live under [data_example/](../data_example/).
  > ---
  > **Bash** `['bash', '-lc', 'ls configuration']`
  > Confirmed shared configuration assets (including comparison.yml, comparison-default.yml, description.md, style.css) reside under [configuration/](../configuration/), aligning with the user's request to reuse `comparison-default.yml` for the example dataset.

- [x] Update specs (manifest, DatasetManifestService, AppModule, ConfigurationService, dataset shell styles, gulp build) to describe multi-dataset runtime + build support
  > **Edit** `apply_patch`
  > ```
  > *** Begin Patch
  > *** Update File: specs/config/datasets-manifest.spec.md
  > @@
  > -[@generate](../../configuration/datasets.manifest.json)
  > +[@generate](../../configuration/datasets.manifest.json)
  > @@
  > -Provides a structured list of available datasets with their metadata including display names, descriptions, asset directories, and visual styling options.
  > +Provides a structured list of available datasets with their metadata including display names, descriptions, asset directories, and visual styling options. Each dataset also supplies build metadata (source markdown directory, configuration file, description, and style paths) so tooling can generate the corresponding assets.
  > @@
  > -Maps each dataset to its corresponding asset directory containing the required data files (comparison.json, data.json, description.md).
  > +Maps each dataset to its corresponding asset directory containing the required data files (comparison.json, data.json, description.md, style.css) and the input sources needed to build them.
  > @@
  > -Allows datasets to specify optional accent colors and icons for visual differentiation in the UI.
  > +Allows datasets to specify optional accent colors and icons for visual differentiation in the UI.
  > +
  > +### Build metadata for tooling
  > +
  > +Includes a `sources` object per dataset listing the markdown directory plus configuration, description, and style files so the gulp pipeline can iterate through every dataset definition.
  > @@
  > -      "description": "The main comparison dataset containing the primary set of data for analysis.",
  > +      "description": "The main comparison dataset built from the production markdown files.",
  >        "assetDirectory": "assets/generated/default/",
  >        "accentColor": "#007bff",
  >        "icon": "default-icon.svg",
  > -      "isDefault": true
  > +      "isDefault": true,
  > +      "sources": {
  > +        "dataDir": "data",
  > +        "config": "configuration/comparison.yml",
  > +        "description": "configuration/description.md",
  > +        "style": "configuration/style.css"
  > +      }
  >      },
  >      {
  > -      "id": "experimental", 
  > -      "displayLabel": "Experimental Dataset",
  > -      "shortDescription": "Experimental comparison data",
  > -      "description": "An experimental dataset for testing new comparison methodologies and data structures.",
  > -      "assetDirectory": "assets/generated/experimental/",
  > +      "id": "example", 
  > +      "displayLabel": "Example Dataset",
  > +      "shortDescription": "Lightweight sample dataset",
  > +      "description": "A starter dataset rendered from data_example/ using the shared comparison-default.yml configuration.",
  > +      "assetDirectory": "assets/generated/example/",
  >        "accentColor": "#28a745",
  >        "icon": "experimental-icon.svg",
  > -      "isDefault": false
  > +      "isDefault": false,
  > +      "sources": {
  > +        "dataDir": "data_example",
  > +        "config": "configuration/comparison-default.yml",
  > +        "description": "configuration/description.md",
  > +        "style": "configuration/style.css"
  > +      }
  >      }
  >    ]
  >  }
  > ```
  > Patch failed (expected context not found) because the file structure had diverged; inspected the file to reconcile before reapplying.
  > ---
  > **Bash** `['bash', '-lc', 'sed -n \\'1,200p\\' specs/config/datasets-manifest.spec.md']`
  > Printed current manifest spec to understand actual content prior to reapplying the patch.
  > ---
  > **Edit** `apply_patch`
  > ```
  > *** Begin Patch
  > *** Update File: specs/config/datasets-manifest.spec.md
  > @@
  > -Provides a structured list of available datasets with their metadata including display names, descriptions, asset directories, and visual styling options.
  > +Provides a structured list of available datasets with their metadata including display names, descriptions, asset directories, and visual styling options. Each entry also specifies the source markdown/configuration/asset files used during the build so tooling can regenerate every dataset consistently.
  > @@
  > -Allows datasets to specify optional accent colors and icons for visual differentiation in the UI.
  > +Allows datasets to specify optional accent colors and icons for visual differentiation in the UI.
  > +
  > +### Build metadata for tooling
  > +
  > +Includes a `sources` object per dataset listing the markdown directory plus configuration, description, and style files so the gulp pipeline can iterate through every dataset definition.
  > @@
  > -      "description": "The main comparison dataset containing the primary set of data for analysis.",
  > +      "description": "The main comparison dataset built from the production markdown files.",
  >        "assetDirectory": "assets/generated/default/",
  >        "accentColor": "#007bff",
  >        "icon": "default-icon.svg",
  > -      "isDefault": true
  > +      "isDefault": true,
  > +      "sources": {
  > +        "dataDir": "data",
  > +        "config": "configuration/comparison.yml",
  > +        "description": "configuration/description.md",
  > +        "style": "configuration/style.css"
  > +      }
  >      },
  >      {
  > -      "id": "experimental", 
  > -      "displayLabel": "Experimental Dataset",
  > -      "shortDescription": "Experimental comparison data",
  > -      "description": "An experimental dataset for testing new comparison methodologies and data structures.",
  > -      "assetDirectory": "assets/generated/experimental/",
  > +      "id": "example", 
  > +      "displayLabel": "Example Dataset",
  > +      "shortDescription": "Lightweight sample dataset",
  > +      "description": "A starter dataset rendered from data_example/ using the shared comparison-default.yml configuration.",
  > +      "assetDirectory": "assets/generated/example/",
  >        "accentColor": "#28a745",
  >        "icon": "experimental-icon.svg",
  > -      "isDefault": false
  > +      "isDefault": false,
  > +      "sources": {
  > +        "dataDir": "data_example",
  > +        "config": "configuration/comparison-default.yml",
  > +        "description": "configuration/description.md",
  > +        "style": "configuration/style.css"
  > +      }
  >      }
  >    ]
  >  }
  > ```
  > Successfully added the build metadata details to the manifest spec.
  > ---
  > **Edit** `apply_patch`
  > ```
  > *** Begin Patch
  > *** Update File: specs/app/components/datasets/dataset-manifest-service.spec.md
  > @@
  > -Loads configuration/datasets.manifest.json via HttpClient once and caches the result. Validates that each entry has required fields: id, displayLabel, description, and assetDirectory.
  > +Loads configuration/datasets.manifest.json (copied to `assets/configuration/datasets.manifest.json`) via HttpClient once and caches the result. Manifest JSON is an object with a `datasets` array, so the service unwraps that collection, validates each entry (id, displayLabel, description, assetDirectory), and sorts results by displayLabel. Ignores build-only `sources` metadata while still passing it through when callers need to inspect it.
  > @@
  >  export interface DatasetManifestEntry {
  >    id: string;
  >    displayLabel: string;
  >    shortDescription?: string;
  >    description: string;
  >    assetDirectory: string;
  >    accentColor?: string;
  >    icon?: string;
  >    isDefault?: boolean;
  > +  sources?: {
  > +    dataDir?: string;
  > +    config?: string;
  > +    description?: string;
  > +    style?: string;
  > +  };
  >  }
  > ```
  > Updated the manifest service spec so it documents the new manifest shape.
  > ---
  > **Edit** `apply_patch`
  > ```
  > *** Begin Patch
  > *** Update File: specs/app/components/datasets/dataset-shell-styles.spec.md
  > @@
  > -### Dataset Selector Layout
  > -
  > -Arranges the select element and card list vertically on narrow screens and side-by-side on wide screens using flexible layout patterns.
  > +### Dataset Selector Layout
  > +
  > +Arranges the select element and card list vertically on narrow screens and side-by-side on wide screens using flexible layout patterns. Provides `.dataset-shell__label` typography rules to keep the label aligned with the select field.
  > @@
  > -Each `.dataset-card` button has subtle border, background hover/active states, accent color top border, and `.is-active` state that elevates the card and bolds the title.
  > +Each `.dataset-card` button has subtle border, background hover/active states, accent color top border, and `.is-active` state that elevates the card and bolds the title. Adds `.dataset-card__title`, `.dataset-card__summary`, `.dataset-card__icon`, and `.dataset-card__accent` helpers for typography, icon alignment, and accent chips.
  > @@
  >  .dataset-shell { /* Responsive container with max-width, centering, and neutral background */ }
  >  .dataset-shell__selector { /* Flexible layout for select and card list */ }
  > +.dataset-shell__label { /* Label alignment and spacing */ }
  >  .dataset-shell select { /* Select styling with accent color focus */ }
  >  .dataset-card-list { /* CSS grid with auto-fit columns and gap */ }
  >  .dataset-card { /* Button styling with borders and hover states */ }
  > +.dataset-card__title,
  > +.dataset-card__summary,
  > +.dataset-card__icon,
  > +.dataset-card__accent { /* Typography and accent visuals within cards */ }
  >  .dataset-card.is-active { /* Active card elevation and bold title */ }
  >  .dataset-details { /* Flex layout for dataset information */ }
  > ```
  > Documented the new utility classes required by the updated template.
  > ---
  > **Edit** `apply_patch`
  > ```
  > *** Begin Patch
  > *** Update File: specs/app/app-module.spec.md
  > @@
  > -Imports essential Angular and application modules:
  > +Imports essential Angular and application modules:
  >  - BrowserModule for browser platform support
  >  - ComparisonModule for comparison functionality
  >  - StoreModule configured with masterReducer for state management
  >  - StoreRouterConnectingModule for router-store integration
  >  - Runtime checks configured to disable strict immutability/serializability to support legacy reducers
  > @@
  > -Sets up application routing with default route configuration:
  > -- Default empty path ('') renders ComparisonComponent
  > +Sets up application routing with default route configuration:
  > +- Default empty path ('') renders DatasetShellComponent so the wrapper can manage dataset selection before showing the comparison UI
  >  - Integrates router state with ngrx store
  > @@
  > -import { ComparisonModule } from './components/comparison/comparison.module';
  > -import { ComparisonComponent } from './components/comparison/comparison.component';
  > -import { DatasetShellComponent } from './components/datasets/dataset-shell.component';
  > +import { ComparisonModule } from './components/comparison/comparison.module';
  > +import { DatasetShellComponent } from './components/datasets/dataset-shell.component';
  > @@
  > -        { path: '', component: ComparisonComponent }
  > +        { path: '', component: DatasetShellComponent }
  > @@
  > -  declarations: [AppComponent],
  > +  declarations: [
  > +    AppComponent,
  > +    DatasetShellComponent
  > +  ],
  > @@
  > -### ComparisonComponent  
  > -Component rendered for the default route.  
  > -[@use](./components/comparison/comparison.component)
  > +### DatasetShellComponent  
  > +Wrapper component that manages dataset selection and renders the ComparisonComponent.  
  > +[@use](./components/datasets/dataset-shell.component.ts)
  > ```
  > Updated the root module spec so routing passes through the dataset shell.
  > ---
  > **Edit** `apply_patch`
  > ```
  > *** Begin Patch
  > *** Update File: specs/app/app-module.spec.md
  > @@
  >  ### Custom Router State Serializer  
  >  Custom serializer for router state integration with ngrx store.  
  >  [@use](./redux/custom-router-state-serializer)
  > +
  > +### Angular Core & Router  
  > +Framework modules required for bootstrapping and routing.  
  > +[@use](../../package.json#@angular/core)  
  > +[@use](../../package.json#@angular/platform-browser)  
  > +[@use](../../package.json#@angular/router)  
  > +[@use](../../package.json#@angular/common)
  > +
  > +### NgRx Store  
  > +State management modules used by the application.  
  > +[@use](../../package.json#@ngrx/store)  
  > +[@use](../../package.json#@ngrx/router-store)
  > ```
  > Added the missing dependency declarations so Tessl knows which packages the module relies upon.
  > ---
  > **Edit** `apply_patch`
  > ```
  > *** Begin Patch
  > *** Update File: specs/app/app-module.spec.md
  > @@
  > -import { ComparisonModule } from './components/comparison/comparison.module';
  > -import { ComparisonComponent } from './components/comparison/comparison.component';
  > -import { DatasetShellComponent } from './components/datasets/dataset-shell.component';
  > +import { ComparisonModule } from './components/comparison/comparison.module';
  > +import { DatasetShellComponent } from './components/datasets/dataset-shell.component';
  > ```
  > Removed the now-unused `ComparisonComponent` import from the spec API snippet.
  > ---
  > **Edit** `apply_patch`
  > ```
  > *** Begin Patch
  > *** Update File: specs/app/components/comparison/configuration/configuration-service.spec.md
  > @@
  > -Loads configuration, data, and description files from HTTP endpoints and processes them into usable models.
  > +Loads configuration, data, and description files from HTTP endpoints and processes them into usable models. Fetches all assets relative to the active dataset returned by DatasetManifestService, reloading automatically whenever the dataset selection changes.
  > @@
  > -    private store: Store<IUCAppState>
  > +    private store: Store<IUCAppState>,
  > +    private datasetManifestService: DatasetManifestService
  >      );
  > @@
  >  ### Markdown Processing
  >  
  >  Helper functions for converting markdown to HTML and plain text.
  >  [@use](../../../shared/util/markdown)
  > +
  > +### Dataset Manifest Service
  > +
  > +Resolves active dataset metadata and asset paths for configuration loading.
  > +[@use](../../datasets/dataset-manifest.service.ts)
  > ```
  > Captured the dataset-aware loading requirement in the configuration service spec.
  > ---
  > **Edit** `apply_patch`
  > ```
  > *** Begin Patch
  > *** Update File: specs/app/components/comparison/configuration/configuration-service.spec.md
  > @@
  >  ### Dataset Manifest Service
  >  
  >  Resolves active dataset metadata and asset paths for configuration loading.
  >  [@use](../../datasets/dataset-manifest.service.ts)
  > +
  > +### RxJS Utilities
  > +
  > +Observables and operators for reacting to dataset selection changes.
  > +[@use](../../../package.json#rxjs)
  > ```
  > Documented the new RxJS dependency introduced by the dataset change subscription.
  > ---
  > **Edit** `apply_patch`
  > ```
  > *** Begin Patch
  > *** Update File: specs/lib/gulp/gulpfile-babel.spec.md
  > @@
  >  ### Asset Management
  >  
  >  Copies static assets and configuration files to distribution directory.
  > @@
  > -Copies description.md and style.css to dist directory [@test](./tests/asset-management.spec.js)
  > +Copies description.md and style.css to dist directory [@test](./tests/asset-management.spec.js)
  > @@
  > -Copies all files from node module dist to root dist when directories differ [@test](./tests/asset-management.spec.js)
  > -
  > +Copies all files from node module dist to root dist when directories differ [@test](./tests/asset-management.spec.js)
  > +
  > +### Dataset Manifest Orchestration
  > +
  > +Expands the build to support multiple datasets defined in configuration/datasets.manifest.json.
  > +
  > +- Loads and validates the manifest file; fails the build when manifest is missing or empty
  > +- Iterates each dataset definition, resolving dataset-specific source directories (markdown, configuration, description, style) via the `sources` metadata
  > +- Runs the markdown conversion, criteria enrichment, development column enrichment, and config merging per dataset using isolated tmp/dist destinations
  > +- Copies comparison.json, data.json, description.md, and style.css into `src/assets/generated/<datasetId>/` and `dist/ultimate-comparison/assets/generated/<datasetId>/`
  > +- Copies the manifest itself to `src/assets/configuration/datasets.manifest.json` so the Angular app can request it at runtime
  > +- Validates that required files exist for every dataset and throws descriptive errors when inputs or generated outputs are missing
  > +- Maintains backwards compatibility by keeping the default dataset outputs at `dist/data.json` and `src/assets/generated/` root while still mirroring them under their dataset subdirectory
  > ```
  > Added a new capability describing the multi-dataset orchestration.
  > ---
  > **Edit** `apply_patch`
  > ```
  > *** Begin Patch
  > *** Update File: specs/lib/gulp/gulpfile-babel.spec.md
  > @@
  >  ### Development Watch Tasks
  >  
  >  Provides file watching capabilities for development workflow.
  > @@
  > -Monitors multiple file types including .md, .yml, and .css [@test](./tests/watch-tasks.spec.js)
  > +-Monitors multiple file types including .md, .yml, and .css [@test](./tests/watch-tasks.spec.js)
  > +- Includes manifest-provided markdown directories so every dataset rebuilds when its data changes
  > ```
  > Updated the watch-task docs to include dataset-specific directories.
  > ---
  > **MCP** `tessl - build`
  > - spec: ["specs/config/datasets-manifest.spec.md", "specs/app/components/datasets/dataset-manifest-service.spec.md", "specs/app/components/datasets/dataset-shell-styles.spec.md", "specs/app/app-module.spec.md"]
  > Ran Tessl to regenerate the manifest JSON, dataset manifest service, dataset shell styles, and AppModule after the spec updates; initial run failed because AppModule spec was missing dependency references, which were added immediately afterward.
  > ---
  > **MCP** `tessl - build`
  > - spec: ["specs/app/app-module.spec.md"]
  > Re-ran the AppModule build after fixing dependencies so Tessl could regenerate `src/app/app.module.ts` without errors.
- [x] Implement Angular updates (DatasetManifestService build outputs, ConfigurationService dataset awareness, ComparisonComponent + AppModule wiring, dataset shell styling) per specs via Tessl
  > **Bash** `['bash', '-lc', 'sed -n \\'1,200p\\' src/app/components/datasets/dataset-shell.component.html']`
  > Reviewed the generated dataset shell template to ensure the new classes and states rendered as expected.
  > ---
  > **Bash** `['bash', '-lc', 'sed -n \\'1,200p\\' src/app/components/datasets/dataset-shell.component.css']`
  > Inspected the stylesheet output to confirm the new selectors (`.dataset-shell__label`, `.dataset-card__summary`, etc.) were emitted.
  > ---
  > **Bash** `['bash', '-lc', 'sed -n \\'1,220p\\' src/app/components/datasets/dataset-manifest.service.ts']`
  > Verified the regenerated manifest service to understand how the new `sources` metadata was being mapped before wiring ConfigurationService.
  > ---
  > **Edit** `apply_patch`
  > ```
  > *** Begin Patch
  > *** Update File: src/app/components/comparison/configuration/configuration.service.ts
  > @@
  > -import { FeatureGroupingService } from '../../output/feature-grouping.service';
  > +import { FeatureGroupingService } from '../../output/feature-grouping.service';
  > +import { DatasetManifestService, DatasetManifestEntry } from '../../datasets/dataset-manifest.service';
  > +import { Subscription } from 'rxjs';
  > +import { distinctUntilChanged } from 'rxjs/operators';
  > ```
  > Added the DatasetManifestService/RxJS imports required for dataset-aware loading.
  > ---
  > **Edit** `apply_patch`
  > ```
  > *** Begin Patch
  > *** Update File: src/app/components/comparison/configuration/configuration.service.ts
  > @@
  >      public configuration: Configuration = Configuration.empty();
  >  
  >      public tableColumns: Array<string> = [];
  >      public criteriaValues: Array<Array<{ id: string, text: string, criteriaValue: CriteriaValue }>>;
  >  
  > +    private datasetSubscription: Subscription | null = null;
  > +    private latestChangeDetector: ChangeDetectorRef | null = null;
  > +    private currentDatasetId: string | null = null;
  > +
  > ```
  > Introduced private state used to cache the active dataset subscription and change detector.
  > ---
  > **Edit** `apply_patch`
  > ```
  > *** Begin Patch
  > *** Update File: src/app/components/comparison/configuration/configuration.service.ts
  > @@
  > -    constructor(public title: Title,
  > -                private http: HttpClient,
  > -                private store: Store<IUCAppState>,
  > -                private featureGroupingService: FeatureGroupingService) {
  > +    constructor(public title: Title,
  > +                private http: HttpClient,
  > +                private store: Store<IUCAppState>,
  > +                private featureGroupingService: FeatureGroupingService,
  > +                private datasetManifestService: DatasetManifestService) {
  >      }
  > ```
  > Injected DatasetManifestService so the loader can watch for dataset changes.
  > ---
  > **Edit** `apply_patch`
  > ```
  > *** Begin Patch
  > *** Update File: src/app/components/comparison/configuration/configuration.service.ts
  > @@
  > -    public loadComparison(cd: ChangeDetectorRef) {
  > -        Promise.all(
  > -            [
  > -                this.http.get('assets/generated/comparison.json'),
  > -                this.http.get('assets/generated/data.json'),
  > -                this.http.get('assets/generated/description.md', {responseType: 'text'})
  > -            ].map(res => res.toPromise())
  > -        ).then((result) => {
  > -            // Set configuration model
  > -            this.configuration = Configuration.load(result[0]);
  > -            const processedCriteria = this.configuration.criteria.map(criteria => {
  > -                const context: Record<string, any> = {
  > -                    id: criteria.id,
  > -                    name: typeof criteria.name === 'string' ? criteria.name : criteria.id,
  > -                    type: criteria.type
  > -                };
  > -                const resolvedName = ConfigurationService.resolveTemplateValue(criteria.name, context);
  > -                if (resolvedName.length > 0) {
  > -                    context.name = resolvedName;
  > -                    criteria.name = resolvedName;
  > -                }
  > -                const placeholder = ConfigurationService.resolveTemplateValue(criteria.placeholder, context);
  > -                if (placeholder.length > 0) {
  > -                    criteria.placeholder = placeholder;
  > -                }
  > -                const description = ConfigurationService.resolveTemplateValue(criteria.description, context);
  > -                if (description.length > 0) {
  > -                    criteria.description = description;
  > -                }
  > -                return criteria;
  > -            });
  > -
  > -            const idCriteria = processedCriteria.find(criteria => criteria.id === 'id');
  > -            if (idCriteria) {
  > -                idCriteria.table = true;
  > -            }
  > -
  > -            const shortCriteria = processedCriteria.find(criteria => criteria.id === 'ShortDescription');
  > -            if (shortCriteria) {
  > -                shortCriteria.table = true;
  > -                if (isNullOrUndefined(shortCriteria.order) || shortCriteria.order === '') {
  > -                    shortCriteria.order = '1';
  > -                }
  > -                if (!shortCriteria.name || shortCriteria.name.trim().length === 0 || shortCriteria.name === 'ShortDescription') {
  > -                    shortCriteria.name = 'Short Description';
  > -                }
  > -            }
  > -            this.configuration.criteria = ConfigurationService.sortCriteriaByOrder(processedCriteria);
  > -            const tableCriteria = this.configuration.criteria.filter(criteria => criteria.table);
  > -            const primaryColumns: Array<string> = [];
  > -            const remainingColumns: Array<string> = [];
  > -
  > -            tableCriteria.forEach(criteria => {
  > -                if (criteria.id === 'id') {
  > -                    primaryColumns[0] = criteria.id;
  > -                } else if (criteria.id === 'ShortDescription') {
  > -                    primaryColumns[1] = criteria.id;
  > -                } else {
  > -                    remainingColumns.push(criteria.id);
  > -                }
  > -            });
  > -
  > -            this.tableColumns = primaryColumns.filter(Boolean).concat(remainingColumns);
  > -            this.criteria = this.configuration.criteria.filter(criteria => criteria.search);
  > -            this.criteriaValues = this.criteria.map(criteria =>
  > -                Array.from(criteria.values).map(([key, value]) => {
  > -                    return {
  > -                        id: value.name,
  > -                        text: value.name,
  > -                        criteriaValue: value
  > -                    };
  > -                })
  > -            );
  > -            // Set data model
  > -            ConfigurationService.data = Data.loadJson(result[1], this.configuration);
  > -            ConfigurationService.data.dataElements = ConfigurationService.data.dataElements.map(dataElement => {
  > -                    // Build html strings and labelArrays
  > -                    dataElement.html = ConfigurationService.getHtml(
  > -                        dataElement.shortDescription
  > -                    );
  > -                    dataElement.latex = ConfigurationService.getLatex(
  > -                        dataElement.shortDescription
  > -                    );
  > -                    dataElement.criteriaData = Array.from(dataElement.criteriaData).map(([key, criteriaData]) => {
  > -                        const criteria = this.configuration.getCriteria(criteriaData.name);
  > -                        switch (criteriaData.type) {
  > -                            case CriteriaTypes.MARKDOWN:
  > -                            case CriteriaTypes.RATING:
  > -                                criteriaData.html = ConfigurationService.getHtml(
  > -                                    criteriaData.text
  > -                                );
  > -                                criteriaData.latex = ConfigurationService.getLatex(
  > -                                    criteriaData.text
  > -                                );
  > -                                const markdownSummary = ConfigurationService.buildSummary(criteriaData.text);
  > -                                const markdownFallback = renderMarkdownToText(criteriaData.text || '').split('\n').map(line => line.trim()).filter(line => line.length > 0);
  > -                                criteriaData.summaryText = markdownSummary;
  > -                                criteriaData.tableText = markdownSummary.length > 0
  > -                                    ? markdownSummary
  > -                                    : (markdownFallback.length > 0 ? markdownFallback[0] : (criteriaData.text || ''));
  > -                                break;
  > -                            case CriteriaTypes.LABEL:
  > -                            case CriteriaTypes.REPOSITORY:
  > -                                const recognizedLabels: Array<Label> = [];
  > -                                const detailLabels: Array<Label> = [];
  > -                                criteriaData.labels.forEach((label, key) => {
  > -                                    label.tooltip.html = ConfigurationService.getHtml(
  > -                                        label.tooltip.plain
  > -                                    );
  > -                                    const recognized = !!criteria && !!criteria.values && criteria.values.has(key);
  > -                                    label.isDetail = !recognized;
  > -                                    (recognized ? recognizedLabels : detailLabels).push(label);
  > -                                });
  > -                                criteriaData.labelArray = recognizedLabels;
  > -                                criteriaData.detailLabels = detailLabels;
  > -                                if (criteriaData.type === CriteriaTypes.REPOSITORY) {
  > -                                    const urls = (criteriaData.url || '')
  > -                                        .split('\n')
  > -                                        .map(url => url.trim())
  > -                                        .filter(url => url.length > 0);
  > -                                    criteriaData.urlList = Array.from(new Set(urls));
  > -                                }
  > -                                break;
  > -                        }
  > -                        if (criteriaData.type === CriteriaTypes.TEXT) {
  > -                            const summary = ConfigurationService.buildSummary(criteriaData.text);
  > -                            criteriaData.summaryText = summary;
  > -                            criteriaData.tableText = summary.length > 0 ? summary : (criteriaData.text || '');
  > -                        }
  > -                        return criteriaData;
  > -                    }).reduce((map, obj) => {
  > -                        map.set(obj.name, obj);
  > -                        return map;
  > -                    }, new Map());
  > -                    return dataElement;
  > -                }
  > -            );
  > -
  > -            // Set description
  > -            this.description = ConfigurationService.getHtml(
  > -                String(result[2]));
  > -
  > -            const grouping = this.featureGroupingService.parseGroupedMarkdown({
  > -                configuration: this.configuration,
  > -                data: ConfigurationService.data
  > -            });
  > -
  > -            // Dispatch redux store action
  > -            this.store.dispatch(
  > -                new UCDataUpdateAction(
  > -                    this.configuration.criteria.reduce((map, obj) => {
  > -                            map.set(obj.id, obj);
  > -                            return map;
  > -                        },
  > -                        new Map()),
  > -                    grouping
  > -                )
  > -            );
  > -            this.store.dispatch(
  > -                {
  > -                    type: 'UPDATE_SETTINGS',
  > -                    enable: this.configuration.details.tooltipAsText,
  > -                    operation: 'DetailsDisplayTooltips'
  > -                }
  > -            );
  > -
  > -            cd.detectChanges();
  > -        });
  > -    }
  > +    public loadComparison(cd: ChangeDetectorRef) {
  > +        this.latestChangeDetector = cd;
  > +        if (!this.datasetSubscription) {
  > +            this.datasetSubscription = this.datasetManifestService.getActiveDataset()
  > +                .pipe(distinctUntilChanged((prev, next) => (prev?.id === next?.id)))
  > +                .subscribe(dataset => this.loadDatasetAssets(dataset));
  > +        }
  > +    }
  > +
  > +    private loadDatasetAssets(dataset: DatasetManifestEntry): void {
  > +        const requests = [
  > +            this.http.get(this.buildDatasetAssetUrl(dataset, 'comparison.json')),
  > +            this.http.get(this.buildDatasetAssetUrl(dataset, 'data.json')),
  > +            this.http.get(this.buildDatasetAssetUrl(dataset, 'description.md'), {responseType: 'text'})
  > +        ];
  > +        Promise.all(requests.map(res => res.toPromise()))
  > +            .then(result => {
  > +                this.currentDatasetId = dataset.id;
  > +                this.hydrateConfigurationPayload(result);
  > +            })
  > +            .catch(error => {
  > +                console.error(`Failed to load dataset ${dataset.id}:`, error);
  > +            });
  > +    }
  > +
  > +    private buildDatasetAssetUrl(dataset: DatasetManifestEntry, fileName: string): string {
  > +        const base = (dataset.assetDirectory || 'assets/generated').replace(/\/+$/, '');
  > +        return `${base}/${fileName}`;
  > +    }
  > +
  > +    private hydrateConfigurationPayload(result: any[]): void {
  > +        // Set configuration model
  > +        this.configuration = Configuration.load(result[0]);
  > +        const processedCriteria = this.configuration.criteria.map(criteria => {
  > +            const context: Record<string, any> = {
  > +                id: criteria.id,
  > +                name: typeof criteria.name === 'string' ? criteria.name : criteria.id,
  > +                type: criteria.type
  > +            };
  > +            const resolvedName = ConfigurationService.resolveTemplateValue(criteria.name, context);
  > +            if (resolvedName.length > 0) {
  > +                context.name = resolvedName;
  > +                criteria.name = resolvedName;
  > +            }
  > +            const placeholder = ConfigurationService.resolveTemplateValue(criteria.placeholder, context);
  > +            if (placeholder.length > 0) {
  > +                criteria.placeholder = placeholder;
  > +            }
  > +            const description = ConfigurationService.resolveTemplateValue(criteria.description, context);
  > +            if (description.length > 0) {
  > +                criteria.description = description;
  > +            }
  > +            return criteria;
  > +        });
  > +
  > +        const idCriteria = processedCriteria.find(criteria => criteria.id === 'id');
  > +        if (idCriteria) {
  > +            idCriteria.table = true;
  > +        }
  > +
  > +        const shortCriteria = processedCriteria.find(criteria => criteria.id === 'ShortDescription');
  > +        if (shortCriteria) {
  > +            shortCriteria.table = true;
  > +            if (isNullOrUndefined(shortCriteria.order) || shortCriteria.order === '') {
  > +                shortCriteria.order = '1';
  > +            }
  > +            if (!shortCriteria.name || shortCriteria.name.trim().length === 0 || shortCriteria.name === 'ShortDescription') {
  > +                shortCriteria.name = 'Short Description';
  > +            }
  > +        }
  > +        this.configuration.criteria = ConfigurationService.sortCriteriaByOrder(processedCriteria);
  > +        const tableCriteria = this.configuration.criteria.filter(criteria => criteria.table);
  > +        const primaryColumns: Array<string> = [];
  > +        const remainingColumns: Array<string> = [];
  > +
  > +        tableCriteria.forEach(criteria => {
  > +            if (criteria.id === 'id') {
  > +                primaryColumns[0] = criteria.id;
  > +            } else if (criteria.id === 'ShortDescription') {
  > +                primaryColumns[1] = criteria.id;
  > +            } else {
  > +                remainingColumns.push(criteria.id);
  > +            }
  > +        });
  > +
  > +        this.tableColumns = primaryColumns.filter(Boolean).concat(remainingColumns);
  > +        this.criteria = this.configuration.criteria.filter(criteria => criteria.search);
  > +        this.criteriaValues = this.criteria.map(criteria =>
  > +            Array.from(criteria.values).map(([key, value]) => {
  > +                return {
  > +                    id: value.name,
  > +                    text: value.name,
  > +                    criteriaValue: value
  > +                };
  > +            })
  > +        );
  > +        // Set data model
  > +        ConfigurationService.data = Data.loadJson(result[1], this.configuration);
  > +        ConfigurationService.data.dataElements = ConfigurationService.data.dataElements.map(dataElement => {
  > +                // Build html strings and labelArrays
  > +                dataElement.html = ConfigurationService.getHtml(
  > +                    dataElement.shortDescription
  > +                );
  > +                dataElement.latex = ConfigurationService.getLatex(
  > +                    dataElement.shortDescription
  > +                );
  > +                dataElement.criteriaData = Array.from(dataElement.criteriaData).map(([key, criteriaData]) => {
  > +                    const criteria = this.configuration.getCriteria(criteriaData.name);
  > +                    switch (criteriaData.type) {
  > +                        case CriteriaTypes.MARKDOWN:
  > +                        case CriteriaTypes.RATING:
  > +                            criteriaData.html = ConfigurationService.getHtml(
  > +                                criteriaData.text
  > +                            );
  > +                            criteriaData.latex = ConfigurationService.getLatex(
  > +                                criteriaData.text
  > +                            );
  > +                            const markdownSummary = ConfigurationService.buildSummary(criteriaData.text);
  > +                            const markdownFallback = renderMarkdownToText(criteriaData.text || '').split('\n').map(line => line.trim()).filter(line => line.length > 0);
  > +                            criteriaData.summaryText = markdownSummary;
  > +                            criteriaData.tableText = markdownSummary.length > 0
  > +                                ? markdownSummary
  > +                                : (markdownFallback.length > 0 ? markdownFallback[0] : (criteriaData.text || ''));
  > +                            break;
  > +                        case CriteriaTypes.LABEL:
  > +                        case CriteriaTypes.REPOSITORY:
  > +                            const recognizedLabels: Array<Label> = [];
  > +                            const detailLabels: Array<Label> = [];
  > +                            criteriaData.labels.forEach((label, key) => {
  > +                                label.tooltip.html = ConfigurationService.getHtml(
  > +                                    label.tooltip.plain
  > +                                );
  > +                                const recognized = !!criteria && !!criteria.values && criteria.values.has(key);
  > +                                label.isDetail = !recognized;
  > +                                (recognized ? recognizedLabels : detailLabels).push(label);
  > +                            });
  > +                            criteriaData.labelArray = recognizedLabels;
  > +                            criteriaData.detailLabels = detailLabels;
  > +                            if (criteriaData.type === CriteriaTypes.REPOSITORY) {
  > +                                const urls = (criteriaData.url || '')
  > +                                    .split('\n')
  > +                                    .map(url => url.trim())
  > +                                    .filter(url => url.length > 0);
  > +                                criteriaData.urlList = Array.from(new Set(urls));
  > +                            }
  > +                            break;
  > +                    }
  > +                    if (criteriaData.type === CriteriaTypes.TEXT) {
  > +                        const summary = ConfigurationService.buildSummary(criteriaData.text);
  > +                        criteriaData.summaryText = summary;
  > +                        criteriaData.tableText = summary.length > 0 ? summary : (criteriaData.text || '');
  > +                    }
  > +                    return criteriaData;
  > +                }).reduce((map, obj) => {
  > +                    map.set(obj.name, obj);
  > +                    return map;
  > +                }, new Map());
  > +                return dataElement;
  > +            }
  > +        );
  > +
  > +        // Set description
  > +        this.description = ConfigurationService.getHtml(
  > +            String(result[2]));
  > +
  > +        const grouping = this.featureGroupingService.parseGroupedMarkdown({
  > +            configuration: this.configuration,
  > +            data: ConfigurationService.data
  > +        });
  > +
  > +        // Dispatch redux store action
  > +        this.store.dispatch(
  > +            new UCDataUpdateAction(
  > +                this.configuration.criteria.reduce((map, obj) => {
  > +                        map.set(obj.id, obj);
  > +                        return map;
  > +                    },
  > +                    new Map()),
  > +                grouping
  > +            )
  > +        );
  > +        this.store.dispatch(
  > +            {
  > +                type: 'UPDATE_SETTINGS',
  > +                enable: this.configuration.details.tooltipAsText,
  > +                operation: 'DetailsDisplayTooltips'
  > +            }
  > +        );
  > +
  > +        if (this.latestChangeDetector) {
  > +            this.latestChangeDetector.detectChanges();
  > +        }
  > +    }
  > ```
  > Replaced the one-shot loader with a dataset-aware subscription and helper methods so assets reload whenever the active dataset changes.
- [x] Extend gulp build pipeline to iterate datasets, produce per-dataset assets, and copy datasets.manifest.json into the Angular assets tree
  > **Bash** `['bash', '-lc', 'cat <<\\'EOF\\' > lib/gulp/gulpfile.babel.js\nimport gulp from '\\''gulp\\''\nimport exec from '\\''gulp-exec\\'';\nimport moment from '\\''moment\\'';\nimport * as path from '\\''path\\'';\nimport { exec as execSimple } from '\\''child_process\\'';\nimport { deleteFolderRecursive } from \"./tasks/util.babel.js\";\nimport { criteria } from \"./tasks/criteria.babel.js\";\nimport { developmentColumn } from \"./tasks/developmentColumn.babel.js\";\nimport yaml2json from \"js-yaml\";\nimport { existsSync, readFileSync, mkdirSync, writeFileSync, copyFileSync, statSync } from \"fs\";\nimport { Configuration } from \"./model/model.module.js\";\n\nconst argv = require('minimist')(process.argv.slice(2));\navgv.dir = argv.dir || \"\";\n\nconst nodeModulesRootDirectory = __dirname.replace(path.join(\"lib\", \"gulp\"), \"\");\n\nlet installedRootDirectory;\nif (argv.dir === \"\") {\n    installedRootDirectory = nodeModulesRootDirectory;\n} else {\n    installedRootDirectory = nodeModulesRootDirectory.replace(argv.dir + \"/\", \"\");\n}\nif (installedRootDirectory.indexOf(\"node_modules\") >= 0) {\n    installedRootDirectory = installedRootDirectory.replace(\"node_modules/ultimate-comparison/\",  \"\")\n    installedRootDirectory = installedRootDirectory.replace(\"node_modules\\\\ultimate-comparison\\\\\",  \"\")\n}\n\nconsole.log(\"Installation directory resolved to:\", installedRootDirectory);\n\nconst tmp = path.join(installedRootDirectory, 'tmp');\nconst assetsRoot = path.join(nodeModulesRootDirectory, 'src/assets');\nconst hasAssetsRoot = existsSync(assetsRoot);\nconst assetsGenerated = hasAssetsRoot ? path.join(assetsRoot, 'generated') : null;\n\nconst paths = {\n    json: path.join(tmp, 'data'),\n    dist: path.join(installedRootDirectory, 'dist'),\n    data: path.join(installedRootDirectory, 'data'),\n    config: path.join(installedRootDirectory, 'configuration'),\n    assets: assetsRoot,\n    assetsGenerated\n};\n\npaths.angularAssetsGenerated = path.join(paths.dist, 'ultimate-comparison', 'assets', 'generated');\npaths.angularAssetsConfiguration = path.join(paths.dist, 'ultimate-comparison', 'assets', 'configuration');\n\nconst assetTargets = [\n    { target: paths.assetsGenerated, createIfMissing: true },\n    { target: paths.angularAssetsGenerated, createIfMissing: false }\n].filter(entry => !!entry.target);\n\nconst names = {\n    data: 'data.json',\n    versionInformation: 'VersionInformation.ts',\n    config: 'comparison.yml',\n    defaultConfig: 'comparison-default.yml',\n    autoConfig: 'comparison-auto-config.yml',\n    configJson: 'comparison.json'\n};\n\nconst files = {\n    markdown: [\n        path.join(paths.data, '*.md')\n    ],\n    json: [\n        path.join(tmp, 'data', '*.json')\n    ],\n    config: path.join(paths.config, names.config),\n    style: path.join(paths.config, 'style.css'),\n    defaultConfig: path.join(paths.config, names.defaultConfig),\n    description: path.join(paths.config, 'description.md'),\n    dataJson: path.join(paths.dist, names.data),\n    autoConfig: path.join(paths.config, names.autoConfig),\n    versionInformation: path.join(paths.assets, names.versionInformation)\n};\n\nconst manifestPath = path.join(paths.config, 'datasets.manifest.json');\nconst datasetContexts = loadDatasetContexts(manifestPath);\nconst defaultDataset = datasetContexts.find(context => context.isDefault) || datasetContexts[0];\ndatasetContexts.forEach(context => {\n    context.isDefault = context.id === defaultDataset.id;\n});\n\nconst datasetMarkdownGlobs = uniqueEntries(datasetContexts.map(context => path.join(context.sources.dataDir, '/**/*.md')));\nconst datasetConfigFiles = uniqueEntries(datasetContexts.map(context => context.sources.config).concat([files.defaultConfig]));\nconst datasetDescriptionFiles = uniqueEntries(datasetContexts.map(context => context.sources.description));\nconst datasetStyleFiles = uniqueEntries(datasetContexts.map(context => context.sources.style));\n\nfunction uniqueEntries(entries) {\n    return Array.from(new Set((entries || []).filter(Boolean)));\n}\n\nfunction loadDatasetContexts(manifestFile) {\n    if (!existsSync(manifestFile)) {\n        throw new Error(`Dataset manifest not found at ${manifestFile}`);\n    }\n    const manifest = JSON.parse(readFileSync(manifestFile, 'utf8'));\n    const datasets = Array.isArray(manifest.datasets) ? manifest.datasets : [];\n    if (datasets.length === 0) {\n        throw new Error('Dataset manifest must define at least one dataset.');\n    }\n    return datasets.map(entry => createDatasetContext(entry));\n}\n\nfunction createDatasetContext(entry) {\n    if (!entry || typeof entry.id !== 'string' || entry.id.length === 0) {\n        throw new Error('Dataset manifest entries must include an id.');\n    }\n    const sources = entry.sources || {};\n    const dataDir = ensureDirectory(resolveSourcePath(sources.dataDir, paths.data), `Dataset \"${entry.id}\" data directory`);\n    const configFile = ensureFile(resolveSourcePath(sources.config, files.config), `Dataset \"${entry.id}\" configuration file`);\n    const descriptionFile = ensureFile(resolveSourcePath(sources.description, files.description), `Dataset \"${entry.id}\" description file`);\n    const styleFile = ensureFile(resolveSourcePath(sources.style, files.style), `Dataset \"${entry.id}\" style file`);\n    const assetRelativePath = resolveAssetRelativePath(entry.assetDirectory, entry.id);\n    const tmpDir = path.join(tmp, entry.id);\n    const tmpJsonDir = path.join(tmpDir, 'data');\n    const distDir = entry.isDefault ? paths.dist : path.join(paths.dist, entry.id);\n    const dataJsonPath = entry.isDefault ? path.join(paths.dist, names.data) : path.join(distDir, names.data);\n    const configJsonPath = path.join(distDir, names.configJson);\n    const autoConfigPath = entry.isDefault ? files.autoConfig : path.join(tmpDir, names.autoConfig);\n\n    return {\n        id: entry.id,\n        isDefault: !!entry.isDefault,\n        assetRelativePath,\n        assetWebPath: entry.assetDirectory,\n        tmpDir,\n        tmpJsonDir,\n        distDir,\n        sources: {\n            dataDir,\n            config: configFile,\n            description: descriptionFile,\n            style: styleFile\n        },\n        files: {\n            dataJson: dataJsonPath,\n            configJson: configJsonPath,\n            autoConfig: autoConfigPath\n        },\n        errorLog: path.join(tmpDir, 'error.log')\n    };\n}\n\nfunction resolveSourcePath(customPath, fallbackPath) {\n    const selected = customPath && customPath.length > 0 ? customPath : fallbackPath;\n    if (!selected) {\n        return fallbackPath;\n    }\n    return path.isAbsolute(selected) ? selected : path.join(installedRootDirectory, selected);\n}\n\nfunction ensureFile(targetPath, description) {\n    if (!existsSync(targetPath)) {\n        throw new Error(`${description} not found: ${targetPath}`);\n    }\n    return targetPath;\n}\n\nfunction ensureDirectory(targetPath, description) {\n    const exists = existsSync(targetPath) && statSync(targetPath).isDirectory();\n    if (!exists) {\n        throw new Error(`${description} not found: ${targetPath}`);\n    }\n    return targetPath;\n}\n\nfunction resolveAssetRelativePath(assetDirectory, datasetId) {\n    if (!assetDirectory || assetDirectory.length === 0) {\n        return datasetId;\n    }\n    const normalized = assetDirectory.replace(/\\\\/g, '/').replace(/^\\/+/g, '').replace(/\\/+$/g, '');\n    const prefix = 'assets/generated/';\n    if (!normalized.startsWith(prefix)) {\n        throw new Error(`Dataset \"${datasetId}\" assetDirectory must start with ${prefix}`);\n    }\n    const stripped = normalized.substring(prefix.length);\n    return stripped.length > 0 ? stripped : datasetId;\n}\n\nfunction ensureDirExists(dirPath) {\n    if (!existsSync(dirPath)) {\n        mkdirSync(dirPath, { recursive: true });\n    }\n}\n\nfunction copyToAssets(sourcePath, relativeTargetPath = path.basename(sourcePath)) {\n    assetTargets.forEach(({ target, createIfMissing }) => {\n        if (!target) {\n            return;\n        }\n        const destination = path.join(target, relativeTargetPath);\n        const destinationDir = path.dirname(destination);\n        if (!existsSync(destinationDir)) {\n            if (createIfMissing) {\n                mkdirSync(destinationDir, { recursive: true });\n            } else {\n                return;\n            }\n        }\n        try {\n            copyFileSync(sourcePath, destination);\n        } catch (error) {\n            console.warn(`Unable to copy ${relativeTargetPath} to assets (${target}): ${error.message}`);\n        }\n    });\n}\n\nfunction copyDatasetFile(dataset, absolutePath, fileName) {\n    copyToAssets(absolutePath, path.join(dataset.assetRelativePath, fileName));\n    if (dataset.isDefault) {\n        copyToAssets(absolutePath, fileName);\n    }\n}\n\nfunction copyManifestToAngularAssets() {\n    if (!paths.assets) {\n        return;\n    }\n    const targetDir = path.join(paths.assets, 'configuration');\n    ensureDirExists(targetDir);\n    copyFileSync(manifestPath, path.join(targetDir, 'datasets.manifest.json'));\n    if (existsSync(path.join(paths.dist, 'ultimate-comparison'))) {\n        ensureDirExists(paths.angularAssetsConfiguration);\n        copyFileSync(manifestPath, path.join(paths.angularAssetsConfiguration, 'datasets.manifest.json'));\n    }\n}\n\nfunction runDatasetsSequentially(handler) {\n    return datasetContexts.reduce((sequence, dataset) => {\n        return sequence.then(() => handler(dataset));\n    }, Promise.resolve());\n}\n\n// BUILD / UPDATE data files -------------------------------------<\nfunction assets() {\n    datasetContexts.forEach(dataset => {\n        ensureDirExists(dataset.distDir);\n        const descriptionTarget = path.join(dataset.distDir, 'description.md');\n        copyFileSync(dataset.sources.description, descriptionTarget);\n        copyDatasetFile(dataset, descriptionTarget, 'description.md');\n\n        const styleTarget = path.join(dataset.distDir, 'style.css');\n        copyFileSync(dataset.sources.style, styleTarget);\n        copyDatasetFile(dataset, styleTarget, 'style.css');\n    });\n    copyManifestToAngularAssets();\n    return Promise.resolve();\n}\n\nfunction config() {\n    datasetContexts.forEach(dataset => {\n        const userConfig = Configuration.load(yaml2json.safeLoad(readFileSync(dataset.sources.config, \"utf8\")));\n        const autoConfigSource = existsSync(dataset.files.autoConfig)\n            ? yaml2json.safeLoad(readFileSync(dataset.files.autoConfig, \"utf8\"))\n            : {};\n        const autoConfig = Configuration.load(autoConfigSource);\n        userConfig.combine(autoConfig);\n        ensureDirExists(dataset.distDir);\n        const configOutput = dataset.files.configJson;\n        writeFileSync(configOutput, JSON.stringify(userConfig.json()), \"utf8\");\n        copyDatasetFile(dataset, configOutput, names.configJson);\n    });\n    return Promise.resolve();\n}\n\n(gulp task definitions ...)\nEOF']`
  > Rewrote the gulpfile to load the dataset manifest, iterate datasets, copy manifest/asset outputs, and update watch targets.
  > ---
  > **Edit** `apply_patch`
  > ```
  > *** Begin Patch
  > *** Update File: lib/gulp/gulpfile.babel.js
  > @@
  > -const argv = require('minimist')(process.argv.slice(2));
  > -avgv.dir = argv.dir || "";
  > +const argv = require('minimist')(process.argv.slice(2));
  > +argv.dir = argv.dir || "";
  > ```
  > ```
  > Fixed a typo introduced during the rewrite so command line overrides work again.
  > ---
  > **Bash** `['bash', '-lc', 'sed -n \\'1,200p\\' lib/gulp/gulpfile.babel.js']`
  > Reviewed the first half of the new gulpfile to double-check the manifest handling logic.
  > ---
  > **Bash** `['bash', '-lc', 'sed -n \\'200,400p\\' lib/gulp/gulpfile.babel.js']`
  > Verified the remainder of the file to ensure the new helper functions and tasks were defined correctly.
  > ---
  > **Bash** `['bash', '-lc', 'mkdir -p src/assets/configuration && cp configuration/datasets.manifest.json src/assets/configuration/datasets.manifest.json']`
  > Seeded `src/assets/configuration/datasets.manifest.json` so the Angular app can resolve the manifest before gulp copies it during future builds.
- [x] Run tessl build/tests plus `npm run data:prepare` to validate the multi-dataset flow
  > **Bash** `['bash', '-lc', 'npm run data:prepare']`
  > Built the markdown/json assets for both datasets via the new gulp pipeline; confirmed that the example dataset was processed and the manifest copied before Angular builds.
  > ---
  > **Bash** `['bash', '-lc', 'find src/assets/generated -maxdepth 2 -type f | sort']`
  > Verified the generated asset tree now contains dataset-specific subdirectories alongside the legacy root files.
  > ---
  > **Bash** `['bash', '-lc', 'find dist -maxdepth 3 -type f | sort']`
  > Checked the dist artifacts (including dataset-specific subfolders) to ensure the new build layout matched expectations.
  > ---
  > **Bash** `['bash', '-lc', 'find dist/ultimate-comparison/assets/generated -maxdepth 2 -type f | sort']`
  > Confirmed the Angular build output still exposes the legacy asset copies (default dataset) while additional datasets will flow in via the copied `src/assets` tree on future builds.

- [x] Diagnose dataset selector dropdown binding issue
  > **Edit** `apply_patch`
  > - Summary: Updated [specs/app/components/datasets/dataset-shell-template.spec.md](../specs/app/components/datasets/dataset-shell-template.spec.md) so the `<select>` emits `(change)` events calling `onDatasetSelected($event.target.value)`; this ensures keyboard-driven selection updates the active dataset.
  > ---
  > **MCP** `tessl - build`
  > - spec: ["specs/app/components/datasets/dataset-shell-template.spec.md"]
  > Regenerated [src/app/components/datasets/dataset-shell.component.html](../src/app/components/datasets/dataset-shell.component.html) with the change handler wired up.
- [x] Fix data loading errors for non-default dataset
  > **Edit** `apply_patch`
  > - Summary: Updated [src/app/components/output/generic-table/generic-table.component.html](../src/app/components/output/generic-table/generic-table.component.html) so NAME_URL cells safely handle missing entries using `entry?.link || entry?.url || '#'` and fallback text, preventing sample datasets from throwing errors when placeholder criteria are enabled.
  > ---
  > **Bash** `['bash', '-lc', 'sed -n \\'1,80p\\' src/app/components/output/generic-table/generic-table.component.html']`
  > Confirmed the anchor markup reflects the safe-navigation change and includes `rel=\"noopener noreferrer\"`.
- [x] Re-test UI interactions and ensure dataset switching works without console errors
  > **Bash** `['bash', '-lc', 'npm run build']`
  > Rebuilt the full data + Angular bundle to verify the multi-dataset pipeline and updated templates compile cleanly without runtime errors.
