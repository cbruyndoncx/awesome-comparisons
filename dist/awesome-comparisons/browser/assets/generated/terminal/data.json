[{"type":"header","level":1,"content":"Aider - https://aider.chat","children":[{"type":"text","content":"Aider is the first popular AI Coding CLI, with a fairly recently added webbased gui.\nAider is a python package and frequently updated with a mass following and an active Discord community."},{"type":"header","level":2,"content":"General Info","children":[]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Terminal","plainChildren":""}]}]},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"- Actively maintained open-source project; check https://github.com/Aider-AI/aider for current version    \n\nv0.76.0 (2025-12)"}]},{"type":"header","level":2,"content":"Repo","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"https://github.com/Aider-AI/aider","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"text","content":"- [4] Popular, actively maintained OSS CLI with a large community    \n- [4] Strong Git integration and multi-LLM support; good for whole-repo edits"}]},{"type":"header","level":2,"content":"Short Description","children":[{"type":"text","content":"A terminal-first AI pair-programming CLI (with optional browser UI) that provides repo-aware, multi-file edits, automatic Git commits, and support for multiple remote and local LLM backends."}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"Aider is an open-source AI pair-programming tool focused on the terminal-first developer workflow. It allows developers to chat with LLMs, make multi-file edits, run linters/tests, and commit changes automatically via Git — all from the CLI (with an optional web GUI). Aider works across languages and large codebases by building and using a code-map of the repository to provide context-aware edits. It supports multiple remote LLM providers and local models, enabling private and offline workflows."}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Any","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"text","content":"- BYOK model: users supply API keys for whichever LLM provider they choose (OpenAI, Anthropic, DeepSeek, etc.), allowing control over costs and provider choice.    \n- Local/model support: Aider can connect to local LLMs (self-hosted or via local runtimes), enabling fully offline workflows and private model usage.    \n- Cost optimization: Supports prompt-caching patterns and lets you choose cheaper models or local models to reduce usage costs.    \n- Workflow strengths: deep Git integration (auto-commit with sensible commit messages, undo commit, diff), in-chat file management (/add, /drop), lint/test runs, and automatic retries/fixes when tests fail.    \n- UX features: terminal-first chat, optional web GUI, voice input, ability to ingest web pages/images for context, and pointing to CONVENTIONS.md to enforce project-specific rules.    \n- Installation: pip-based installer (e.g., python -m pip install aider-install; then run aider-install), then run aider in a repo with your chosen model and API key.    \n- Good fit for: teams wanting repo-aware AI edits, those requiring private/local model runs, developers who prefer CLI workflows and Git-backed safety for AI edits.    \n- Limitations/considerations: Aider is a thin orchestration layer — actual model behavior, costs, and availability depend on chosen LLM provider or local runtime; evaluate model performance and token costs for your use case before large-scale adoption."}]},{"type":"header","level":2,"content":"Last Update","children":[{"type":"text","content":"2026-01-30"}]},{"type":"header","level":2,"content":"Licensing","children":[]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"MIT","plainChildren":""}]}]},{"type":"header","level":2,"content":"Free Trial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"N/A","plainChildren":""},{"type":"item","level":1,"content":"Open-source tool (permanently free); users pay their own LLM provider for API usage, not a time-limited trial","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"text","content":"MCP Support"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No"}]}]},{"type":"header","level":2,"content":"Prompts","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Supports configurable prompt templates, system-level prompts, and prompt caching to reduce costs and speed up repeated tasks.","plainChildren":""},{"type":"item","level":1,"content":"Prompts can be adjusted during chat and model selection is switchable in-session.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Tools","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"In-chat commands and workflow tooling: runs linters/tests, shows diffs, and commits changes to Git automatically.","plainChildren":""},{"type":"item","level":1,"content":"Common in-chat commands include: /add (include files), /drop (remove files from context), /model (switch model), /undo (revert last AI change), and /reasoning-effort (control model reasoning depth).","plainChildren":""}]}]},{"type":"header","level":2,"content":"Resources","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Builds a repo code-map for contextual awareness and can ingest files, folders, URLs and images to provide rich contextual resources to the model.","plainChildren":""}]}]},{"type":"header","level":2,"content":"ACP","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Deployment","children":[]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Local Offline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Supports local model usage via adapters (community integrations exist for local runtimes such as Ollama and other self-hosted LLMs)","plainChildren":""}]}]},{"type":"header","level":2,"content":"Developer Experience","children":[]},{"type":"header","level":2,"content":"Context Management","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Maintains a repository code-map to provide broad context and supports targeted context injection via @file, @folder, URLs, and by adding files to the chat.","plainChildren":""},{"type":"item","level":1,"content":"Supports prompt caching and selective file inclusion to manage token usage and focus the model.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Direct File References","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Use @file / @folder references and the in-chat /add command to include specific files or folders in the session for precise edits.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Uses Git commits as checkpoints; Aider auto-commits changes with sensible messages and provides /undo and standard git tooling to revert or inspect history.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Git Support","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Supports multiple LLM backends and local model adapters; configurable via model adapters and API-key settings","plainChildren":""}]}]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"No formal plugin marketplace or plugin API; extensibility is achieved through model adapters, configuration, and local runtime integrations.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"No documented lifecycle hooks API for third-party plugins; automation is typically handled via configuration, scripts and Git workflows.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Provides reusable in-chat slash commands for workflow control (e.g., /add, /drop, /model, /undo, /reasoning-effort, /help).","plainChildren":""}]}]},{"type":"header","level":2,"content":"Skills","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Custom Modes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Built-in chat modes to tailor behavior: code (direct edits), architect (design/planning), ask (questions about code), help (explain Aider features).","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Does not expose a named subagent framework; supports autonomous execution modes (auto-approve) but not first-class subagent definitions.","plainChildren":""}]}]}],"sourcePath":"aider.md"},{"type":"header","level":1,"content":"Antigravity - https://antigravity.dev","children":[{"type":"text","content":"Antigravity is Google's free AI-powered agentic development platform that represents a fundamental shift from traditional manual coding to autonomous agent-driven development. Built as a VSCode fork with multi-agent orchestration capabilities, Antigravity enables AI agents to plan entire projects, write code across multiple files, test applications, and debug issues automatically through an integrated editor, terminal, and browser environment.\n\n**Dataset ID:** terminal"},{"type":"header","level":2,"content":"General Info","children":[]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Terminal","plainChildren":""}]}]},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"Preview (November 2025)"}]},{"type":"header","level":2,"content":"Repo","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Short Description","children":[{"type":"text","content":"Google's free AI-powered agentic IDE with autonomous multi-agent orchestration"}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"Antigravity is an agent-first development platform that functions as a terminal-integrated IDE designed to automate complex development tasks. Unlike traditional coding assistants that provide autocomplete suggestions, Antigravity orchestrates autonomous AI agents that can plan, implement, test, and debug complete features. The platform implements a three-surface architecture consisting of an Editor panel (VSCode-based), Agent Manager, Artifacts panel, Browser preview, and Terminal. As of January 2026, it remains in public preview.\n\nThe platform uses natural language commands triggered through keyboard shortcuts and supports two distinct execution modes: Fast mode for quick tasks and Planning mode for complex tasks requiring approval. Antigravity provides built-in MCP integration for connecting to external tools and services, supports multi-agent parallel execution, and generates transparent artifacts including task lists, implementation plans, and browser recordings that allow developers to verify agent logic and provide feedback."}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Any","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"text","content":"Currently in experimental phase with documented operational issues including crashes and quota-management problems. Uses Gemini 3 Pro as primary model with generous usage limits during preview."}]},{"type":"header","level":2,"content":"Last Update","children":[{"type":"text","content":"2026-01-31"}]},{"type":"header","level":2,"content":"Licensing","children":[]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Proprietary","plainChildren":""}]}]},{"type":"header","level":2,"content":"Free Trial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Free during preview period with generous Gemini 3 Pro usage limits","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"text","content":"MCP Support"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No"}]}]},{"type":"header","level":2,"content":"Prompts","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Tools","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Resources","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"ACP","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Deployment","children":[]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Local Offline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Developer Experience","children":[]},{"type":"header","level":2,"content":"Context Management","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Can include additional context using @ symbol for files, directories, MCP servers","plainChildren":""}]}]},{"type":"header","level":2,"content":"Direct File References","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"@ symbol for referencing files and directories","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Rollback support to undo agent changes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Git Support","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Seamless GitHub integration for commits, pull requests, and issues","plainChildren":""},{"type":"item","level":1,"content":"Complete GitLab support including CI/CD workflows","plainChildren":""},{"type":"item","level":1,"content":"Generates small, reviewable diffs for all agent modifications","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Can reference saved prompts using / symbol","plainChildren":""},{"type":"item","level":1,"content":"Cmd + I for inline completions","plainChildren":""},{"type":"item","level":1,"content":"Cmd + L to toggle agent side panel","plainChildren":""}]}]},{"type":"header","level":2,"content":"Skills","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Custom Modes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Fast mode for quick tasks","plainChildren":""},{"type":"item","level":1,"content":"Planning mode for complex tasks with approvable plans","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Multi-agent parallel execution with specialized agents for browser automation, terminal operations, and file handling","plainChildren":""}]}]}],"sourcePath":"antigravity.md"},{"type":"header","level":1,"content":"Auggie CLI - https://www.augmentcode.com/changelog/auggie-cli","children":[{"type":"text","content":"Auggie is Augment's agentic coding CLI that runs in your terminal. It understands your codebase and helps you ship faster by analyzing code, making safe edits, and automating routine tasks — all via natural language.\n\n**Dataset ID:** terminal"},{"type":"header","level":2,"content":"General Info","children":[]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Terminal","plainChildren":""}]}]},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"v0.5.6 (2025)"}]},{"type":"header","level":2,"content":"Repo","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"https://github.com/augmentcode/auggie","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"text","content":"- [3] Strong context engine with automatic codebase mapping and CI/CD integration    \n- [3] Limited extensibility; no MCP or BYOK support documented"}]},{"type":"header","level":2,"content":"Short Description","children":[{"type":"text","content":"An AI agent that brings Augment Code's power to the terminal, featuring advanced context awareness and flexible integration into developer workflows."}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"Auggie CLI is an agentic coding assistant designed to integrate into every part of your development workflow. Using Augment's leading context engine, it maps project structure, dependencies, and patterns without manual context selection. The tool supports both interactive and non-interactive use, making it flexible for one-off commands, piped input, or integration into build systems.\n\nAuggie can handle up to 10,000 commit histories, ensuring accurate code suggestions and modifications even in large codebases. The tool is positioned as a competitor to Claude Code, Gemini CLI, and other terminal-based AI coding agents."}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Any","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"text","content":"- Installation: Available via npm for Node.js 22 or later (`npm install -g @augmentcode/auggie`)    \n- Context Engine: Automatically maps project structure and dependencies without manual context selection    \n- Flexible Usage: Supports interactive and non-interactive modes, piped input, and build system integration    \n- Codebase Scale: Can handle up to 10,000 commit histories    \n- Competition: Positioned as an alternative to Claude Code, Gemini CLI, and OpenAI's Codex CLI    \n- Released: 2025"}]},{"type":"header","level":2,"content":"Last Update","children":[{"type":"text","content":"2026-01-30"}]},{"type":"header","level":2,"content":"Licensing","children":[]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Proprietary","plainChildren":""}]}]},{"type":"header","level":2,"content":"Free Trial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"text","content":"MCP Support"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No"}]}]},{"type":"header","level":2,"content":"Prompts","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Natural language prompts for code generation, analysis, and modifications","plainChildren":""}]}]},{"type":"header","level":2,"content":"Tools","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Terminal-based tools for code analysis, editing, and automation","plainChildren":""}]}]},{"type":"header","level":2,"content":"Resources","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Official documentation: https://docs.augmentcode.com/cli/overview","plainChildren":""},{"type":"item","level":1,"content":"GitHub repository: https://github.com/augmentcode/auggie","plainChildren":""},{"type":"item","level":1,"content":"Product page: https://www.augmentcode.com/product/CLI","plainChildren":""}]}]},{"type":"header","level":2,"content":"ACP","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Deployment","children":[]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Local Offline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Requires connection to Augment's cloud services for AI capabilities","plainChildren":""}]}]},{"type":"header","level":2,"content":"Developer Experience","children":[]},{"type":"header","level":2,"content":"Context Management","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Advanced context engine that automatically maps project structure, dependencies, and patterns","plainChildren":""},{"type":"item","level":1,"content":"Handles up to 10,000 commit histories","plainChildren":""}]}]},{"type":"header","level":2,"content":"Direct File References","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Can reference and edit specific files based on natural language requests","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Git Support","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Integrates with git repositories and understands commit history","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Custom commands via `auggie command <name>` and slash commands within the TUI. `/rules` for workspace rules viewing.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Skills","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Custom Modes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Interactive mode (full-screen TUI) and automation/print mode (`--print` flag) for CI/CD pipelines.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Ungrouped Criteria","children":[]},{"type":"header","level":2,"content":"Terminal","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]}],"sourcePath":"auggie-cli.md"},{"type":"header","level":1,"content":"Claude Code - https://claude.ai/code","children":[{"type":"text","content":"Claude Code is Anthropic's command-line, agentic developer assistant that integrates Claude models into terminal workflows to help write, refactor, and manage code across repositories."},{"type":"header","level":2,"content":"General Info","children":[]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Terminal","plainChildren":""}]}]},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"v2.1.16 (2026-01)"}]},{"type":"header","level":2,"content":"Repo","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"-","plainChildren":""},{"type":"item","level":1,"content":"Closed-source proprietary product from Anthropic","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"text","content":"- [4] Strong reasoning and long-context handling    \n- [3] Can be costly at the highest-capability model tiers    \n- [4] Excellent for multi-file refactors and end-to-end developer workflows"}]},{"type":"header","level":2,"content":"Short Description","children":[{"type":"text","content":"Claude Code is a terminal-first CLI that exposes Anthropic's Claude models to developer workflows for interactive code generation, multi-file refactors, automated testing, and scripted agentic tasks. It lets developers run prompts, apply edits, execute shell commands, and integrate with git from the terminal while preserving interactive safeguards (permission prompts and commit/checkpoint workflows).\n\n-"}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"Claude Code is a low-level, terminal-first developer tool from Anthropic that exposes Claude family models (Opus, Sonnet, Haiku tiers) to developer workflows. It is intentionally unopinionated and scriptable: it runs in the terminal, integrates with Git and other CLI tools, and can be wired into CI/CD, deployment systems, and custom automation. Claude Code asks permission before making file edits or running commands, and it can be configured to use Anthropic's public API, cloud-hosted model endpoints (e.g., Bedrock, Vertex AI), or organization-managed keys.\n\nThe tool is focused on large-context reasoning, multi-file code transformations, automated testing and verification, and agentic workflows where the assistant can run sequences of commands, apply patches, and validate results. It is suitable for both single developers and teams; for the latter it is offered as part of Anthropic's Team/Enterprise plans with central administration and enhanced security controls."}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Any","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"text","content":"- Models: Offers multiple model tiers (commonly referenced as Opus (highest capability), Sonnet (workhorse), and Haiku (cost-efficient)). Opus is aimed at deep reasoning and large refactors; Sonnet balances cost and capability; Haiku is optimized for high-volume, lower-complexity tasks.    \n- Pricing: Available as seat-based subscriptions (Pro, Max tiers) and pay-as-you-go API token pricing. High-capability models (Opus) carry premium token costs; Sonnet often provides a better cost/performance tradeoff for everyday coding.    \n- Context window: Claude-family models marketed with very large context windows (useful for large repositories and multi-file edits).    \n- Platform support: macOS, Linux, Windows (CLI-first). Windows usage commonly requires Git for Windows for full CLI feature parity.    \n- Use cases: automated refactors, multi-file PR generation, test generation and repair, code review assistance, automated CI hooks, developer productivity automation.    \n- Safety & controls: interactive permission prompts, enterprise controls for data handling, and options to route through organization-managed endpoints.    \n- Ecosystem: community tooling and integrations exist (context engineers, wrappers, \"awesome\" lists) though the official product is closed-source.    \n- Further reading: consult the official Claude documentation at <https://claude.ai/> and the Claude Code overview at <https://claude.ai/code> for up-to-date pricing, model names, and deployment options."}]},{"type":"header","level":2,"content":"Last Update","children":[{"type":"text","content":"2026-01-30"}]},{"type":"header","level":2,"content":"Licensing","children":[]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Proprietary","plainChildren":""}]}]},{"type":"header","level":2,"content":"Free Trial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"text","content":"MCP Support"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No"}]}]},{"type":"header","level":2,"content":"MCP-Prompts","children":[{"type":"text","content":"Prompts"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes"}]}]},{"type":"header","level":2,"content":"MCP-Tools","children":[{"type":"text","content":"Tools"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes"}]}]},{"type":"header","level":2,"content":"MCP-Resources","children":[{"type":"text","content":"Resources"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes"}]}]},{"type":"header","level":2,"content":"ACP","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Claude Code implements the Agent Client Protocol (ACP) by Zed Industries, enabling standardized editor-agent communication over JSON-RPC via stdio. Any ACP-compatible editor or IDE can connect to Claude Code as an agent backend.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Deployment","children":[]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Local Offline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Claude Code relies on remote model endpoints by default. Anthropic and enterprise customers can route requests through cloud provider-hosted model deployments or organization-managed endpoints, but a fully offline/local model runtime is not provided as a standard option.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Developer Experience","children":[]},{"type":"header","level":2,"content":"Context Management","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Claude Code manages context via large-model context windows, automatic inclusion of a repository-level CLAUDE.md, and explicit file-injection/piping. Users can also supply files via stdin or configure the CLI to read specific paths into the session context.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Direct File References","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"The CLI can read files from the working tree, and its workflow includes asking permission to edit files or run commands. Project conventions (CLAUDE.md and .claude command files) are used to teach the assistant about frequently referenced files and commands.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Claude Code integrates with git workflows and presents interactive prompts before making edits; typical usage includes creating commits, reviewable patches, or requiring user confirmation to apply changes so that git history acts as a checkpoint/undo mechanism.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Git Support","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Claude Code supports project-level extensibility via the .claude directory (custom commands and scripts). Users can author reusable command files that become slash-style commands in the CLI, enabling repeatable automations.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Project configuration and command files allow lifecycle-like behaviors (preflight instructions and custom scripts) that the CLI will surface during interactive sessions. Users can document expected behaviors in CLAUDE.md and trigger scripted sequences via custom commands.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Custom project commands placed under .claude/commands are surfaced as slash-style commands and can be invoked from the CLI to run specialized workflows (for example, /project:fix-github-issue).","plainChildren":""}]}]},{"type":"header","level":2,"content":"Skills","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Skills are modular packages in .claude/skills/ containing a SKILL.md with YAML frontmatter (name, description) and optional bundled resources (scripts, references, assets). Only the name and description are loaded into context; full instructions load on demand when the skill triggers.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Custom Modes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"The CLI allows model selection and configurable behaviors (e.g., read-only analysis, aggressive edit mode, or restricted tool sets). Users can create and store project-specific command templates and flags to emulate specialist modes for common tasks.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Claude Code supports agentic, multi-step workflows where the assistant can run sequences of commands, apply edits, run tests, and re-evaluate results. Project scripts and MCP-style integrations can be used to orchestrate more complex subagent behaviors.","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"text","content":"MCP Support"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes"}]}]},{"type":"header","level":2,"content":"MCP-Protocol-Version","children":[{"type":"text","content":"2025-06-18"}]},{"type":"header","level":2,"content":"MCP-Roots","children":[{"type":"text","content":"Roots"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes"}]}]},{"type":"header","level":2,"content":"MCP-Sampling","children":[{"type":"text","content":"Sampling"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No"}]}]},{"type":"header","level":2,"content":"MCP-Tasks","children":[{"type":"text","content":"Tasks"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No"}]}]}],"sourcePath":"claude-code.md","mcpEnrichment":{"clientId":"claude-code","title":"Claude Code","url":"https://claude.com/product/claude-code","protocolVersion":"2025-06-18","capabilities":{"tools":{},"prompts":{},"resources":{},"roots":{},"sampling":false,"elicitation":false,"logging":false,"tasks":false}}},{"type":"header","level":1,"content":"Codex CLI - https://github.com/openai/codex/","children":[{"type":"text","content":"Codex CLI is an open-source command-line interface for interacting with OpenAI's Codex model and other compatible LLM providers."},{"type":"header","level":2,"content":"General Info","children":[]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Terminal","plainChildren":""}]}]},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"v0.89.0 (2026-01-22)"}]},{"type":"header","level":2,"content":"Repo","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"https://github.com/openai/codex","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"text","content":"- [4] Strong community and practitioner assessments    \n- [4] Effective terminal-first coding agent with configurable approval modes"}]},{"type":"header","level":2,"content":"Short Description","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"A terminal-first coding agent that reads, edits, and executes code using LLMs with configurable approval/sandbox modes and provider gateways.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"Codex CLI provides a lightweight, terminal-first agent that lets developers read, modify, and execute code using large language models. It runs tasks in sandboxed environments, can run linters/tests, propose edits, and integrate changes back into a local repository or create pull requests. The CLI supports multiple operation modes (suggest, auto-edit, full-auto) which control how much automation is allowed without user approval."}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Any","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"text","content":"- Supports multiple model providers (OpenAI, OpenRouter, Gemini, Ollama, Mistral, DeepSeek, xAI, Groq and other OpenAI-compatible endpoints) via configuration and gateways.    \n- Configuration stored in ~/.codex/config.toml; users can create reusable prompts and agent settings per-repo.    \n- Operational modes:    \n- Suggest (default): proposes edits and commands; requires user approval before applying changes.    \n- Auto Edit: autonomously reads/writes files, but asks before executing shell commands.    \n- Full Auto: performs reads, writes, and executes commands in a sandboxed, network-disabled environment without additional prompts.    \n- AGENTS.md: repository-level guidance files can be added to help the agent understand project structure, test commands, and conventions.    \n- Useful for exploratory code tasks, automated refactors, running test-fix cycles, and generating PR-ready diffs; best results when the repository includes clear tests and documentation.    \n\nSources: GitHub repository (https://github.com/openai/codex) and project documentation/examples aggregated from public write-ups about Codex CLI and its configuration."}]},{"type":"header","level":2,"content":"Last Update","children":[{"type":"text","content":"2026-01-30"}]},{"type":"header","level":2,"content":"Licensing","children":[]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"MIT","plainChildren":""}]}]},{"type":"header","level":2,"content":"Free Trial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Availability depends on chosen model provider (OpenAI, Ollama, etc.)","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"text","content":"MCP Support"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No"}]}]},{"type":"header","level":2,"content":"Prompts","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Codex CLI supports reusable prompts, per-repo agent settings and prompt templates via configuration files (e.g., ~/.codex/config.toml and repository AGENTS.md).","plainChildren":""}]}]},{"type":"header","level":2,"content":"Tools","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Integrates with local tools (linters, test runners, build commands) and can propose/execute shell commands (subject to approval mode and sandboxing).","plainChildren":""}]}]},{"type":"header","level":2,"content":"Resources","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Can ingest repository files, AGENTS.md guidance, and external web search or provider-specific context when configured.","plainChildren":""}]}]},{"type":"header","level":2,"content":"ACP","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Codex CLI supports the Agent Client Protocol (ACP) by Zed Industries for standardized editor-agent communication via JSON-RPC over stdio.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Deployment","children":[]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Uses API keys for model providers; supports configuring different gateways and provider endpoints.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Local Offline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Primarily uses remote model providers, though configurations and gateways (e.g., Ollama, LiteLLM proxies) can enable local model endpoints in some setups.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Developer Experience","children":[]},{"type":"header","level":2,"content":"Context Management","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Supports persistent guidance via AGENTS.md, per-repo config, and prompt templates; can manage context window by ingesting specified files and project documentation.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Direct File References","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Agents operate directly on repository files, can read and propose edits to specific files, and support passing file content or paths into prompts for context.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Typical workflow uses git commits/diffs and can prepare commits or PRs; interactive modes ask for approval before applying changes, enabling easy rollback via git.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Git Support","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Can produce commits and prepare PR diffs (behavior depends on config and approval mode).","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes (via provider gateways and config)","plainChildren":""}]}]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"The project exposes provider gateways and integrations but does not provide a formal \"plugin\" packaging system in the core CLI (as of last review).","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"There is no documented, generic plugin-hook lifecycle API; repository-level AGENTS.md and config provide the primary customization points.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"The interactive interface supports internal commands (e.g., `/permissions`, `/skill` for enabling/disabling skills) and the CLI exposes flags and subcommands to control operation modes.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Skills","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Custom prompts deprecated in favor of skills for reusable instructions and workflows. `/skill` UI for enabling/disabling individual skills (v0.88.0+).","plainChildren":""}]}]},{"type":"header","level":2,"content":"Custom Modes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Built-in modes (suggest, auto-edit, full-auto) and approval/sandbox configurations let teams tailor agent autonomy and safety boundaries.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Workflows often include specialized agent roles (e.g., review agents, testing agents) and the CLI supports multi-step plans that can incorporate distinct agent behaviors.","plainChildren":""}]}]}],"sourcePath":"codex-cli.md"},{"type":"header","level":1,"content":"CommandCode - https://commandcode.ai","children":[{"type":"text","content":"CommandCode is a terminal-based AI coding agent that continuously learns and adapts to individual developer coding styles and preferences. Using a proprietary meta neuro-symbolic AI model called \"taste-1,\" CommandCode addresses the frustration of AI-generated code that is technically correct but doesn't match personal coding patterns by learning through every interaction and progressively aligning with developer conventions for variable naming, code structure, testing preferences, and architectural patterns.\n\n**Dataset ID:** terminal"},{"type":"header","level":2,"content":"General Info","children":[]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Terminal","plainChildren":""}]}]},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Repo","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Short Description","children":[{"type":"text","content":"Terminal-based AI coding agent with adaptive learning that matches your coding style"}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"CommandCode is a CLI tool that operates as an autonomous coding agent, distinguishing itself through continuous learning capabilities. Unlike traditional AI assistants that reset after each interaction, CommandCode uses its proprietary \"taste-1\" meta neuro-symbolic AI model combining large language models with continuous reinforcement learning to acquire and encode personal coding patterns.\n\nThe agent learns from explicit feedback (accepted/rejected suggestions), implicit feedback (manual edits), and context from project decisions. It stores learned preferences in project memory files (.commandcode/taste/taste.md), allowing progressive improvement across sessions. The system treats every developer action as a learning signal, capturing years of micro-decisions about variable naming conventions, when to extract helper functions, preferred design patterns, and testing structures."}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"TypeScript","plainChildren":""},{"type":"item","level":1,"content":"Python","plainChildren":""},{"type":"item","level":1,"content":"JavaScript","plainChildren":""},{"type":"item","level":1,"content":"HTML","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"text","content":"Installed via npm (npm i -g command-code). Claimed performance improvements include 10x faster coding, 2x faster code reviews, and 5x fewer bugs. Learned taste can be shared across teams using npx taste push/pull commands."}]},{"type":"header","level":2,"content":"Last Update","children":[{"type":"text","content":"2026-01-31"}]},{"type":"header","level":2,"content":"Licensing","children":[]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Proprietary","plainChildren":""}]}]},{"type":"header","level":2,"content":"Free Trial","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"text","content":"MCP Support"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No"}]}]},{"type":"header","level":2,"content":"Prompts","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Tools","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Resources","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"ACP","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Deployment","children":[]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Requires API key from CommandCode.ai","plainChildren":""}]}]},{"type":"header","level":2,"content":"Local Offline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Developer Experience","children":[]},{"type":"header","level":2,"content":"Context Management","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Persistent context management through /memory command system","plainChildren":""},{"type":"item","level":1,"content":"Maintains project-specific information across sessions","plainChildren":""},{"type":"item","level":1,"content":"Contextual memory systems that remember decisions and preferences over time","plainChildren":""}]}]},{"type":"header","level":2,"content":"Direct File References","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Git Support","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Git-aware operations for project understanding","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"/memory for persistent context","plainChildren":""},{"type":"item","level":1,"content":"/resume to continue past conversations","plainChildren":""}]}]},{"type":"header","level":2,"content":"Skills","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Custom Modes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]}],"sourcePath":"commandcode.md"},{"type":"header","level":1,"content":"Crush - https://github.com/charmbracelet/crush","children":[{"type":"text","content":"Crush is a glamorous terminal-based AI coding agent developed by Charmbracelet that integrates multiple large language models directly into terminal workflows. Built with Bubble Tea terminal UI framework, Crush combines AI capabilities with real-time code understanding through Language Server Protocol integration and external system connectivity via Model Context Protocol, providing a visually appealing and intelligent collaborative coding workspace in the command line.\n\n**Dataset ID:** terminal"},{"type":"header","level":2,"content":"General Info","children":[]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Terminal","plainChildren":""}]}]},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"v0.33.2"}]},{"type":"header","level":2,"content":"Repo","children":[{"type":"text","content":"https://github.com/charmbracelet/crush"}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"text","content":"19,107 GitHub stars (as of January 2026)"}]},{"type":"header","level":2,"content":"Short Description","children":[{"type":"text","content":"Terminal-based AI coding agent with glamorous TUI and multi-model LLM support"}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"Crush operates as a CLI-based agentic coding tool that maintains multiple work sessions per project while providing context-aware assistance for development tasks. The tool integrates Language Server Protocols for semantic code understanding, file and directory access, and Model Context Protocol servers for external integrations.\n\nCrush supports multi-model flexibility with providers including OpenAI, Anthropic Claude, Google Gemini, Groq, OpenRouter, and Vercel AI Gateway, with custom provider configurations for both OpenAI-compatible and Anthropic-compatible APIs. Users can switch between different LLMs mid-session without losing conversational context. The platform provides a comprehensive diff and review system allowing developers to inspect proposed changes within the terminal UI before accepting or rejecting modifications."}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Any","plainChildren":""},{"type":"item","level":1,"content":"LSP integration supports any language with LSP implementation available","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"text","content":"Built upon Charmbracelet's broader ecosystem of Go-based libraries and tools. The Charm ecosystem reportedly powers 25,000+ applications. Supports installation via Homebrew, npm, Arch Linux, Go, FreeBSD, and Nix. Recent updates include expandable thinking, improved UI structure, and interface enhancements."}]},{"type":"header","level":2,"content":"Last Update","children":[{"type":"text","content":"2026-01-31"}]},{"type":"header","level":2,"content":"Licensing","children":[]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"FSL","plainChildren":""},{"type":"item","level":1,"content":"FSL-1.1-MIT (business-source license with irrevocable eventual fallback to MIT)","plainChildren":""}]}]},{"type":"header","level":2,"content":"Free Trial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Fully open source with no restrictions","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"text","content":"MCP Support"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No"}]}]},{"type":"header","level":2,"content":"MCP-Prompts","children":[{"type":"text","content":"Prompts"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No"}]}]},{"type":"header","level":2,"content":"MCP-Tools","children":[{"type":"text","content":"Tools"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes"}]}]},{"type":"header","level":2,"content":"MCP-Resources","children":[{"type":"text","content":"Resources"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No"}]}]},{"type":"header","level":2,"content":"ACP","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Deployment","children":[]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Supports custom provider configurations for OpenAI-compatible and Anthropic-compatible APIs","plainChildren":""}]}]},{"type":"header","level":2,"content":"Local Offline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Can work with local or self-hosted LLM providers","plainChildren":""}]}]},{"type":"header","level":2,"content":"Developer Experience","children":[]},{"type":"header","level":2,"content":"Context Management","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Session-based context system with multiple concurrent work sessions per project","plainChildren":""},{"type":"item","level":1,"content":"Each session preserves conversation history and file context across runs","plainChildren":""},{"type":"item","level":1,"content":"Sessions support inheritance (child sessions inherit from parent sessions)","plainChildren":""},{"type":"item","level":1,"content":"crush.md file serves as project context anchor with metadata","plainChildren":""}]}]},{"type":"header","level":2,"content":"Direct File References","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"File and directory access within projects","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Full diff and undo support","plainChildren":""}]}]},{"type":"header","level":2,"content":"Git Support","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Git integration capabilities when present in project","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Skills","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Custom Modes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Session templates for reusable workflow patterns","plainChildren":""},{"type":"item","level":1,"content":"Different session types: Project Sessions, Exploration Sessions, Learning Sessions, Debugging Sessions","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"text","content":"MCP Support"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes"}]}]},{"type":"header","level":2,"content":"MCP-Protocol-Version","children":[{"type":"text","content":"2025-06-18"}]},{"type":"header","level":2,"content":"MCP-Roots","children":[{"type":"text","content":"Roots"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes"}]}]},{"type":"header","level":2,"content":"MCP-Sampling","children":[{"type":"text","content":"Sampling"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No"}]}]},{"type":"header","level":2,"content":"MCP-Tasks","children":[{"type":"text","content":"Tasks"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No"}]}]}],"sourcePath":"crush.md","mcpEnrichment":{"clientId":"crush","title":"Crush","url":"https://github.com/charmbracelet/crush","protocolVersion":"2025-06-18","capabilities":{"tools":{},"prompts":false,"resources":false,"roots":{"listChanged":true},"sampling":false,"elicitation":false,"logging":false,"tasks":false}}},{"type":"header","level":1,"content":"Droid CLI - https://factory.ai/product/cli","children":[{"type":"text","content":"Droid CLI is part of Factory AI's developer platform, offering AI assistants (called Droids) inside IDEs and terminals that maintain context across tools and workflows. Droid is the #1 software development agent on Terminal-Bench.\n\n**Dataset ID:** terminal"},{"type":"header","level":2,"content":"General Info","children":[]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Terminal","plainChildren":""},{"type":"item","level":1,"content":"Code/Autonomous agent","plainChildren":""}]}]},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"- 2025"}]},{"type":"header","level":2,"content":"Repo","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"-","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"text","content":"- [4] State-of-the-art Terminal-Bench performance (58.75% on v0.1.1), rich MCP integration, custom droids and skills    \n- [3] Proprietary platform; enterprise pricing may limit individual adoption"}]},{"type":"header","level":2,"content":"Short Description","children":[{"type":"text","content":"AI software engineering agent from Factory AI that operates in terminals and IDEs with persistent contextual memory across workflows."}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"Droid CLI is Factory AI's autonomous coding agent that provides interactive AI assistants inside IDEs and terminals while maintaining contextual memory across different tools and platforms. With a score of 58.75% on Terminal-Bench, Droid sets the new state-of-the-art for AI agents' ability to complete complex end-to-end tasks in terminal environments.\n\nThe platform offers code completion, PR review suggestions, automated fixes, and can automate workflows from design docs to CI and review. Droid Exec is Factory's headless CLI mode that runs non-interactive commands for automation in CI pipelines, cron jobs, pre-commit hooks, and batch operations. Droids keep their knowledge across tools and platforms, following users through their workflow without losing context."}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Any","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"text","content":"- Terminal-Bench Performance: 58.75% on v0.1.1 (state-of-the-art), testing 80 human-verified, Dockerized tasks    \n- Benchmark Coverage: Coding, build/test, dependency management, data/ML workflows, systems, networking, security, and core CLI    \n- Free Trial: 20M tokens included    \n- Droid Exec: Headless CLI mode for automation (CI pipelines, cron jobs, pre-commit hooks)    \n- Persistent Context: Maintains knowledge across tools and platforms    \n- Features: Code completion, PR reviews, automated fixes, workflow automation    \n- Installation: Simple curl command to get started"}]},{"type":"header","level":2,"content":"Last Update","children":[{"type":"text","content":"2026-01-30"}]},{"type":"header","level":2,"content":"Licensing","children":[]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Proprietary","plainChildren":""}]}]},{"type":"header","level":2,"content":"Free Trial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"20M tokens included","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"text","content":"MCP Support"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No"}]}]},{"type":"header","level":2,"content":"Prompts","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Tools","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Interactive and headless CLI modes","plainChildren":""},{"type":"item","level":1,"content":"Code completion and PR review tools","plainChildren":""},{"type":"item","level":1,"content":"Automated workflow tools","plainChildren":""}]}]},{"type":"header","level":2,"content":"Resources","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Official documentation: https://docs.factory.ai/cli/getting-started/quickstart","plainChildren":""},{"type":"item","level":1,"content":"Product page: https://factory.ai/product/cli","plainChildren":""},{"type":"item","level":1,"content":"Features: https://factorycli.com/features","plainChildren":""}]}]},{"type":"header","level":2,"content":"ACP","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Deployment","children":[]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Custom BYOK models loaded from settings.json. Supports GPT-5.2 and other providers via model selector.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Local Offline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Developer Experience","children":[]},{"type":"header","level":2,"content":"Context Management","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Droids maintain contextual memory across tools and platforms","plainChildren":""},{"type":"item","level":1,"content":"Persistent knowledge throughout workflows","plainChildren":""}]}]},{"type":"header","level":2,"content":"Direct File References","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Git Support","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"PR review suggestions and automated fixes","plainChildren":""},{"type":"item","level":1,"content":"Workflow automation from design docs to CI","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"7 lifecycle hook types with configurable exit codes (success, warning, block, abort). Permanently enabled, no longer experimental. Configurable via `/hooks` command.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Built-in commands: `/statusline`, `/wrapped`, `/settings`, `/hooks`. Tab auto-completion for custom commands.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Skills","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Auto-included Skill tool in custom droids. LLM-powered auto-generation of custom droids for specialized tasks.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Custom Modes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Interactive mode (chat-first REPL) and Droid Exec (headless single-shot for CI/CD). Spec mode presents multiple implementation options.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Custom droids enabled by default. Specialized types: Reliability Droid (incidents), Product Droid (tickets/PM), Knowledge Droid (codebase analysis), Tutorial Droid (onboarding).","plainChildren":""}]}]},{"type":"header","level":2,"content":"Ungrouped Criteria","children":[]},{"type":"header","level":2,"content":"Terminal","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]}],"sourcePath":"droid-cli.md"},{"type":"header","level":1,"content":"Gemini CLI - https://github.com/google-gemini/gemini-cli","children":[{"type":"text","content":"Open-source AI agent that brings Google's Gemini models directly to the terminal. Gemini CLI uses a reason-and-act (ReAct) loop with built-in tools and MCP server integrations to handle complex coding tasks like fixing bugs, creating features, improving test coverage, and automating operational workflows. It supports multimodal input (PDFs, images, sketches), Google Search grounding for real-time context, and a ~1M-token context window.\n\nSince its 2025 launch, Gemini CLI has expanded rapidly with an extensions framework, lifecycle hooks, sub-agents, GitHub Actions integration, and a rebuilt terminal rendering engine with mouse support."},{"type":"header","level":2,"content":"General Info","children":[]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Terminal","plainChildren":""}]}]},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"v0.21.0 (2025-12-15)"}]},{"type":"header","level":2,"content":"Repo","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"https://github.com/google-gemini/gemini-cli","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"text","content":"- [4] Mature open-source CLI agent with strong MCP support, generous free tier, and rapid feature cadence    \n- [3] Extensions and sub-agents ecosystems are still maturing; enterprise features require Vertex AI or Code Assist tiers"}]},{"type":"header","level":2,"content":"Short Description","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Open-source terminal AI agent powered by Google Gemini models, featuring MCP integration, lifecycle hooks, sub-agents, extensions, and a generous free tier (1,000 requests/day).","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"Gemini CLI is Google's open-source command-line AI agent that provides direct access to Gemini models (2.5 Flash, 2.5 Flash-Lite, 2.5 Pro, 3 Flash) in the terminal. It operates via a ReAct loop with built-in tools for file operations, shell commands, web fetching, and Google Search grounding. Developers can extend it through MCP servers, custom extensions, lifecycle hooks, and sub-agents. The tool supports multimodal input, conversation checkpointing, token caching, GEMINI.md context files for per-project customization, and non-interactive scripting for CI/CD automation. A free tier provides 60 requests/minute and 1,000 requests/day with a personal Google account."}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Any","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"text","content":"- Models: Supports Gemini 2.5 Flash, 2.5 Flash-Lite, 2.5 Pro, and 3 Flash, selectable via the `-m` flag. All models share a ~1M-token context window.    \n- Free tier: 60 requests/minute, 1,000 requests/day with a personal Google account. Enterprise users can use Vertex AI or Code Assist Standard/Enterprise.    \n- Rendering engine: v0.15.0+ features a rebuilt terminal renderer eliminating flicker and prompt jumping, with mouse control support.    \n- GitHub Actions: Beta integration for automated issue triage, PR reviews, and on-demand assistance via `@gemini-cli` mentions.    \n- GEMINI.md: Project-level context files that customize agent behavior per repository, similar to .cursorrules or CLAUDE.md.    \n- Authentication: Supports Google Account (free), Gemini API key, or Google Cloud Vertex AI.    \n- Install: `npm install -g @google/gemini-cli@latest`"}]},{"type":"header","level":2,"content":"Last Update","children":[{"type":"text","content":"2026-01-30"}]},{"type":"header","level":2,"content":"Licensing","children":[]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Fully open-source under Apache 2.0. Community contributions accepted via GitHub.","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Apache-2.0","plainChildren":""}]}]},{"type":"header","level":2,"content":"Free Trial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Free tier with 60 req/min and 1,000 req/day using a personal Google account. No credit card required.","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"text","content":"MCP Support"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No"}]}]},{"type":"header","level":2,"content":"Prompts","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Tools","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Built-in tools: Google Search grounding, file operations, shell commands, web fetching. Additional tools available via MCP servers.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Resources","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"ACP","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Gemini CLI supports the Agent Client Protocol (ACP) by Zed Industries for standardized editor-agent communication via JSON-RPC over stdio.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Deployment","children":[]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Supports Gemini API keys from AI Studio and Google Cloud Vertex AI project credentials. Users can choose their own model endpoint and billing.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Local Offline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Requires network access to reach Gemini API endpoints. No local/offline model execution.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Developer Experience","children":[]},{"type":"header","level":2,"content":"Context Management","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"GEMINI.md context files for per-project instructions. Token caching to optimize repeated context. Conversation checkpointing for saving and resuming sessions.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Direct File References","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"`@{path}` syntax to embed local file or directory content directly into prompts and custom commands.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Conversation checkpointing allows saving and resuming complex development sessions without losing context.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Git Support","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Git-aware workflows including automated commits, rebases, and PR management. GitHub MCP server provides 40+ repository operations.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Extensions framework (v0.8.0+) enables complete customization of the CLI environment. Custom commands, context files, and MCP server integrations.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Lifecycle hooks execute at predefined points: BeforeModel, AfterModel, BeforeTool, BeforeToolSelection, AfterAgent. Used for security enforcement, prompt injection, logging, and continuous iteration loops (Ralph loop pattern).","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Built-in slash commands (`/help`, `/chat`, `/deploy`, `/security:analyze`) plus custom command creation with `@{path}` file embedding.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Skills","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Experimental Agent Skills feature based on Anthropic's open agent skills standard. Skills bundle specialized expertise and workflows, loaded on-demand to save context tokens. Autonomous activation — Gemini decides when to invoke a skill based on its description. Skill porters enable cross-platform reusability.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Custom Modes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Built-in Codebase Investigator sub-agent for deep analysis and reverse engineering. Custom sub-agents configurable in settings.json with independent context windows, specialized tools, and optional model overrides. Experimental remote sub-agent support via Agent-to-Agent (A2A) protocol.","plainChildren":""}]}]}],"sourcePath":"gemini-cli.md"},{"type":"header","level":1,"content":"GitHub Copilot CLI - https://github.com/github/copilot-cli","children":[{"type":"text","content":"GitHub Copilot CLI is a terminal-based AI assistant that provides a chat-like interface in your command line, enabling developers to generate shell commands from natural language, explain terminal operations, and receive AI-driven coding assistance directly in their terminal environment. Integrated with the GitHub CLI via gh copilot, the tool helps write, explain, and automate Git, GitHub, and shell operations using conversational prompts.\n\n**Dataset ID:** terminal"},{"type":"header","level":2,"content":"General Info","children":[]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Terminal","plainChildren":""}]}]},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Repo","children":[{"type":"text","content":"https://github.com/github/copilot-cli"}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Short Description","children":[{"type":"text","content":"Terminal-based AI assistant for generating and explaining shell commands via natural language"}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"GitHub Copilot CLI operates as an interactive terminal assistant that translates natural language requests into executable shell commands and provides explanations for complex terminal operations. The tool supports two primary interaction modes: Interactive Mode (continuous chat-like conversation with follow-up questions) and Programmatic Mode (single-prompt execution via -p/--prompt flag for automation and scripting).\n\nThe CLI includes a flexible approval system for tool usage, allowing developers to control which commands Copilot can execute with options to approve commands one-time only, approve tools for the entire session, or deny specific tools entirely. Commands can be directly executed with ! prefix without AI model calls. The tool supports custom agents that can be invoked via /agent slash command, direct prompt references, or --agent command-line option."}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Any","plainChildren":""},{"type":"item","level":1,"content":"Language-agnostic shell command generation and explanation","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"text","content":"Requires Node.js 22+ and npm 10+. Free plan includes 50 chat requests per month; full access requires GitHub Copilot Individual, Business, or Enterprise subscription. Installation via npm install -g @github/copilot or gh copilot (GitHub CLI integration as of January 2026). Automatically inherits organization's Copilot policies and governance settings. Can create draft PRs and work in background for substantial changes."}]},{"type":"header","level":2,"content":"Last Update","children":[{"type":"text","content":"2026-01-31"}]},{"type":"header","level":2,"content":"Licensing","children":[]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Proprietary","plainChildren":""}]}]},{"type":"header","level":2,"content":"Free Trial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Free plan with 50 chat requests per month","plainChildren":""},{"type":"item","level":1,"content":"Full subscription plans: Individual, Business, Enterprise","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"text","content":"MCP Support"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No"}]}]},{"type":"header","level":2,"content":"Prompts","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Natural language prompts for command generation and code assistance","plainChildren":""}]}]},{"type":"header","level":2,"content":"Tools","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Shell command execution with approval system","plainChildren":""},{"type":"item","level":1,"content":"Git and GitHub operations","plainChildren":""},{"type":"item","level":1,"content":"Web search, fetch, extensions tools","plainChildren":""},{"type":"item","level":1,"content":"Approval options: --allow-all-tools, --deny-tool flags","plainChildren":""}]}]},{"type":"header","level":2,"content":"Resources","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"GitHub repository context","plainChildren":""},{"type":"item","level":1,"content":"Documentation access","plainChildren":""}]}]},{"type":"header","level":2,"content":"ACP","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Deployment","children":[]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Uses GitHub's AI infrastructure","plainChildren":""}]}]},{"type":"header","level":2,"content":"Local Offline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Requires GitHub authentication and internet connectivity","plainChildren":""}]}]},{"type":"header","level":2,"content":"Developer Experience","children":[]},{"type":"header","level":2,"content":"Context Management","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Session-based context in interactive mode","plainChildren":""},{"type":"item","level":1,"content":"Repository-aware when run in code directories","plainChildren":""}]}]},{"type":"header","level":2,"content":"Direct File References","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Can reference files and code in active editor","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Creates new branches and commits unstaged changes as checkpoints for substantial changes","plainChildren":""},{"type":"item","level":1,"content":"Draft PR creation for background work","plainChildren":""}]}]},{"type":"header","level":2,"content":"Git Support","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Native Git command generation and execution","plainChildren":""},{"type":"item","level":1,"content":"GitHub CLI integration via gh copilot","plainChildren":""},{"type":"item","level":1,"content":"Can create branches, commits, and draft pull requests","plainChildren":""},{"type":"item","level":1,"content":"Granular control over git subcommands (e.g., deny git push)","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"/explain for understanding code and commands","plainChildren":""},{"type":"item","level":1,"content":"/agent for selecting custom agents","plainChildren":""},{"type":"item","level":1,"content":"/login for authentication","plainChildren":""}]}]},{"type":"header","level":2,"content":"Skills","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Custom Modes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Interactive mode for continuous chat","plainChildren":""},{"type":"item","level":1,"content":"Programmatic mode for single-prompt automation (-p/--prompt flag)","plainChildren":""},{"type":"item","level":1,"content":"Custom agent invocation via --agent flag","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Custom agents can be created and invoked","plainChildren":""},{"type":"item","level":1,"content":"Example: refactoring agent, testing agent","plainChildren":""},{"type":"item","level":1,"content":"Invoked via /agent command, direct prompts, or --agent CLI option","plainChildren":""}]}]}],"sourcePath":"github-copilot-cli.md"},{"type":"header","level":1,"content":"Grok CLI - https://github.com/superagent-ai/grok-cli","children":[{"type":"text","content":"An open-source AI agent that brings the power of Grok directly into your terminal with conversational AI, smart file operations, bash integration, and MCP tools support."},{"type":"header","level":2,"content":"General Info","children":[]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Terminal","plainChildren":""}]}]},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"- Latest (2026-02)    \n- Created: 2025-07-14    \n- Last updated: 2026-02-08    \n- 2,322+ GitHub stars"}]},{"type":"header","level":2,"content":"Repo","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"https://github.com/superagent-ai/grok-cli","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"text","content":"- [4] Strong conversational AI with intelligent tool selection and automated file operations    \n- [4] Excellent extensibility via MCP (Model Context Protocol) servers    \n- [4] High-speed code editing with Morph Fast Apply at 4,500+ tokens/sec with 98% accuracy    \n- [3] Requires X.AI API key (BYOK); not fully self-contained"}]},{"type":"header","level":2,"content":"Short Description","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Open-source terminal AI assistant powered by Grok models that provides conversational AI, smart file operations, bash integration, and Model Context Protocol (MCP) tools for extending capabilities directly in your shell environment","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"Grok CLI is an MIT-licensed, open-source terminal application developed by the team at Vibe that integrates X.AI's Grok models directly into command-line workflows. Built over a single weekend, the tool has gained significant traction with over 2,300 GitHub stars and recognition from notable figures including Boris Cherny (Creator of Claude Code, MTS at Anthropic).\n\nThe tool provides a conversational natural language interface powered by Grok models (primarily Grok-3) with automatic tool selection for viewing, creating, and editing files, executing shell commands, and performing complex multi-step tasks. Grok CLI can handle up to 400 tool execution rounds by default to manage sophisticated workflows, and it supports OpenAI-compatible APIs allowing integration with multiple model providers (X.AI, OpenAI, OpenRouter, Groq).\n\nBuilt with TypeScript and the Ink framework (React-based terminal UI), Grok CLI runs on Bun 1.0+ (with Node.js 18+ fallback) and offers both interactive and headless modes. The interactive mode provides a real-time conversational interface, while headless mode enables single-prompt execution suitable for scripting and CI/CD pipelines. The tool integrates Morph's Fast Apply model for high-speed code editing at 4,500+ tokens/sec with 98% accuracy, providing rapid code transformations."}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Any","plainChildren":""},{"type":"item","level":1,"content":"Language-agnostic; supports any programming language through file operations and bash commands","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"text","content":"- Models: Supports grok-code-fast-1 (default), grok-4-latest, grok-3-latest, grok-3-fast, grok-3-mini-fast, and any OpenAI-compatible models via custom endpoints    \n- Installation: Available via Bun (`bun add -g @vibe-kit/grok-cli`) or npm (`npm install -g @vibe-kit/grok-cli`)    \n- Tech stack: TypeScript, Bun runtime, Ink UI framework (React-based terminal UI), OpenAI-compatible REST API    \n- Context window: Supports large context with Grok's 1M+ token context window for project-wide analysis and modifications    \n- Platform support: Cross-platform (macOS, Linux, Windows) via Bun/Node.js runtime    \n- Use cases: Interactive terminal AI assistance, automated file operations, git workflow automation (commit/push), code editing and refactoring, CI/CD integration, custom tool workflows via MCP    \n- MCP integration: Supports Model Context Protocol servers including Linear integration, GitHub integration, custom stdio and HTTP-based servers, environment variable support for authentication    \n- Custom instructions: Project-level (`.grok/GROK.md`) and global (`~/.grok/GROK.md`) instruction files with priority-based loading system    \n- Configuration: Two-tier system with user-level (`~/.grok/user-settings.json`) for global settings and project-level (`.grok/settings.json`) for project-specific config    \n- Morph Fast Apply: Optional high-speed code editing at 4,500+ tokens/sec with 98% accuracy using abbreviated edit format    \n- Tool rounds: Configurable `--max-tool-rounds` parameter (default 400) controls execution complexity and prevents infinite loops    \n- API key management: Supports environment variables, `.env` files, command flags, and user settings JSON for flexible credential management    \n- Community: Active Discord server for user support and collaboration    \n- Further reading: GitHub repository at https://github.com/superagent-ai/grok-cli and official site at https://www.superagent.sh/open-source/grok-cli"}]},{"type":"header","level":2,"content":"Last Update","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"2026-02-09","plainChildren":""}]}]},{"type":"header","level":2,"content":"Licensing","children":[]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"MIT-licensed open-source project available on GitHub","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"MIT","plainChildren":""}]}]},{"type":"header","level":2,"content":"Free Trial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Fully open-source and free to use; requires X.AI API key (bring your own key)","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"text","content":"MCP Support"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No"}]}]},{"type":"header","level":2,"content":"Prompts","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Natural language conversational interface with support for custom instructions via `.grok/GROK.md` files at project and global levels","plainChildren":""}]}]},{"type":"header","level":2,"content":"Tools","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Intelligent automatic tool selection for file operations (view, create, edit), bash command execution, git operations, and extensible MCP-based tools","plainChildren":""}]}]},{"type":"header","level":2,"content":"Resources","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"GitHub repository: https://github.com/superagent-ai/grok-cli","plainChildren":""},{"type":"item","level":1,"content":"Official site: https://www.superagent.sh/open-source/grok-cli","plainChildren":""},{"type":"item","level":1,"content":"Discord community for support","plainChildren":""},{"type":"item","level":1,"content":"Command reference and documentation via DeepWiki","plainChildren":""}]}]},{"type":"header","level":2,"content":"ACP","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"No documented Agent Client Protocol (ACP) support; uses MCP (Model Context Protocol) instead for extensibility","plainChildren":""}]}]},{"type":"header","level":2,"content":"Deployment","children":[]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Requires user-provided API keys from X.AI (Grok), OpenAI, OpenRouter, Groq, or other OpenAI-compatible providers","plainChildren":""},{"type":"item","level":1,"content":"Multiple configuration methods: environment variables, `.env` files, command-line flags, user settings JSON","plainChildren":""}]}]},{"type":"header","level":2,"content":"Local Offline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Requires internet connection and remote API endpoints for Grok or other LLM models","plainChildren":""},{"type":"item","level":1,"content":"Code is open-source and can be self-hosted, but model inference requires cloud-based API access","plainChildren":""}]}]},{"type":"header","level":2,"content":"Developer Experience","children":[]},{"type":"header","level":2,"content":"Context Management","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Large context support with Grok's 1M+ token context window","plainChildren":""},{"type":"item","level":1,"content":"Custom instruction files: project-level (`.grok/GROK.md`) and global (`~/.grok/GROK.md`) with priority-based loading","plainChildren":""},{"type":"item","level":1,"content":"Conversational context preserved throughout interactive sessions","plainChildren":""}]}]},{"type":"header","level":2,"content":"Direct File References","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Smart file operations with AI automatically viewing, creating, and editing files","plainChildren":""},{"type":"item","level":1,"content":"Abbreviated edit format support with Morph Fast Apply for rapid code changes","plainChildren":""},{"type":"item","level":1,"content":"Direct file access within working directory and project context","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"No built-in checkpoint or undo system documented","plainChildren":""},{"type":"item","level":1,"content":"Users can leverage git for version control and manual checkpoints","plainChildren":""}]}]},{"type":"header","level":2,"content":"Git Support","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Git-aware: recognizes git repositories and can check git status","plainChildren":""},{"type":"item","level":1,"content":"Automated git workflows: commit-and-push command with AI-generated commit messages","plainChildren":""},{"type":"item","level":1,"content":"Branch management and common git operations through bash integration","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"No plugin bundling system; extensibility provided through MCP servers rather than traditional plugins","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"No documented lifecycle hook system for agent customization","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Command-line interface uses flags and options rather than slash commands","plainChildren":""},{"type":"item","level":1,"content":"CLI options: `-V` (version), `-d` (directory), `-k` (API key), `-m` (model), `-p` (headless prompt), `--max-tool-rounds`, `-h` (help)","plainChildren":""}]}]},{"type":"header","level":2,"content":"Skills","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"No reusable skill definition system; functionality extended via MCP tools instead","plainChildren":""}]}]},{"type":"header","level":2,"content":"Custom Modes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Interactive mode: Real-time conversational interface (`grok` or `grok -d /path/to/project`)","plainChildren":""},{"type":"item","level":1,"content":"Headless mode: Single-prompt execution for scripting and CI/CD (`grok --prompt \"task\"` or `grok -p \"task\"`)","plainChildren":""},{"type":"item","level":1,"content":"Morph Fast Apply mode: High-speed code editing at 4,500+ tokens/sec when available","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Single-agent architecture with intelligent tool selection; no documented multi-agent or subagent system","plainChildren":""}]}]}],"sourcePath":"grok-cli.md"},{"type":"header","level":1,"content":"Jules Tools CLI - https://jules.google/","children":[{"type":"text","content":"Jules Tools is Google's command-line interface for Jules, their asynchronous AI coding agent powered by Gemini 2.5 Pro. Launched in October 2025, it brings Jules directly into the developer's terminal for streamlined coding workflows.\n\n**Dataset ID:** terminal"},{"type":"header","level":2,"content":"General Info","children":[]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Terminal","plainChildren":""},{"type":"item","level":1,"content":"Code/Autonomous agent","plainChildren":""}]}]},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"- Public Beta (October 2025)"}]},{"type":"header","level":2,"content":"Repo","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"-","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"text","content":"- [3] Async cloud-based agent with strong GitHub integration and Gemini 3 Pro backing    \n- [2] No extensibility (no MCP, hooks, plugins, or skills); cloud-only execution model"}]},{"type":"header","level":2,"content":"Short Description","children":[{"type":"text","content":"Command-line interface for Google's Jules AI coding agent, enabling terminal-based interaction with Gemini 2.5 Pro-powered asynchronous coding assistance."}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"Jules Tools is the command-line interface for Jules, Google's asynchronous coding agent launched in October 2025. The CLI lets developers interact with Jules directly from the terminal using commands, streamlining workflows by eliminating the need to switch between the web interface and GitHub.\n\nJules fetches repositories, clones them to a Cloud VM, and develops a plan utilizing the latest Gemini 2.5 Pro model. It operates asynchronously, allowing developers to focus on other tasks while it works in the background on coding tasks such as writing tests, building features, fixing bugs, and bumping dependency versions.\n\nThe tool integrates with existing repositories, understands full project context, and creates pull requests with the changes. Google has also made Jules' API public, allowing developers to integrate Jules into their existing workflows and development environments beyond the CLI."}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Any","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"text","content":"- Model: Powered by Gemini 2.5 Pro    \n- Async Operation: Works in background while developers focus on other tasks    \n- Launch: Public beta began August 2025, CLI launched October 2025    \n- Free Tier: Up to 15 individual daily tasks and 3 concurrent tasks    \n- Paid Plans: Google AI Pro ($19.99/month - 5x limits), Ultra ($124.99/month - 20x limits)    \n- Features: Test writing, feature building, bug fixing, dependency updates, audio changelogs    \n- Integration: Public API available for custom workflow integration    \n- Cloud Execution: Clones repositories to Cloud VM for development"}]},{"type":"header","level":2,"content":"Last Update","children":[{"type":"text","content":"2026-01-30"}]},{"type":"header","level":2,"content":"Licensing","children":[]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Proprietary","plainChildren":""}]}]},{"type":"header","level":2,"content":"Free Trial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Free tier: 15 daily tasks, 3 concurrent tasks","plainChildren":""},{"type":"item","level":1,"content":"Available worldwide where Gemini models are accessible","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"text","content":"MCP Support"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No"}]}]},{"type":"header","level":2,"content":"Prompts","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Command-line prompts for task assignment","plainChildren":""},{"type":"item","level":1,"content":"Natural language task descriptions","plainChildren":""}]}]},{"type":"header","level":2,"content":"Tools","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"CLI commands for interacting with Jules","plainChildren":""},{"type":"item","level":1,"content":"Public API for custom integrations","plainChildren":""}]}]},{"type":"header","level":2,"content":"Resources","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Official website: https://jules.google/","plainChildren":""},{"type":"item","level":1,"content":"Documentation: https://jules.google/docs/","plainChildren":""},{"type":"item","level":1,"content":"Google Developer Blog: https://developers.googleblog.com/","plainChildren":""}]}]},{"type":"header","level":2,"content":"ACP","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Deployment","children":[]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Local Offline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Requires Cloud VM for repository cloning and execution","plainChildren":""}]}]},{"type":"header","level":2,"content":"Developer Experience","children":[]},{"type":"header","level":2,"content":"Context Management","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Understands full repository context","plainChildren":""},{"type":"item","level":1,"content":"Powered by Gemini 2.5 Pro's large context window","plainChildren":""}]}]},{"type":"header","level":2,"content":"Direct File References","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Creates pull requests for review before merging","plainChildren":""}]}]},{"type":"header","level":2,"content":"Git Support","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Direct GitHub integration","plainChildren":""},{"type":"item","level":1,"content":"Automatic PR creation","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Skills","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Custom Modes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Asynchronous background operation mode. Recurring scheduled tasks (e.g. weekly dependency checks, nightly lint fixes).","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Ungrouped Criteria","children":[]},{"type":"header","level":2,"content":"Terminal","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]}],"sourcePath":"jules-tools.md"},{"type":"header","level":1,"content":"Kimi CLI - https://github.com/MoonshotAI/kimi-cli","children":[{"type":"text","content":"Kimi CLI is a command-line coding tool from Moonshot AI that integrates intelligent agents with traditional Shell operations, featuring dual-mode interaction design for seamless switching between Shell and AI agent modes.\n\n**Dataset ID:** terminal"},{"type":"header","level":2,"content":"General Info","children":[]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Terminal","plainChildren":""}]}]},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"- Technical Preview (2025)"}]},{"type":"header","level":2,"content":"Repo","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"https://github.com/MoonshotAI/kimi-cli","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"text","content":"- [3] Innovative dual-mode design with 128K context and native ACP/MCP support    \n- [2] Technical preview; limited extensibility ecosystem"}]},{"type":"header","level":2,"content":"Short Description","children":[{"type":"text","content":"Dual-mode CLI coding assistant from Moonshot AI with 128K context window, supporting both traditional Shell operations and AI agent mode with ACP and MCP protocols."}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"Kimi CLI is a command-line coding tool from Moonshot AI that combines traditional Shell operations with intelligent AI agents. The core innovation is its \"dual-mode interaction\" design, allowing users to work in familiar Shell style while being able to switch to \"intelligent agent mode\" with one click using the Ctrl-K shortcut.\n\nThe tool features a large 128K token context window, making it suitable for working with extensive codebases. Kimi CLI supports Agent Client Protocol (ACP) out of the box and can be used with any ACP-compatible editor or IDE. It also supports the well-established MCP (Model Context Protocol) config convention. The tool is positioned as a competitor to Claude Code and other terminal-based AI coding assistants, with coding performance comparable to Claude 4.5 and GLM 4.6."}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Any","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"text","content":"- Dual-Mode Operation: Seamless switching between Shell and AI agent mode using Ctrl-K    \n- Context Window: 128K tokens for large codebase support    \n- Protocol Support: Native ACP (Agent Client Protocol) support, MCP config convention    \n- Performance: Comparable to Claude 4.5 and GLM 4.6 in coding tasks    \n- Installation: Available via Python/PyPI    \n- Open Source: Code available on GitHub    \n- Release Status: Currently in technical preview    \n- IDE Integration: Compatible with any ACP-compatible editor or IDE"}]},{"type":"header","level":2,"content":"Last Update","children":[{"type":"text","content":"2026-01-30"}]},{"type":"header","level":2,"content":"Licensing","children":[]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Apache-2.0","plainChildren":""}]}]},{"type":"header","level":2,"content":"Free Trial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Open source and freely available","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"text","content":"MCP Support"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No"}]}]},{"type":"header","level":2,"content":"Prompts","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Tools","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Supports Agent Client Protocol (ACP)","plainChildren":""},{"type":"item","level":1,"content":"Compatible with ACP-compatible tools and IDEs","plainChildren":""}]}]},{"type":"header","level":2,"content":"Resources","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"GitHub repository: https://github.com/MoonshotAI/kimi-cli","plainChildren":""},{"type":"item","level":1,"content":"Installation via Python/PyPI","plainChildren":""},{"type":"item","level":1,"content":"Documentation in repository","plainChildren":""}]}]},{"type":"header","level":2,"content":"ACP","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Kimi CLI supports the Agent Client Protocol (ACP) by Zed Industries natively, enabling use with any ACP-compatible editor or IDE for standardized editor-agent communication via JSON-RPC over stdio.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Deployment","children":[]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Supports API key configuration via Moonshot AI Open Platform.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Local Offline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Developer Experience","children":[]},{"type":"header","level":2,"content":"Context Management","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"128K token context window","plainChildren":""},{"type":"item","level":1,"content":"Maintains context across Shell and agent modes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Direct File References","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Git Support","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Skills","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Custom Modes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Dual-mode design: Shell mode and AI agent mode. Toggle with Ctrl-K.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Ungrouped Criteria","children":[]},{"type":"header","level":2,"content":"Terminal","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]}],"sourcePath":"kimi-cli.md"},{"type":"header","level":1,"content":"Kiro CLI - https://www.example.com","children":[{"type":"text","content":"<!-- Add the comparison entry name plus canonical URL on first line. -->\n\n<!-- Describe this comparison entry using one or two paragraphs. -->"},{"type":"header","level":2,"content":"General Info","children":[{"type":"text","content":"<!-- General Info -->"}]},{"type":"header","level":2,"content":"Classification","children":[{"type":"text","content":"<!-- AI Native Dev ainativedev.io Classification -->\n<!-- Keep only the label values that apply to this comparison. Add any supporting notes using indented \"- \" entries beneath the kept values. -->"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Terminal","plainChildren":""},{"type":"item","level":1,"content":"Code/Autonomous agent","plainChildren":""},{"type":"item","level":1,"content":"Product/Prototyping","plainChildren":""},{"type":"item","level":1,"content":"AIE/Model","plainChildren":""},{"type":"item","level":1,"content":"Kiro CLI is the terminal client for AWS's Kiro agentic development platform; it brings agent-driven, spec-driven development flows to the shell and can act autonomously to modify multiple files, run tools, and follow project \"steering\" files.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"- GA (General Availability)    \n- Kiro CLI is the production/GA release of AWS's Kiro platform (the successor to Amazon Q Developer CLI). No single semantic version number is published like an open-source repo; updates are rolled out by AWS.    \n\n<!-- Latest version used for update -->"}]},{"type":"header","level":2,"content":"Repo","children":[{"type":"text","content":"<!-- Associated Github repository -->"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"-","plainChildren":""},{"type":"item","level":1,"content":"Kiro CLI is an AWS-managed product (no public GitHub repo for the core product). Documentation and download links are published by AWS.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"text","content":"- [4] Full-featured agentic CLI with MCP, steering files, custom agents, checkpoints, and spec-driven workflows    \n- [3] Proprietary AWS-managed product; no BYOK or offline support"}]},{"type":"header","level":2,"content":"Short Description","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Terminal client for AWS Kiro — an agentic, spec-driven development assistant that uses steering files, MCP integration, and custom agents to scaffold, modify and debug code from the command line.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"- Kiro CLI is the command-line interface for AWS's Kiro platform. It exposes the same agentic development capabilities available in the Kiro IDE to developers who prefer working in a terminal. Key capabilities include spec-driven workflows (spec generation and implementation), project \"steering\" via markdown files in a .kiro/steering/ directory, Model Context Protocol (MCP) integrations to surface external data sources, custom agents tailored to team workflows, and an Auto agent that selects optimal models for tasks.    \n- The CLI can open editors for long prompts, accept multimodal inputs (including screenshots in supported workflows), manage MCP servers, create and run agents, and checkpoint/rollback agent actions. It is intended for interactive development tasks (scaffolding, debugging, infra-as-code) and for automations where an agent can operate across multiple files and tools within a repository.    \n\n<!-- Few paragraphs about the product -->"}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"text","content":"<!-- Any or limited list of supported programming Languages -->\n<!-- Keep only the label values that apply to this comparison. Add any supporting notes as indented \"- \" entries beneath the kept values. -->"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Any","plainChildren":""},{"type":"item","level":1,"content":"Kiro is language-agnostic and can operate on repositories in virtually any language. Commonly used languages include JavaScript/TypeScript, Python, Java, Go, Rust, C#, C/C++, Ruby and others — the agent uses repository context and steering files to follow project conventions rather than being limited to a specific language.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"text","content":"- Kiro CLI shares steering files and configuration with the Kiro IDE, enabling consistent behavior across IDE and terminal workflows.    \n- The product is a managed AWS offering that uses subscriptions/credits for model usage; teams manage access via AWS Identity Center and related AWS account controls."}]},{"type":"header","level":2,"content":"Last Update","children":[{"type":"text","content":"2026-01-30"}]},{"type":"header","level":2,"content":"Licensing","children":[{"type":"text","content":"<!-- Licensing -->"}]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"text","content":"<!-- Coding tool is released under opensource license -->\n<!-- Keep only the label values that apply to this comparison. Choose either Yes or No and remove the other, or delete both if unknown. Add any supporting notes using indented \"- \" entries beneath the kept values. -->"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Kiro CLI is an AWS-managed commercial product; the core product is not published as open source.","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"text","content":"<!-- Opensource specific license or Proprietary for other commercial licenses -->\n<!-- Keep only the label values that apply to this comparison. Add any supporting notes using indented \"- \" entries beneath the kept values. -->"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Proprietary","plainChildren":""},{"type":"item","level":1,"content":"Distributed and operated by AWS under their commercial terms; third-party models accessible via the service are subject to their respective licenses.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Free Trial","children":[{"type":"text","content":"<!-- Free access (like opensource), or free (potentially limited) trial available -->\n<!-- Keep only the label values that apply to this comparison. Choose either Yes or No and remove the other, or delete both if unknown. Add any supporting notes using indented \"- \" entries beneath the kept values. -->"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"-","plainChildren":""},{"type":"item","level":1,"content":"Pricing and trial/credit offers are managed by AWS; availability of trial credits can vary by account and promotion — refer to AWS Kiro documentation or the Kiro subscription portal for current offers.","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"text","content":"MCP Support"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No"}]}]},{"type":"header","level":2,"content":"Prompts","children":[{"type":"text","content":"<!-- Default description for Prompts -->\n<!-- Keep only the label values that apply. Choose either Yes or No and remove the other, or delete both if unknown. Add any supporting notes as indented \"- \" entries beneath the kept values. -->"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"The CLI supports both short interactive prompts and longer multi-line prompts (which open the user's configured editor). Prompts may include steering file context and repository files automatically.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Tools","children":[{"type":"text","content":"<!-- Default description for Tools -->\n<!-- Keep only the label values that apply. Choose either Yes or No and remove the other, or delete both if unknown. Add any supporting notes as indented \"- \" entries beneath the kept values. -->"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Kiro agents can run pre-approved tools (linters, formatters, test runners, shell commands) and teams can control which tools an agent is permitted to execute.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Resources","children":[{"type":"text","content":"<!-- Default description for Resources -->\n<!-- Keep only the label values that apply. Choose either Yes or No and remove the other, or delete both if unknown. Add any supporting notes as indented \"- \" entries beneath the kept values. -->"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"The CLI consumes steering files, repository files, MCP server data, and system/workspace metadata as resources to ground agent actions.","plainChildren":""}]}]},{"type":"header","level":2,"content":"ACP","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Deployment","children":[{"type":"text","content":"<!-- Deployment -->"}]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"text","content":"<!-- Bring Your Own LLM API Key supported -->\n<!-- Keep only the label values that apply. Choose either Yes or No and remove the other, or delete both if unknown. Add any supporting notes as indented \"- \" entries beneath the kept values. -->"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Kiro is a managed AWS product with models and routing controlled by the service; it does not generally function as a BYOK wrapper for arbitrary external LLM API keys.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Local Offline","children":[{"type":"text","content":"<!-- Support for local on-site deployment or local offline use -->\n<!-- Keep only the label values that apply. Choose either Yes or No and remove the other, or delete both if unknown. Add any supporting notes as indented \"- \" entries beneath the kept values. -->"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Kiro CLI is designed to integrate with AWS-managed services and models; it is not designed as an offline, self-hosted LLM stack.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Developer Experience","children":[{"type":"text","content":"<!-- Developer Experience -->"}]},{"type":"header","level":2,"content":"Context Management","children":[{"type":"text","content":"<!-- Methods for managing and updating the context. -->\n<!-- Keep only the label values that apply. Choose either Yes or No and remove the other, or delete both if unknown. Add any supporting notes as indented \"- \" entries beneath the kept values. -->"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Context is managed via steering files in .kiro/steering/ (workspace and global scopes), AGENTS.md, MCP servers, and automatic workspace/system context injection.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Direct File References","children":[{"type":"text","content":"<!-- Can with @file or similar provide context. -->\n<!-- Keep only the label values that apply. Choose either Yes or No and remove the other, or delete both if unknown. Add any supporting notes as indented \"- \" entries beneath the kept values. -->"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Agents can read repository files and steering files; prompts and agent actions can reference files directly so the agent sees the actual source it will modify.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"text","content":"<!-- A way to undo using checkpoints or if autocommitted git history -->\n<!-- Keep only the label values that apply. Choose either Yes or No and remove the other, or delete both if unknown. Add any supporting notes as indented \"- \" entries beneath the kept values. -->"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"The CLI offers checkpointing/rollback semantics for agent actions so users can revert agent changes or step back through execution stages.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Git Support","children":[{"type":"text","content":"<!-- Coding tool is aware of GIT and can work/integrate with GIT repos -->\n<!-- Keep only the label values that apply. Choose either Yes or No and remove the other, or delete both if unknown. Add any supporting notes as indented \"- \" entries beneath the kept values. -->"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Kiro integrates with Git-based workflows (reads repository state, can create commits/branches as part of agent operations) and is designed to operate inside standard Git repos.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"text","content":"<!-- Is it possible to extend or customize the system in any way -->"}]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"text","content":"<!-- A method of bundling together commands, agents and hooks (claude). -->\n<!-- Keep only the label values that apply. Choose either Yes or No and remove the other, or delete both if unknown. Add any supporting notes as indented \"- \" entries beneath the kept values. -->"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Kiro supports custom agents, hooks and project-specific steering which together provide extensibility similar to plugins. Teams can define agents optimized for particular workflows.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"text","content":"<!-- Lifecycle events for the agent. -->\n<!-- Keep only the label values that apply. Choose either Yes or No and remove the other, or delete both if unknown. Add any supporting notes as indented \"- \" entries beneath the kept values. -->"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Lifecycle hooks can be configured to run tests, linters, or other automation at defined points in agent workflows.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"text","content":"<!-- Re-usable commands that can be manually triggered by the user. -->\n<!-- Keep only the label values that apply. Choose either Yes or No and remove the other, or delete both if unknown. Add any supporting notes as indented \"- \" entries beneath the kept values. -->"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"The CLI exposes subcommands rather than chat-style slash commands.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Skills","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Progressive context loading: skills load only metadata (name/description) at startup, with full documentation loading on-demand when needed. Supports 18 built-in language skills.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Custom Modes","children":[{"type":"text","content":"<!-- Keep only the label values that apply. Choose either Yes or No and remove the other, or delete both if unknown. Add any supporting notes as indented \"- \" entries beneath the kept values. -->"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Custom agents and steering files create specialist modes for different tasks (e.g., backend agent, frontend agent, devops agent).","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"text","content":"<!-- Define specialized AI subagents for task-specific workflows. -->\n<!-- Keep only the label values that apply. Choose either Yes or No and remove the other, or delete both if unknown. Add any supporting notes as indented \"- \" entries beneath the kept values. -->"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Users can create focused agents for specific responsibilities; these agents have pre-approved tools, dedicated steering/context, and can persist configuration across sessions.","plainChildren":""}]}]}],"sourcePath":"kiro-cli.md"},{"type":"header","level":1,"content":"Kiro - https://kiro.run/","children":[{"type":"text","content":"Fast, lightweight CLI coding utility that brings AI-powered development assistance to the terminal. A new terminal-focused coding tool emphasizing speed and developer productivity."},{"type":"header","level":2,"content":"General Info","children":[]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Terminal","plainChildren":""}]}]},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"- 2025"}]},{"type":"header","level":2,"content":"Repo","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"-","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"text","content":"- [3] Lightweight CLI with spec-driven development and custom agent support    \n- [2] Limited public documentation on extensibility details"}]},{"type":"header","level":2,"content":"Short Description","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Fast, lightweight CLI coding utility designed for terminal-based AI-assisted development workflows.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"Kiro is a new command-line coding utility that focuses on speed and simplicity for terminal-based developers. It provides AI-powered coding assistance directly in the terminal environment, making it easy to generate code, debug issues, and perform development tasks without leaving the command line. Kiro emphasizes a minimal footprint and fast response times, making it ideal for developers who prefer terminal-based workflows."}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Any","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"text","content":"- Speed-focused: Designed for fast response times and minimal latency.    \n- Lightweight: Minimal resource footprint for quick startup and operation.    \n- Terminal-native: Built specifically for command-line development workflows.    \n- New tool released in 2025 targeting CLI-focused developers.    \n- Emphasizes developer productivity through simplicity and speed."}]},{"type":"header","level":2,"content":"Last Update","children":[{"type":"text","content":"2026-01-30"}]},{"type":"header","level":2,"content":"Licensing","children":[]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Proprietary","plainChildren":""}]}]},{"type":"header","level":2,"content":"Free Trial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"text","content":"MCP Support"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No"}]}]},{"type":"header","level":2,"content":"Prompts","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Tools","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Resources","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"ACP","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Deployment","children":[]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Local Offline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Developer Experience","children":[]},{"type":"header","level":2,"content":"Context Management","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Direct File References","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Git Support","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Skills","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Progressive context loading: skills load only metadata at startup, full content on demand.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Custom Modes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]}],"sourcePath":"kiro.md"},{"type":"header","level":1,"content":"Letta - https://github.com/cpacker/MemGPT","children":[{"type":"text","content":"Letta (formerly MemGPT) is an open-source, model-agnostic platform for building stateful AI agents with persistent memory capabilities. As a memory-first coding agent designed for terminal environments, Letta enables developers to work with agents that learn and improve across sessions rather than in isolated interactions, using a MemGPT-based architecture with self-editing memory split between in-context and out-of-context storage organized into editable memory blocks.\n\n**Dataset ID:** terminal"},{"type":"header","level":2,"content":"General Info","children":[]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Terminal","plainChildren":""}]}]},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Repo","children":[{"type":"text","content":"https://github.com/cpacker/MemGPT"}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Short Description","children":[{"type":"text","content":"Memory-first terminal coding agent with persistent learning and multi-agent systems"}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"Letta Code functions as a terminal-based IDE agent that ranks as the #1 model-agnostic open-source coding harness on TerminalBench, achieving 42.5% overall score and ranking #4 overall and #2 among agents using Claude 4 Sonnet. The platform prioritizes long-lived agents that persist across sessions and improve with use, carrying memories across interactions.\n\nThe system implements a memory hierarchy distinguishing between in-context and out-of-context memory using memory blocks—persistent, editable components that agents can modify using tools. When context exceeds approximately 40,000 tokens, Letta performs recursive summarization of previous messages. The platform supports dynamic skill learning (36.8% relative improvement on Terminal-Bench 2.0), long-running agents for complex operations, multi-agent systems with shared memory, and tool integration for web search and code execution."}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Python","plainChildren":""},{"type":"item","level":1,"content":"JavaScript","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"text","content":"Terminal-use agent implemented in under 200 lines of code using Letta's stateful agents SDK. Supports background mode streaming with resumable streams and crash recovery for long-running tasks (10+ minutes). Installed via pip (pymemgpt). Can be deployed as Letta Cloud (managed service) or self-hosted servers. Performance using Claude 4 Sonnet matches Claude Code using Claude Opus."}]},{"type":"header","level":2,"content":"Last Update","children":[{"type":"text","content":"2026-01-31"}]},{"type":"header","level":2,"content":"Licensing","children":[]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Apache-2.0","plainChildren":""}]}]},{"type":"header","level":2,"content":"Free Trial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Fully open source with free hosted endpoint via memgpt quickstart --backend memgpt","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"text","content":"MCP Support"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No"}]}]},{"type":"header","level":2,"content":"Prompts","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Tools","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Custom tool definitions and execution (e.g., Google Search, web_search, run_code)","plainChildren":""}]}]},{"type":"header","level":2,"content":"Resources","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Connections to external data sources (e.g., PDF files) for RAG","plainChildren":""}]}]},{"type":"header","level":2,"content":"ACP","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Deployment","children":[]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Supports OpenAI, free hosted endpoint, and local LLMs configurable through memgpt configure","plainChildren":""}]}]},{"type":"header","level":2,"content":"Local Offline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Local LLM support for self-hosted models","plainChildren":""}]}]},{"type":"header","level":2,"content":"Developer Experience","children":[]},{"type":"header","level":2,"content":"Context Management","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Memory blocks with read-only and read-write sections for planning","plainChildren":""},{"type":"item","level":1,"content":"Recursive summarization (compaction) when context exceeds ~40,000 tokens","plainChildren":""},{"type":"item","level":1,"content":"Infinite message history with searchable past conversations","plainChildren":""},{"type":"item","level":1,"content":"/attach command to attach data sources to agent","plainChildren":""}]}]},{"type":"header","level":2,"content":"Direct File References","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Can load data from directories and databases","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"/save command to save checkpoint of current agent/conversation state","plainChildren":""},{"type":"item","level":1,"content":"Recovery-Bench functionality for error recovery from corrupted states","plainChildren":""}]}]},{"type":"header","level":2,"content":"Git Support","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Extensible","children":[]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"/exit to exit CLI","plainChildren":""},{"type":"item","level":1,"content":"/attach to attach loaded data sources","plainChildren":""},{"type":"item","level":1,"content":"/save to save checkpoints","plainChildren":""},{"type":"item","level":1,"content":"/dump to view message log and context","plainChildren":""}]}]},{"type":"header","level":2,"content":"Skills","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Dynamic skill learning from library","plainChildren":""},{"type":"item","level":1,"content":"Agents can discover, load, and utilize relevant skills to complete tasks","plainChildren":""},{"type":"item","level":1,"content":"Pre-built skills for advanced memory and continual learning","plainChildren":""}]}]},{"type":"header","level":2,"content":"Custom Modes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Multi-agent systems with shared memory","plainChildren":""},{"type":"item","level":1,"content":"Multiple conversations running in parallel within a single agent","plainChildren":""},{"type":"item","level":1,"content":"All conversations share same memory blocks and searchable message history","plainChildren":""}]}]}],"sourcePath":"letta.md"},{"type":"header","level":1,"content":"Neovate Code - https://github.com/NeovateAI","children":[{"type":"text","content":"Neovate Code is an open-source AI-powered coding agent developed by Ant Group that provides a terminal CLI interface for code generation, debugging, testing, and refactoring tasks. As a model-agnostic platform supporting multiple AI providers, Neovate Code follows the latest AI coding best practices including Spec Driven Development and Parallel Agent approaches, offering both interactive and headless modes with robust session management and an extensible plugin system.\n\n**Dataset ID:** terminal"},{"type":"header","level":2,"content":"General Info","children":[]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Terminal","plainChildren":""}]}]},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Repo","children":[{"type":"text","content":"https://github.com/NeovateAI"}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Short Description","children":[{"type":"text","content":"Open-source terminal coding agent with multi-model support and extensible plugin architecture"}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"Neovate Code operates as an intelligent coding assistant designed to understand codebases, follow coding patterns, and help developers implement features, fix bugs, and refactor code with context awareness. The platform provides a chat-driven development interface through natural conversation for coding tasks, with AGENTS.md rule files to define custom rules and project-specific behaviors.\n\nSession persistence allows developers to continue work across sessions with history stored per working directory. The tool supports interactive mode (default conversational interface), headless mode for CI/CD integration and automation, and plan mode to review implementation plans before execution. Built-in plugin system enables substantial customization with companies like Ant Group and Kuaishou using it to build proprietary code agents."}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Python","plainChildren":""},{"type":"item","level":1,"content":"JavaScript","plainChildren":""},{"type":"item","level":1,"content":"TypeScript","plainChildren":""},{"type":"item","level":1,"content":"Supports additional languages through model capabilities","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"text","content":"Installed via npm (npm install -g @neovate/code). Supports multimodal input with drag-and-drop for images, screenshots, and diagrams. File references via @ symbol with fuzzy search. Session forking with esc-esc for branching workflows. Desktop client variant in development. Roadmap includes Smart Debug, Smart Review, and Smart Inspection tools."}]},{"type":"header","level":2,"content":"Last Update","children":[{"type":"text","content":"2026-01-31"}]},{"type":"header","level":2,"content":"Licensing","children":[]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"MIT","plainChildren":""}]}]},{"type":"header","level":2,"content":"Free Trial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Fully open source","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"text","content":"MCP Support"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No"}]}]},{"type":"header","level":2,"content":"Prompts","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Tools","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Custom tool integrations via plugin system","plainChildren":""}]}]},{"type":"header","level":2,"content":"Resources","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"@ symbol for file and directory references with fuzzy search","plainChildren":""}]}]},{"type":"header","level":2,"content":"ACP","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Deployment","children":[]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Supports OpenAI, Anthropic, Google, and other providers","plainChildren":""},{"type":"item","level":1,"content":"Environment variable-based API key management","plainChildren":""},{"type":"item","level":1,"content":"Interactive /login command for authentication","plainChildren":""}]}]},{"type":"header","level":2,"content":"Local Offline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Developer Experience","children":[]},{"type":"header","level":2,"content":"Context Management","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Session persistence per working directory","plainChildren":""},{"type":"item","level":1,"content":"History stored as .jsonl files in ~/.neovate/projects/<project_name>/","plainChildren":""},{"type":"item","level":1,"content":"@ symbol for adding files and directories to context","plainChildren":""}]}]},{"type":"header","level":2,"content":"Direct File References","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"@ symbol with fuzzy search matching for files and directories","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Session forking with esc-esc","plainChildren":""},{"type":"item","level":1,"content":"/clear command preserves original session file","plainChildren":""}]}]},{"type":"header","level":2,"content":"Git Support","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Git workflow automation","plainChildren":""},{"type":"item","level":1,"content":"Intelligent commit messages and branch management","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Built-in plugin system with multiple hooks","plainChildren":""},{"type":"item","level":1,"content":"Custom providers, skills configuration, integration points","plainChildren":""},{"type":"item","level":1,"content":"Companies build proprietary versions (Ant Group, Kuaishou)","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Multiple extension points throughout codebase","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"/login for provider selection","plainChildren":""},{"type":"item","level":1,"content":"/model for model selection","plainChildren":""},{"type":"item","level":1,"content":"/clear for new session","plainChildren":""},{"type":"item","level":1,"content":"Custom slash commands via plugins","plainChildren":""}]}]},{"type":"header","level":2,"content":"Skills","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Custom skill paths for project-specific capabilities","plainChildren":""}]}]},{"type":"header","level":2,"content":"Custom Modes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Interactive mode (default conversational interface)","plainChildren":""},{"type":"item","level":1,"content":"Headless mode for automation and CI/CD","plainChildren":""},{"type":"item","level":1,"content":"Plan mode for reviewing implementation before execution","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Parallel Agent approach support","plainChildren":""},{"type":"item","level":1,"content":"Multiple agents can work concurrently on tasks","plainChildren":""}]}]}],"sourcePath":"neovate.md"},{"type":"header","level":1,"content":"OpenCode - https://opencode.ai","children":[{"type":"text","content":"A terminal-native, open-source AI coding assistant that brings LLM-powered code understanding, generation and editing directly into the developer's terminal. OpenCode focuses on privacy (local-first model support), extensibility (custom actions/skills), and deep integration with developer workflows (git, LSP, shell)."},{"type":"header","level":2,"content":"General Info","children":[]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Terminal","plainChildren":""}]}]},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"v1.1.44 (2026-01-30)"}]},{"type":"header","level":2,"content":"Repo","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"https://github.com/sst/opencode","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"text","content":"- [5] Terminal-native, privacy-first design    \n- [5] Broad LLM provider support (Models.dev)    \n- [4] Rich toolset for file, shell, and repo operations"}]},{"type":"header","level":2,"content":"Short Description","children":[{"type":"text","content":"A terminal-native, local-first AI coding assistant with a TUI for interactive planning and building; supports local and cloud LLMs, LSP integration, git-aware editing, and extensible skills/actions."}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"OpenCode is an open-source AI assistant designed for use from the terminal. It provides a conversational interface and a suite of programmatic tools (file operations, grep/glob, patch/apply, diagnostics, shell execution, fetch, Sourcegraph search, etc.) that allow the assistant to read, explain, modify and create code in the context of a repository. OpenCode supports both cloud and local LLMs (through Models.dev and adapters such as Ollama), can initialize project context, produce implementation plans, and then switch to a build mode to apply edits. Its architecture supports extensible actions/skills and hierarchical agents for complex tasks."}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Any","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"text","content":"- Strong privacy posture: can run entirely with local models so source code does not need to be uploaded to third-party APIs.    \n- Rich tool set that mirrors common CLI developer actions (ls, grep, view, write, edit, patch, bash) so it can operate robustly on repositories.    \n- Useful workflow modes: Plan mode (no edits, design/strategy) and Build mode (apply changes). Includes undo/redo for edits.    \n- Integrates with LSP/diagnostics for precise error detection and fixes.    \n- Extensible via custom actions/skills and supports spawning sub-agents for task decomposition.    \n- Good fit for polyglot environments and CI/CD automation where a terminal-first interface and scriptability are advantages.    \n- Main website: https://opencode.ai — repo and docs live at https://github.com/sst/opencode"}]},{"type":"header","level":2,"content":"Last Update","children":[{"type":"text","content":"2026-01-30"}]},{"type":"header","level":2,"content":"Licensing","children":[]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"MIT","plainChildren":""}]}]},{"type":"header","level":2,"content":"Free Trial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"N/A","plainChildren":""},{"type":"item","level":1,"content":"Open-source software (permanently free), not a time-limited trial","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"text","content":"MCP Support"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No"}]}]},{"type":"header","level":2,"content":"MCP-Prompts","children":[{"type":"text","content":"Prompts"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No"}]}]},{"type":"header","level":2,"content":"MCP-Tools","children":[{"type":"text","content":"Tools"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes"}]}]},{"type":"header","level":2,"content":"MCP-Resources","children":[{"type":"text","content":"Resources"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No"}]}]},{"type":"header","level":2,"content":"ACP","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Deployment","children":[]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Local Offline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Supports running with local model backends (e.g. Ollama) and Models.dev adapters.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Developer Experience","children":[]},{"type":"header","level":2,"content":"Context Management","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"OpenCode builds and maintains repository-aware context by scanning and indexing the project (repository analysis via `/init`) and persisting session state and conversation history in SQLite. It exposes project-scoped sessions, keeps file associations, and uses LSP and file-system reads to surface relevant snippets when answering questions or generating changes. See: https://github.com/sst/opencode and https://opencode.ai/docs","plainChildren":""}]}]},{"type":"header","level":2,"content":"Direct File References","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Files can be directly referenced and manipulated via the CLI/TUI: file explorer panels, explicit read/view/edit actions, patch/apply operations, and path-based prompts. The assistant can open specific files, show diffs, write changes, and apply/revert patches programmatically.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"OpenCode supports undo/redo for edits, persistent session history (SQLite), and shows diffs/patches to review before applying. It also integrates with Git workflows so developers can rely on VCS history as an additional checkpoint mechanism.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Git Support","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Extensible via actions/skills, model adapters, and custom commands. Developers can add new \"skills\" or adapters (e.g., Ollama, Models.dev connectors) and script bespoke tool integrations. There is no single centralized marketplace documented; extensibility is file- and config-driven in the repo.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"There are no widely-documented lifecycle \"hook\" events for agent-generated actions similar to webhooks or lifecycle callbacks. Extensibility is provided via custom actions/skills and command extensions rather than a formal lifecycle hook system (see actions/skills and custom commands in the docs/repo).","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"OpenCode provides slash-style commands for common workflows (examples include `/init` to analyze a repo, `/undo` and `/redo` to revert or restore changes). Users can create custom commands/prompts to speed repetitive interactions.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Skills","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Extensible via custom actions/skills. Skills and actions act as specialized capabilities that can be added for domain-specific tasks and reused across sessions.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Custom Modes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"OpenCode provides at least two explicit modes: Plan Mode (read-only design/planning) and Build Mode (apply edits). Modes can be toggled in the TUI (Tab key), enabling different agent behaviours (e.g., generate a plan vs. make changes).","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"The architecture supports hierarchical agents and the spawning of sub-agents (subtasks/skills) for decomposing complex work into smaller steps; custom actions/skills can act as specialized subagents for domain tasks.","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"text","content":"MCP Support"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes"}]}]},{"type":"header","level":2,"content":"MCP-Protocol-Version","children":[{"type":"text","content":"2025-06-18"}]},{"type":"header","level":2,"content":"MCP-Roots","children":[{"type":"text","content":"Roots"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No"}]}]},{"type":"header","level":2,"content":"MCP-Sampling","children":[{"type":"text","content":"Sampling"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No"}]}]},{"type":"header","level":2,"content":"MCP-Tasks","children":[{"type":"text","content":"Tasks"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No"}]}]}],"sourcePath":"opencode.md","mcpEnrichment":{"clientId":"opencode","title":"Opencode","url":"https://opencode.ai","protocolVersion":"2025-06-18","capabilities":{"tools":{"listChanged":true},"prompts":false,"resources":false,"roots":false,"sampling":false,"elicitation":false,"logging":false,"tasks":false}}},{"type":"header","level":1,"content":"Pi - https://github.com/mariozechner/pi","children":[{"type":"text","content":"Pi is a minimal terminal-based coding agent harness designed as an alternative to traditional IDEs, enabling developers to interact with AI language models through a command-line interface. Built around the principle of \"adapt pi to your workflows, not the other way around,\" Pi emphasizes constraints and minimalism to avoid unnecessary complexity while providing a complete orchestration system combining an agent loop, terminal UI framework, and execution tools.\n\n**Dataset ID:** terminal"},{"type":"header","level":2,"content":"General Info","children":[]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Terminal","plainChildren":""}]}]},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Repo","children":[{"type":"text","content":"https://github.com/mariozechner/pi"}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Short Description","children":[{"type":"text","content":"Minimal terminal coding agent harness with multi-provider support and extensible architecture"}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"Pi operates as a terminal-based AI coding agent framework consisting of three main components: pi-ai (unified LLM API supporting multiple providers), agent loop (handles orchestration by processing user messages, executing tool calls, feeding results back to the LLM, and repeating until completion), and pi-tui (terminal user interface that renders conversations and agent interactions).\n\nThe system employs differential rendering where the interface only redraws changed components rather than re-rendering the entire screen, improving performance and responsiveness. This leverages the native terminal's built-in functionality like natural scrolling and search within the scrollback buffer, creating a linear conversation interface that mirrors chat-based interactions. Pi supports four primary tools: file operations (read/write), bash command execution, text replacements, and content search (grep/find/ls)."}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Any","plainChildren":""},{"type":"item","level":1,"content":"Can execute tools in any language via bash tool (bash, NodeJS, Python, Go, etc.)","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"text","content":"Distributed via npm as command-line package. Supports Gateway architecture for multi-platform integration (WhatsApp, Telegram, Discord, iMessage). Includes pi-interactive-shell extension for autonomous CLI control within observable overlay (vim, htop, psql, ssh, docker logs). Supports streaming output, session continuation and branching."}]},{"type":"header","level":2,"content":"Last Update","children":[{"type":"text","content":"2026-01-31"}]},{"type":"header","level":2,"content":"Licensing","children":[]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"MIT","plainChildren":""}]}]},{"type":"header","level":2,"content":"Free Trial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Fully open source","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"text","content":"MCP Support"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No"}]}]},{"type":"header","level":2,"content":"Prompts","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Tools","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"File operations (read/write)","plainChildren":""},{"type":"item","level":1,"content":"Bash command execution","plainChildren":""},{"type":"item","level":1,"content":"Text replacements","plainChildren":""},{"type":"item","level":1,"content":"Content search (grep/find/ls)","plainChildren":""}]}]},{"type":"header","level":2,"content":"Resources","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"ACP","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Deployment","children":[]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Supports Anthropic, OpenAI, Google, xAI, Groq, Cerebras, OpenRouter, and any OpenAI-compatible endpoint","plainChildren":""},{"type":"item","level":1,"content":"Azure and Bedrock support","plainChildren":""}]}]},{"type":"header","level":2,"content":"Local Offline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Supports any OpenAI-compatible endpoint including local models","plainChildren":""}]}]},{"type":"header","level":2,"content":"Developer Experience","children":[]},{"type":"header","level":2,"content":"Context Management","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Mid-session model switching","plainChildren":""},{"type":"item","level":1,"content":"Cost and token tracking","plainChildren":""},{"type":"item","level":1,"content":"Message queuing during agent execution","plainChildren":""}]}]},{"type":"header","level":2,"content":"Direct File References","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Editor with fuzzy file search, path completion, and drag-and-drop functionality","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Session continuation and branching","plainChildren":""}]}]},{"type":"header","level":2,"content":"Git Support","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Extensible","children":[]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Aggressively extensible via TypeScript extensions","plainChildren":""},{"type":"item","level":1,"content":"Third-party packages installable from npm or git","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Skills","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Skills support","plainChildren":""},{"type":"item","level":1,"content":"Prompt templates","plainChildren":""}]}]},{"type":"header","level":2,"content":"Custom Modes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Interactive mode (full TUI)","plainChildren":""},{"type":"item","level":1,"content":"Print/JSON mode for scripts","plainChildren":""},{"type":"item","level":1,"content":"RPC mode for process integration","plainChildren":""},{"type":"item","level":1,"content":"SDK mode for embedding in custom applications","plainChildren":""},{"type":"item","level":1,"content":"Tool restriction options (e.g., read-only mode for planning)","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Can recursively spawn itself within tmux sessions for full observability","plainChildren":""}]}]}],"sourcePath":"pi.md"},{"type":"header","level":1,"content":"Warp - https://www.warp.dev","children":[{"type":"text","content":"Modern AI-powered terminal and agentic development environment focused on unifying natural-language agents, terminal commands, and collaborative \"Drive\" features for teams."},{"type":"header","level":2,"content":"General Info","children":[]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Terminal","plainChildren":""}]}]},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"- v2.0 (2025-09-01)    \n- Specific release date unavailable; major v2.0 release occurred in September 2025"}]},{"type":"header","level":2,"content":"Repo","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"https://www.warp.dev","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"text","content":"- [5] Best-in-class terminal + AI integration (Agent Mode, Drive, Warp Code)    \n- [4] Commercial/proprietary product; some enterprise privacy controls but limited public BYOK/local-offline detail"}]},{"type":"header","level":2,"content":"Short Description","children":[{"type":"text","content":"Warp is a modern terminal that has evolved into an \"Agentic Development Environment\" (ADE). It tightly integrates large language models and agent workflows with the command line, providing natural-language command generation, an interactive chat/agent interface (Agent Mode), collaborative Drive features (Workflows, Notebooks, shared Environment Variables), and code-focused tooling (Warp Code with diff-tracking). Warp's interface lets developers mix prompts and shell commands in a single input, run multi-step agent plans, review and accept diffs produced by agents, and share/run parameterized Workflows across teams."},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"AI-powered terminal and Agentic Development Environment (ADE) that combines natural-language Agent Mode, Warp Code (live diffing and stepwise code edits), and Warp Drive (shared Workflows, Notebooks, prompts and environment variables) to enable collaborative, model-driven development workflows within the terminal.### Description","plainChildren":""}]}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Any","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"text","content":"- Key features: Agent Mode (natural language -> commands), Warp Code (diff-tracking and stepwise code edits by agents), Drive (shared Workflows and Notebooks), Planning Mode and multi-agent orchestration.    \n- Privacy controls: granular autonomy settings (allowlists/denylists, pause/approve diffs, control file access), network logging, and zero-data-retention guarantees for enterprise customers.    \n- Strengths: Unified UX for prompt + shell input, native diff review for agent-made changes, strong collaboration primitives for teams.    \n- Limitations / unknowns: public documentation is limited on BYOK (bring-your-own-key) and fully offline local LLM operation; product is proprietary which may limit on-premise customization for some organizations.    \n- Recommended when: you want a first-class terminal with integrated AI agents and team sharing (Drive), and you prefer an opinionated, commercial product with enterprise privacy controls rather than an open-source self-hosted solution."}]},{"type":"header","level":2,"content":"Last Update","children":[{"type":"text","content":"2026-01-30"}]},{"type":"header","level":2,"content":"Licensing","children":[]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Proprietary","plainChildren":""}]}]},{"type":"header","level":2,"content":"Free Trial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"text","content":"MCP Support"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No"}]}]},{"type":"header","level":2,"content":"Prompts","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Supports natural-language input as the primary interface; stored prompt templates and reusable prompts are persisted in Warp Drive and can seed Workflows and agents. Agents present a plan before execution and prompts can be edited or parameterized per Workflow.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Tools","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Agents can invoke shell commands as tools, interact with Git, run code edits via Warp Code, call selected LLM providers via configured MCP/model integrations, and execute Drive Workflows.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Resources","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Warp Drive stores shared resources (Workflows, Notebooks, commands, prompts, and environment variables) that agents can access as contextual artifacts.","plainChildren":""}]}]},{"type":"header","level":2,"content":"ACP","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Deployment","children":[]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Warp allows configuration of LLM providers and supports enterprise proxy/BYOK arrangements (customer-supplied API keys or proxying) in enterprise plans. Public documentation is limited on fully self-hosted/on-prem BYOK flows; contact sales/enterprise docs for details.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Local Offline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Note: Warp runs a local classifier to detect natural-language input, and some metadata/local processing happens on-device, but AI requests are typically proxied to selected LLM providers (OpenAI, Anthropic/Claude variants) unless explicitly configured via enterprise arrangements. There is no broadly-documented fully-offline LLM mode for the AI assistant as of the latest public releases.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Developer Experience","children":[]},{"type":"header","level":2,"content":"Context Management","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Methods include attaching files and images, referencing file paths, persisting Drive artifacts (Workflows/Notebooks/Env vars), and allowing agents to request additional context interactively during multi-step plans.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Direct File References","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"You can reference and attach specific files/paths as context for agents; Warp Code surfaces file-level diffs and agents can propose edits to particular files which are shown in the live diff UI.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Warp provides live diff review and approval before applying changes; edits from agents can be accepted, rejected or modified and then committed to Git. Drive artifacts also provide shared versions and history for collaborative workflows.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Git Support","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Git workflows are supported via the terminal and Warp's code/diff UX; the tool is used to author and review code diffs produced by agents.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Support for Workflows, Notebooks, Drive-based sharing and agent configuration enables extensibility of team knowledge and repeatable automation patterns.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"No public plugin marketplace or documented plugin API; extensibility is primarily via Drive Workflows, Notebook artifacts, and model/agent configuration.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"No documented lifecycle hook API for agents; control is provided via agent permissions, allowlists/denylists and approval workflows.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"No public global slash-command system documented; parameterized Workflows serve as invocable shortcuts and templates.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Skills","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Custom Modes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Built-in modes include Command Mode, Agent Mode, and Planning Mode. Agent autonomy and behavior can be tuned per agent/Workflow (pause-for-approval, review diffs, allowlists/denylists).","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Warp supports running multiple agents and orchestrating multi-agent workflows. While there is multi-agent orchestration and task chaining, there is no widely-published \"subagent API\" name — orchestration is handled via the agent management UI and planning features.","plainChildren":""}]}]}],"sourcePath":"warp.md"}]