[{"type":"header","level":1,"content":"Aix Coder - https://www.aixcoder.com","children":[{"type":"text","content":"AIXcoder (often styled aiXcoder or Aix Coder) is an AI-powered code-completion and generation assistant with a local-first design that emphasizes privacy and offline capability. It provides method-level code generation, smart completion, and code search, and integrates into popular IDEs to assist developers across languages and workflows."},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"(2025-10-19)"}]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Editor","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[]},{"type":"header","level":2,"content":"Repository","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Any","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"AIXcoder is designed as a developer productivity tool that lives inside the IDE and can operate in local/offline mode so that source code does not leave the developer's machine. It offers context-aware code completion (single- and multi-line), method-level code generation from natural-language prompts, intelligent code search across repositories, and features intended to help with refactoring, debugging and finding relevant APIs. A key differentiator is a quantized local model (reported as a ~7B parameter model) that the vendor positions as performant enough to run on commodity hardware (e.g., laptops with ~8–16GB RAM) while delivering low-latency completions."}]},{"type":"header","level":2,"content":"BYOK","children":[]},{"type":"header","level":2,"content":"LocalOffline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"AIXcoder emphasizes local/offline model operation so code and context can remain on-device. The product also offers cloud modes for extended functionality.","plainChildren":""}]}]},{"type":"header","level":2,"content":"FreeTrial","children":[]},{"type":"header","level":2,"content":"GitSupport","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Integrates with repository search and can surface examples and API usage from GitHub/open-source code; version-control integration is part of the IDE workflow.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Terminal","children":[]},{"type":"header","level":2,"content":"Opensource","children":[]},{"type":"header","level":2,"content":"License","children":[]},{"type":"header","level":2,"content":"MCP-Client","children":[]},{"type":"header","level":2,"content":"Notes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Offline/local-first: One of the product's main selling points is the ability to run a quantized model locally to avoid sending source code to the cloud — appealing for privacy-sensitive and regulated environments.","plainChildren":""},{"type":"item","level":1,"content":"Model: Public materials reference an aiXcoder-7B model (quantized) that aims to balance capability and resource usage; vendor material claims strong benchmark performance relative to much larger models in certain code-completion tasks.","plainChildren":""},{"type":"item","level":1,"content":"Integrations: Official IDE integrations include VS Code, JetBrains (IntelliJ family), and Eclipse, making the tooling accessible within common developer environments.","plainChildren":""},{"type":"item","level":1,"content":"Features: Method-level code generation (generate a complete function from a description), multi-line/context-aware completions, code search across repos, and refactoring/debugging assistance.","plainChildren":""},{"type":"item","level":1,"content":"Resource profile: Because the local model is quantized, vendors indicate it can run on modest hardware (4–8GB for very small setups, better experience with 8–16GB and/or modest GPUs), though exact requirements depend on the chosen deployment mode and model precision.","plainChildren":""},{"type":"item","level":1,"content":"Enterprise options: There are team/enterprise offerings with custom intelligence, private deployment, and analytics for developer efficiency; details and pricing vary by vendor engagement.","plainChildren":""},{"type":"item","level":1,"content":"Unclear / not publicly confirmed: specific license details for the model and tooling, BYOK (bring-your-own-key) support for cloud features, explicit terminal/CLI tooling support, and whether the project or models are fully open-source. If these are critical, verify with the vendor or product documentation before selecting the tool.","plainChildren":""}]}]},{"type":"header","level":2,"content":"ContextManagement","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"AIXcoder supports multiple context management approaches: local on-device inference (keeps workspace/context local), context windowing in the IDE plugin (captures nearby file contents and project context for completions), and optional cloud mode where selected context may be sent for enhanced generation.","plainChildren":""}]}]},{"type":"header","level":2,"content":"DirectFileReferences","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"The IDE integrations surface repository and file-level examples; agent can reference files from the open repo search features and local workspace context when running locally.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"IDE plugin lifecycle hooks and model pinning enable attaching to lifecycle events (suggestion shown/accepted/rejected, telemetry emission). Enterprise/private deployments can be integrated into CI/CD to ensure deterministic suggestions.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Within supported IDEs, aiXcoder exposes quick actions and command palette entries (e.g., trigger generation, search) that act like reusable commands; exact support depends on the IDE plugin.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"aiXcoder supports specialized workflows (search, generation, repair) that behave like subagents; enterprise/custom models or fine-tuned variants can be deployed to handle task-specific flows (e.g., network automation script generation).","plainChildren":""}]}]},{"type":"header","level":2,"content":"CustomModes","children":[]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"aiXcoder bundles IDE plugins (VS Code, JetBrains, Eclipse) that package UI commands, context capture, and model inference; enterprise offerings include private bundles and integrations for internal tooling.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[]},{"type":"header","level":2,"content":"SpecDrivenDevelopment","children":[]}],"sourcePath":"aix-coder.md"},{"type":"header","level":1,"content":"Amazon Q Developer - https://aws.amazon.com/q/","children":[{"type":"text","content":"Amazon Q Developer (sometimes shortened to \"Amazon Q\") is AWS's developer-facing generative-AI platform that provides conversational assistance, code generation, and developer tooling integrated directly into popular IDEs and the AWS Console. It consolidates earlier AWS coding assistants (including CodeWhisperer) into a single experience and adds workspace-aware chat, documentation generation, security scanning, and integrations with external context providers."},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"vN/A (2025-10-19)"}]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Editor","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"[4] IDE & AWS integration (deep integration with AWS services and IDE toolchains)","plainChildren":""},{"type":"item","level":1,"content":"[4] Productivity (context-aware chat, inline suggestions, code actions, and docs generation)","plainChildren":""},{"type":"item","level":1,"content":"[3] Privacy/enterprise controls (cloud-hosted, limited BYOK/local/offline options)","plainChildren":""},{"type":"item","level":1,"content":"[4] Extensibility (MCP/plugins and third-party integrations)","plainChildren":""}]}]},{"type":"header","level":2,"content":"Repository","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"https://aws.amazon.com/q/ (service documentation)","plainChildren":""}]}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Any","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Supports Model Context Protocol (MCP) connections and a plugin/alias system for third-party tooling (monitoring, security providers)","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"Amazon Q Developer is an AWS-hosted generative-AI assistant for developers that embeds into IDEs (VS Code, JetBrains family, Eclipse, Visual Studio) and the AWS Console. It provides:\nAmazon Q unifies prior AWS assistants (CodeWhisperer features were integrated into the Amazon Q experience in 2024) and is intended to accelerate development on AWS services while providing deeper context about a project and its cloud resources."},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Conversational chat and agentic workflows for understanding and modifying code","plainChildren":""},{"type":"item","level":1,"content":"Inline suggestions and code actions (Explain, Refactor, Fix, Optimize, Generate Tests, etc.) directly from the editor","plainChildren":""},{"type":"item","level":1,"content":"Documentation generation (e.g., create README or component docs via chat commands)","plainChildren":""},{"type":"item","level":1,"content":"Security scanning and guidance surfaced alongside code suggestions","plainChildren":""},{"type":"item","level":1,"content":"Integrations with external context providers through MCP and plugin aliases (e.g., CloudZero, Datadog, Wiz)","plainChildren":""},{"type":"item","level":1,"content":"Code transformation and migration helpers for language/OS modernization","plainChildren":""}]}]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"LocalOffline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"FreeTrial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Notes: AWS has offered free tiers or developer-friendly access for prior services (CodeWhisperer) and provides Builder ID sign-in options; enterprise pricing & feature bundles for Amazon Q are documented in AWS pricing/docs.","plainChildren":""}]}]},{"type":"header","level":2,"content":"GitSupport","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Works with repository workflows via IDE integrations; generated suggestions and transformations can be applied to local repos but require human review for correctness and licensing.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Terminal","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Primary surface: IDE plugins and AWS Console chat. There is no official terminal-only interactive CLI assistant equivalent documented as the main surface.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Proprietary","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Notes: Supports Model Context Protocol / MCP server connections to bring external context into conversations and agent workflows.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Supported IDEs: Visual Studio Code, JetBrains IDEs (IntelliJ, PyCharm, WebStorm, etc.), Eclipse, and Visual Studio — feature parity varies by IDE (VSCode and JetBrains typically have the richest feature set).","plainChildren":""},{"type":"item","level":1,"content":"Authentication: Supports AWS Builder ID and IAM Identity Center. Builder ID allows individuals to use Amazon Q without an AWS account; IAM Identity Center sessions for Amazon Q may have extended durations (90 days for setups created on/after 2024-04-18 in some configurations).","plainChildren":""},{"type":"item","level":1,"content":"Example editor actions: select code → right-click → Amazon Q → Explain / Refactor / Fix / Optimize / Generate Tests / Send to Prompt / Inline Chat.","plainChildren":""},{"type":"item","level":1,"content":"Documentation generation: a chat command (e.g. `/doc`) can be used to create README or other docs by analyzing the workspace.","plainChildren":""},{"type":"item","level":1,"content":"Security & reference tracking: inherits capabilities from CodeWhisperer lineage — surfaces potential vulnerabilities, license/reference links when generated code closely matches examples, and provides remediation guidance.","plainChildren":""},{"type":"item","level":1,"content":"Third-party plugins: Amazon Q supports integrations with monitoring/security providers via a plugin alias system in the AWS Console; examples reported include CloudZero, Datadog, Wiz (these pull provider data via APIs and Q surfaces results and deep links without sending the user's chat content to the provider).","plainChildren":""},{"type":"item","level":1,"content":"Use cases: onboarding and code comprehension, generating boilerplate, test generation, migrating or modernizing code, documenting projects, security scanning and remediation guidance, and creating AWS infra-aware code snippets.","plainChildren":""},{"type":"item","level":1,"content":"Limitations: cloud-hosted (no fully local/offline mode), generated code requires human review for correctness/security/licensing, enterprise controls and BYOK options are limited compared to self-hosted offerings.","plainChildren":""},{"type":"item","level":1,"content":"Related: Amazon CodeWhisperer functionality was consolidated into Amazon Q Developer around April 2024; for legacy references check CodeWhisperer docs (https://aws.amazon.com/codewhisperer/).","plainChildren":""}]}]},{"type":"header","level":2,"content":"ContextManagement","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Amazon Q provides multiple methods to manage and update context for IDE conversations and agentic workflows:","plainChildren":""},{"type":"item","level":1,"content":"Workspace context: the IDE plugin can analyze the open workspace (project files, dependency manifests, build files) to provide workspace-aware responses and code generation.","plainChildren":""},{"type":"item","level":1,"content":"File-level context: selecting a file or code range and invoking actions (Explain / Refactor / Fix / Send to Prompt / Inline Chat) passes that precise code as context for the assistant.","plainChildren":""},{"type":"item","level":1,"content":"Inline chat context: editor-integrated chat threads that retain recent messages and file references so follow-up prompts remain aware of prior discussion and selected files.","plainChildren":""},{"type":"item","level":1,"content":"MCP (Model Context Protocol) servers: external MCP connectors supply additional contextual sources (Jira, Figma, monitoring/security tools) which are merged into the assistant's context when configured via mcp.json and enabled in settings.","plainChildren":""},{"type":"item","level":1,"content":"Command-based context triggers: chat commands (e.g., /doc) initiate workspace-wide analyses that explicitly gather and use project context to produce artifacts (README, docs, etc.).","plainChildren":""}]}]},{"type":"header","level":2,"content":"DirectFileReferences","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Files can be directly referenced and used as context by the IDE plugin:","plainChildren":""},{"type":"item","level":1,"content":"Select-and-action model: highlight code or open a file and invoke Amazon Q actions to send that file/range as direct context to the assistant.","plainChildren":""},{"type":"item","level":1,"content":"Workspace analysis: commands like /doc trigger automated scanning of repository structure and key files to generate documentation or summaries.","plainChildren":""},{"type":"item","level":1,"content":"Deep linking in IDE: generated edits and files are applied directly into the local repository (via standard editor apply/replace flows) so references are maintained in-place.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"There is no public documentation describing a lifecycle-events/hooks API for attaching custom agent lifecycle callbacks inside Amazon Q Developer plugins. MCP enables external context providers and tool integrations, but explicit lifecycle hook APIs for agent-generated events (e.g., \"onBeforeChange\", \"onAfterApply\", or persistent event subscriptions\") are not documented in the available sources.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Amazon Q exposes chat/command triggers in supported surfaces:","plainChildren":""},{"type":"item","level":1,"content":"/doc: workspace documentation generation (create README, component docs) by analyzing the project.","plainChildren":""},{"type":"item","level":1,"content":"Editor actions exposed via context menus and inline chat (these act like command triggers: Explain, Refactor, Fix, Optimize, Generate Tests, Send to Prompt).","plainChildren":""},{"type":"item","level":1,"content":"AWS Console plugin alias prefixing: in the AWS console chat, prefixing questions with a plugin alias triggers calls to third-party plugin APIs (CloudZero, Datadog, Wiz) and surfaces provider data inline.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Amazon Q supports agentic and multi-tool workflows that act like specialized subagents:","plainChildren":""},{"type":"item","level":1,"content":"Feature development agents: natural-language feature descriptions can spawn agentic workflows that modify multiple files across the workspace to implement that feature.","plainChildren":""},{"type":"item","level":1,"content":"MCP-enabled connectors: MCP servers act as specialized tool connectors (Jira, Figma, EKS server) that the assistant can query as part of an orchestrated workflow.","plainChildren":""},{"type":"item","level":1,"content":"Automated test/code-review agents: built-in units for generating tests and performing code reviews behave like task-specialist agents executed within the IDE.","plainChildren":""}]}]},{"type":"header","level":2,"content":"CustomModes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Customization and tailoring mechanisms include:","plainChildren":""},{"type":"item","level":1,"content":"IDE settings: toggles and preferences (e.g., enable MCP, plugin aliases) to adjust how Amazon Q behaves in the developer's environment.","plainChildren":""},{"type":"item","level":1,"content":"Project-scoped context: configuring MCP servers and workspace analysis yields domain-specific behavior for a particular repository.","plainChildren":""},{"type":"item","level":1,"content":"Plugin aliasing in the AWS Console: using different aliases effectively changes the plugin/toolset the assistant will consult, producing different response modes for queries.","plainChildren":""},{"type":"item","level":1,"content":"Note: there is no strong public documentation of a formal \"mode authoring\" UI for end-users to create persistent named personas; tailoring today is primarily achieved via configuration and MCP/plugin composition.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Amazon Q supports a plugin/alias system and MCP-based integrations:","plainChildren":""},{"type":"item","level":1,"content":"AWS Console plugin aliases: third-party providers (CloudZero, Datadog, Wiz) are configured as aliases; prefixing queries with an alias causes Amazon Q to call that provider's APIs and surface results with deep links.","plainChildren":""},{"type":"item","level":1,"content":"MCP servers: act as plugin-style connectors that expose structured context and actions to the assistant (e.g., Jira issues, Figma designs, cluster data from an EKS MCP server).","plainChildren":""},{"type":"item","level":1,"content":"Privacy model: plugin usage is designed to avoid sending chat transcripts to third-party providers during configuration and use (data flows are described in docs as provider API calls initiated by the Q service and surfaced to the user).","plainChildren":""},{"type":"item","level":1,"content":"Bundling: while there isn't a published \"plugin SDK\" in the same sense as browser extensions, MCP provides the protocol for bundling tool connectors, and the AWS Console aliasing provides the user-visible mechanism to call them.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Undo / rollback options in typical workflows include:","plainChildren":""},{"type":"item","level":1,"content":"Editor undo and local change staging: changes generated by Amazon Q are applied through the IDE, so standard undo/redo and editor history apply immediately after edits.","plainChildren":""},{"type":"item","level":1,"content":"Git / VCS: recommended rollback mechanism—users can commit or stash before applying changes and use git to revert unwanted modifications (no built-in Q checkpointing was documented).","plainChildren":""},{"type":"item","level":1,"content":"No documented built-in persistent \"checkpoint\" or automatic snapshot feature inside Amazon Q itself; rely on editor and VCS for safe rollback.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SpecDrivenDevelopment","children":[]}],"sourcePath":"amazon_q_developer.md"},{"type":"header","level":1,"content":"AskCodi - https://www.askcodi.com","children":[{"type":"text","content":"AI-assisted coding assistant and unified LLM gateway for developers"},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"(2025-10-18)"}]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Editor","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"[4] Feature set and tooling","plainChildren":""},{"type":"item","level":1,"content":"[4] IDE integration and workflows","plainChildren":""},{"type":"item","level":1,"content":"[4] Privacy controls (no-save claims for extensions)","plainChildren":""},{"type":"item","level":1,"content":"[4] Value for individual developers","plainChildren":""}]}]},{"type":"header","level":2,"content":"Repository","children":[]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Any","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Plugin / \"Codi Apps\" modular tools model","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"AskCodi is an AI-powered coding assistant and OpenAI-compatible LLM gateway developed to help developers generate, explain, refactor, document, and test code. It combines a suite of focused developer tools (branded as \"Codi Apps\") with IDE extensions and an API that lets teams call multiple LLM providers through a single endpoint. AskCodi emphasizes practical developer workflows — inline completions, chat, code explanation, unit-test generation, SQL/regex builders, and automated refactors — and aims to reduce context-switching by integrating directly into popular editors."}]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"LocalOffline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"FreeTrial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"GitSupport","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Reads project context / Codespace-style integrations for richer suggestions","plainChildren":""}]}]},{"type":"header","level":2,"content":"Terminal","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"text","content":"Proprietary"}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Company/platform: positioned as a developer-focused toolkit (modular \"Codi Apps\") and an OpenAI-compatible API gateway that supports multiple model providers.","plainChildren":""},{"type":"item","level":1,"content":"Privacy: AskCodi advertises no-save behavior for its extensions (privacy-focused by design), but it is primarily a cloud service.","plainChildren":""},{"type":"item","level":1,"content":"Pricing: offers a Free tier and paid tiers (reported consumer Premium yearly plan around mid-range pricing); paid tiers increase AI credits, access to advanced models, and higher limits.","plainChildren":""},{"type":"item","level":1,"content":"Integrations: VS Code extension (marketplace), other IDE support (JetBrains/IntelliJ family, Sublime, Neovim and others via community extensions).","plainChildren":""},{"type":"item","level":1,"content":"Use cases: rapid snippet generation, documentation and docstring creation, unit-test generation, SQL/regex generation, refactoring, and code explanation for onboarding or legacy code comprehension.","plainChildren":""},{"type":"item","level":1,"content":"Notable strengths: multi-model gateway, modular task-oriented toolset, direct IDE integrations.","plainChildren":""},{"type":"item","level":1,"content":"Caveats: not open-source and primarily cloud-based; enterprise/local deployment and exact BYOK/local-offline capabilities should be confirmed against AskCodi's current documentation or sales/enterprise channels for sensitive or regulated environments.","plainChildren":""}]}]},{"type":"header","level":2,"content":"ContextManagement","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Codespaces: full-project upload/workspace that provides the model with repository-wide context (files, deps, project structure) for more accurate, consistent suggestions.","plainChildren":""},{"type":"item","level":1,"content":"Codi Workbook: continuous, Jupyter-style sessions that preserve conversational and code-generation context across interactions within a project.","plainChildren":""},{"type":"item","level":1,"content":"IDE extensions: session- and project-scoped chat history in Codi Chat; model selection and project settings help tailor contextual behavior.","plainChildren":""},{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"DirectFileReferences","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"IDE extensions and Codespaces allow the assistant to reference files by path and read project files — open-file context in editors and uploaded workspace content in Codespaces enable targeted file-level operations.","plainChildren":""},{"type":"item","level":1,"content":"Project-level workbooks/conversations can be associated with a project workspace so prompts and generations can point to specific files or directories within that workspace.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"No public documentation found describing lifecycle hooks (webhooks, pre/post-generation hooks, or plugin lifecycle events) for AskCodi; if required for automation, confirm with AskCodi support or enterprise docs.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"There is no clear, public reference to a Slack-style or chat-slash-command system in AskCodi's public docs. IDE integrations do expose commands via editor command palettes, but an explicit \"slash command\" interface in the chat is not documented.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Codi Apps: modular, task-oriented tools (code generation, test generation, SQL/regex builders, explainers) act like specialized agents for distinct developer tasks and can be selected per workflow.","plainChildren":""},{"type":"item","level":1,"content":"Workbooks and project-based conversations let you compose and reuse focused tool flows that function similarly to subagents for project-specific needs.","plainChildren":""}]}]},{"type":"header","level":2,"content":"CustomModes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Model selection and per-project settings let teams select different LLMs or presets for specific workflows (e.g., choose Claude vs. GPT for particular task types), effectively creating tailored modes.","plainChildren":""},{"type":"item","level":1,"content":"Codi Apps + Workbook combinations function as configurable modes for focused tasks (e.g., a testing mode using the unit-test generator app).","plainChildren":""}]}]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Codi Apps: an internal modular plugin-like system of specialized tools that provide focused capabilities (refactors, test generation, SQL/regex builders, explainers).","plainChildren":""},{"type":"item","level":1,"content":"IDE plugins: official extensions for VS Code and other community extensions for JetBrains, Neovim, Sublime, Zed, Cursor, Continue.dev that integrate AskCodi features directly into editors.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"AskCodi does not publicly document a built-in \"checkpoint/undo\" feature for generated changes; typical recovery/rollback would be handled via VCS (git) in the uploaded Codespace or local editor. Confirm enterprise/backups features with AskCodi sales/support for advanced checkpointing.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SpecDrivenDevelopment","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Other","plainChildren":""},{"type":"item","level":1,"content":"Not applicable / no direct mapping: AskCodi is a developer tooling platform and LLM gateway rather than a spec-driven development framework; it does not advertise built-in support for any of the above SDD frameworks in public documentation.","plainChildren":""}]}]}],"sourcePath":"ask-codi.md"},{"type":"header","level":1,"content":"Augment Code - https://augmentcode.com","children":[{"type":"text","content":"AI-powered developer platform focused on deep codebase understanding and autonomous coding agents."},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"vN.N (yyyy-mm-dd)"}]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Editor","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[]},{"type":"header","level":2,"content":"Repository","children":[]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Any","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Plugins / IDE extensions (VS Code, JetBrains, Vim/Neovim)","plainChildren":""},{"type":"item","level":1,"content":"Integrations with GitHub, Jira, Confluence, Notion, Linear","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"Augment Code is an AI-first development platform built to help professional engineers work with large, complex codebases. It uses a high-capacity context engine (advertised ~200k tokens of context), continuous embeddings of code and docs, and persistent \"Memories\" to provide deeply contextual completions, autonomous agents, and stepwise \"Next Edit\" navigation through multi-file changes. It supports autonomous agents that can plan, build, and open pull requests, and integrates with many developer tools and infra via MCP and native integrations."}]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"LocalOffline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Cloud-first product; local/in-IDE operations likely use cloud model/augmentation","plainChildren":""}]}]},{"type":"header","level":2,"content":"FreeTrial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"GitSupport","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Terminal","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"CLI and TUI available","plainChildren":""}]}]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Proprietary","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Strong focus on enterprise workflows and large monorepos; features include Smart Apply, Next Edit navigation, change checkpoints, persistent memories, and multi-modal inputs (screenshots, Figma).","plainChildren":""},{"type":"item","level":1,"content":"Industry benchmark claims (HWE Bench top-ranked, e.g., 65.4% on HWE)","plainChildren":""}]}]},{"type":"header","level":2,"content":"ContextManagement","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Augment Code provides multiple context management methods: a high-capacity context engine (advertised ~200k tokens) that indexes entire repositories and their docs; persistent \"Memories\" that learn preferences and reuse prior decisions; explicit focus-context selection (file, folder, or code-block focus); on-demand reindexing/refresh; and MCP-based connectors to enrich context with external services (docs, CI, issue trackers).","plainChildren":""}]}]},{"type":"header","level":2,"content":"DirectFileReferences","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Files can be directly referenced and targeted: users select files or folders in the UI or editor extension, chat answers include source citations and file links, Next Edit and Smart Apply place edits into the correct files, and the CLI/TUI supports file-path targeting. Agents can open PRs and create checkpoints tied to specific files.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Augment exposes lifecycle-style events and checkpoints that can be observed or acted on: plan/intent creation, edit proposal generation, Smart Apply execution, checkpoint creation, rollback/restore, PR opened/merged, and terminal command execution (with approval). Integrations and MCP connectors surface these events to external systems (e.g., CI, issue trackers) for automation and auditing.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"The platform supports re-usable, user-triggered commands across interfaces: editor commands (VS Code/JetBrains), CLI/TUI invocations, and chat actions (apply, propose, create checkpoint). These act like reusable operations users can invoke to apply agent capabilities consistently.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Augment supports specialized autonomous agents or agent modes for task-specific workflows: local/IDE agents and remote/cloud agents that can plan, execute edits, run tests, and open PRs. Agents can be configured with different permissions, memories, and tool access via MCP connectors to create focused subagents for e.g., security fixes, refactors, or dependency upgrades.","plainChildren":""}]}]},{"type":"header","level":2,"content":"CustomModes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Users can create specialist modes / profiles that tailor the assistant for particular tasks or styles: project profiles, role-specific modes (reviewer, maintainer, refactorer), model and memory selection, and policy/permission presets. These modes adjust agent behavior, allowed actions, and context-scope.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Augment offers an extensibility model via editor plugins (VS Code, JetBrains, Vim/Neovim), MCP connectors and native integrations (GitHub, Jira, Confluence, Notion, Linear). These bundle commands, agent capabilities, and integration hooks so teams can compose workflows and connect external tools.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"The platform provides change checkpoints and snapshotting for safe experimentation: automatic change tracking, named checkpoints before applying edits, easy rollback/restore, and Git/PR-backed snapshots for human review. Checkpoints are central to Smart Apply / Next Edit flows.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SpecDrivenDevelopment","children":[{"type":"text","content":"---"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Other","plainChildren":""},{"type":"item","level":1,"content":"Augment also demonstrates spec-aware behaviors (e.g., checking edits against OpenAPI specs and service contracts) but does not publish a single public SDD framework name. For projects using Tessl (this repository), Augment's features (Next Edit, checkpoints, spec/contract checks) complement a Tessl-style spec-driven workflow.","plainChildren":""}]}]}],"sourcePath":"augment-code.md"},{"type":"header","level":1,"content":"Brokk - https://brokk.ai","children":[{"type":"text","content":"[ An AI-native code assistant optimized for large codebases; standalone Java desktop app that provides workspace-driven context engineering, Deep Scan, Agentic Search, and agentic Code/Ask/Architect workflows. Ideal for supervising LLMs with compiler-grade context in monorepos (especially Java). ]"},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"v0.1 (2025-10-19)"}]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Editor","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"[4] Strong for large, statically-typed codebases (Java monorepos): excellent context management and static-analysis driven workflows","plainChildren":""},{"type":"item","level":1,"content":"[3] Desktop-first UI and GPL-3.0 licensing may be tradeoffs for some teams","plainChildren":""}]}]},{"type":"header","level":2,"content":"Repository","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"https://github.com/BrokkAi/brokk","plainChildren":""}]}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Java","plainChildren":""},{"type":"item","level":1,"content":"Other","plainChildren":""},{"type":"item","level":1,"content":"Can analyze and work with other languages via dependency decompilation / semantic indexing; used in demos with Python and mixed stacks)","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"[Brokk is a standalone, Java-based desktop application that rethinks AI-assisted coding for large repositories. Instead of treating a repo as text, Brokk builds compiler-grade context using static analysis (Joern) and semantic indexing, then exposes that curated context to LLMs via a Workspace. Key capabilities include Deep Scan (automated context recommendations), Agentic Search (symbol-aware project search), Code/Ask/Architect agents for different levels of intervention, dependency decompilation, and Git/history-aware context. Brokk's design focuses on reducing hallucinations and cost by giving models only the precise context they need rather than the entire repository.]"}]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"LocalOffline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"[Brokk's client is open-source Java software; it ships with or can leverage Jlama for local/tiny-model inference and supports workflows that minimize cloud calls. Some advanced features may use hosted models depending on configuration.]","plainChildren":""}]}]},{"type":"header","level":2,"content":"FreeTrial","children":[]},{"type":"header","level":2,"content":"GitSupport","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Terminal","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"GNU General Public License v3.0 (GPL-3.0)","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[]},{"type":"header","level":2,"content":"Notes","children":[{"type":"text","content":"[Additional details:]"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Workspace-first UX: users curate a Workspace of files, summaries, diffs and dependency artifacts so the LLM gets focused, relevant context.","plainChildren":""},{"type":"item","level":1,"content":"Deep Scan: runs a richer analysis over Workspace + instructions and recommends which files to include and in what form (editable, read-only, summary).","plainChildren":""},{"type":"item","level":1,"content":"Agentic Search: symbol-aware search (classes, methods, fields, usages, call graphs) across the full repo rather than simple text grep.","plainChildren":""},{"type":"item","level":1,"content":"Action set: Code (apply edits), Ask (question/answers on Workspace), Search (project exploration), Run in Shell (execute commands), Architect (multi-step planning and execution).","plainChildren":""},{"type":"item","level":1,"content":"Dependency handling: can import and decompile dependencies so the assistant understands third-party code and reduces hallucinations.","plainChildren":""},{"type":"item","level":1,"content":"Edit Loop: attempts to build/run tests after edits and feeds failures back to the LLM for automated revisions.","plainChildren":""},{"type":"item","level":1,"content":"Technical stack: Java desktop UI (Swing), Joern for static analysis, Jlama for local/pure-Java LLM inference; integrates with Maven/Gradle builds.","plainChildren":""},{"type":"item","level":1,"content":"Best fit: large enterprises and teams working on big Java monorepos or mixed-language monorepos where understanding cross-cutting references and history matters.","plainChildren":""},{"type":"item","level":1,"content":"Licensing note: GPL-3.0 is copyleft — derivative works that incorporate Brokk's code must be released under the same license.","plainChildren":""},{"type":"item","level":1,"content":"Not an IDE plugin: Brokk is a separate application (designed intentionally), though it can work alongside IDEs and version control workflows.]","plainChildren":""}]}]},{"type":"header","level":2,"content":"ContextManagement","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Workspace-driven context: users curate a Workspace containing selected files, generated summaries, diffs and dependency artifacts so the LLM receives only the focused context it needs (editable vs read-only panes).","plainChildren":""},{"type":"item","level":1,"content":"Deep Scan: semantic, compiler-aware analysis recommends additional files and symbols to include based on the instruction and dataflow, reducing manual context selection.","plainChildren":""},{"type":"item","level":1,"content":"Dependency summaries/decompilation: third-party libraries can be imported, summarized or decompiled into the Workspace so the assistant understands external APIs.","plainChildren":""},{"type":"item","level":1,"content":"Build & history-aware context: Brokk infers build system details and can incorporate compiled artifacts and VCS history to provide richer, correct context for edits.","plainChildren":""}]}]},{"type":"header","level":2,"content":"DirectFileReferences","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Files are referenced directly via the Workspace (explicit file inclusion), Agentic Search (symbol-aware file results and usages), and Deep Scan recommendations.","plainChildren":""},{"type":"item","level":1,"content":"Code mode applies edits to concrete files in the Workspace and produces diffs/patches that are surfaced to Git; Ask mode answers are scoped to the files present in the Workspace.","plainChildren":""},{"type":"item","level":1,"content":"Paths, symbols and call-graph locations are surfaced so prompts and agent actions can target precise files or symbols.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Brokk provides distinct agent roles (Ask, Code, Architect) that act like specialized subagents for question answering, direct code edits, and multi-step autonomous planning/execution.","plainChildren":""},{"type":"item","level":1,"content":"Architect enables multi-stage task planning and execution where the system composes sequences of agent actions and can iterate on results under human supervision.","plainChildren":""}]}]},{"type":"header","level":2,"content":"CustomModes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Interaction modes: Ask vs Code (different behavior and permissions for read-only exploration vs direct edits) and Architect (orchestration mode) let users tailor the level of automation.","plainChildren":""},{"type":"item","level":1,"content":"Model/config overrides: Brokk allows configuring default models per action and selecting overrides for specific tasks, enabling cost/quality tradeoffs and task-specific tuning.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Extensibility via the open-source client: Brokk's codebase and configuration enable integration points (model providers, build system adapters, dependency importers) and teams can extend behavior by modifying or contributing to the client.","plainChildren":""},{"type":"item","level":1,"content":"BYOK and configurable model/provider integrations let organizations plug in their preferred LLMs and key management approaches.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Edits are produced as diffs/patches and Brokk is Git-aware; users can review changes, commit, or revert using standard VCS workflows.","plainChildren":""},{"type":"item","level":1,"content":"The edit/build/test loop preserves build/test results and incremental revisions, allowing iterative rollback or refinement of agent-produced changes.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SpecDrivenDevelopment","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Other","plainChildren":""},{"type":"item","level":1,"content":"Not directly applicable to Brokk; Brokk is an AI-native code-assistant and does not prescribe a specific spec-driven development framework.","plainChildren":""}]}]}],"sourcePath":"brokk-ai-coder.md"},{"type":"header","level":1,"content":"Cline - https://cline.bot","children":[{"type":"text","content":"Cline is an open-source AI coding assistant implemented as a Visual Studio Code extension that provides file editing, terminal execution, browser automation, and customizable tool integrations to help developers perform multi-step development tasks with a human-in-the-loop workflow."},{"type":"header","level":2,"content":"Version","children":[]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Editor","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"[5] Strong AI-assisted workflows and tool integrations","plainChildren":""},{"type":"item","level":1,"content":"[4] Requires external model/API keys (BYOK) which gives flexibility but adds setup","plainChildren":""},{"type":"item","level":1,"content":"[4] Powerful features (browser automation, checkpoints) but depends on model capabilities","plainChildren":""}]}]},{"type":"header","level":2,"content":"Repository","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"https://github.com/cline/cline","plainChildren":""}]}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Any","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"VS Code extension plus MCP (Model Context Protocol) support for custom tools","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"Cline is designed to act as a development partner rather than a simple autocomplete. It can create and edit files with diff previews, run terminal commands, launch browsers and interact with pages (for testing or debugging), and install or use custom MCP tools. It keeps a structured memory bank (projectbrief.md, activeContext.md, progress.md) and uses checkpointing to snapshot steps so users can compare or restore states. Work is performed in a human-in-the-loop manner: Cline proposes changes and requests confirmation before saving."}]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"LocalOffline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Any additional details like Ollama: supports local model hosts (Ollama, LM Studio) as backends for offline/local use","plainChildren":""}]}]},{"type":"header","level":2,"content":"FreeTrial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"GitSupport","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Terminal","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"MIT","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Supports multiple model providers (Anthropic Claude, OpenAI, Google Gemini, AWS Bedrock, and local hosts via Ollama/LM Studio).","plainChildren":""},{"type":"item","level":1,"content":"Provides plan & act modes to separate strategic planning from implementation.","plainChildren":""},{"type":"item","level":1,"content":"Checkpoint management lets you create snapshots at each step and restore or compare previous states.","plainChildren":""},{"type":"item","level":1,"content":"Can run dev servers (e.g., `npm run dev`), detect linter/compile errors, and assist with fixes.","plainChildren":""},{"type":"item","level":1,"content":"Memory bank files persist structured context across sessions to help the assistant retain project knowledge.","plainChildren":""},{"type":"item","level":1,"content":"Uses a usage-based model where you supply API keys (BYOK) and pay providers directly.","plainChildren":""},{"type":"item","level":1,"content":"Good fit for developers wanting an integrated AI assistant inside VS Code with extensible tooling and local model support.","plainChildren":""}]}]},{"type":"header","level":2,"content":"ContextManagement","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Cline maintains a structured \"memory bank\" (projectbrief.md, activeContext.md, progress.md) to persist and rebuild project understanding across sessions.","plainChildren":""},{"type":"item","level":1,"content":"Checkpoint management creates snapshots at each step and tool call, allowing comparison, restore, and safe experimentation.","plainChildren":""},{"type":"item","level":1,"content":"Plan & Act modes separate strategic planning from execution so context updates can be staged and reviewed before being committed.","plainChildren":""},{"type":"item","level":1,"content":"Context usage is tracked (token/context progress) and Cline selectively reads/indexes files and docs to remain within model windows while preserving salient project state.","plainChildren":""}]}]},{"type":"header","level":2,"content":"DirectFileReferences","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Cline reads, opens, edits and creates files directly inside the editor; it shows diffs and writes changes to file paths in the workspace.","plainChildren":""},{"type":"item","level":1,"content":"Files are referenced by path and integrated into Cline's context (diff views, Timeline entries, and checkpoint snapshots) so the agent can cite and act on exact files.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"MCP tools act as attachable integrations with lifecycle-like behaviors (tool installation, invocation, and result handling).","plainChildren":""},{"type":"item","level":1,"content":"Checkpoint creation/restore and Plan→Act transitions behave as lifecycle events developers can rely on when orchestrating multi-step workflows.","plainChildren":""},{"type":"item","level":1,"content":"Terminal execution and browser automation steps emit outputs (terminal output, screenshots, logs) that can be observed and reacted to as event-like signals.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Cline exposes VS Code commands accessible via the command palette (e.g., open Cline, add a tool, invoke actions) which act as reusable user-triggered commands.","plainChildren":""},{"type":"item","level":1,"content":"The project also documents a CLI reference (docs.cline.bot/cline-cli/cli-reference) for command-line interactions tied to the extension's features.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Through the Model Context Protocol (MCP) Cline can add and integrate custom tools/services (\"add a tool\" flow) that act as specialized subagents for task-specific workflows.","plainChildren":""},{"type":"item","level":1,"content":"These MCP-backed tools can fetch external data (Jira, PagerDuty, cloud APIs), perform operations, and be invoked from plans, effectively functioning as domain-specific subagents.","plainChildren":""}]}]},{"type":"header","level":2,"content":"CustomModes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Toggleable rulesets (.clinerules) and Plan vs Act modes let teams define specialist behavior profiles and switch modes to tailor the assistant for different tasks or policies.","plainChildren":""},{"type":"item","level":1,"content":"Teams and projects can configure provider/backends (BYOK, local models) that change runtime behavior and constraints for the assistant.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"MCP provides a mechanism to bundle commands, tools and integrations: developers create MCP servers/tools and install them into Cline to extend functionality.","plainChildren":""},{"type":"item","level":1,"content":"The VS Code extension model plus community MCP servers enables packaging sets of capabilities (commands, hooks, tool endpoints) that behave like plugins.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Built-in checkpointing snapshots workspace state at steps and tool calls; users can compare changes, restore previous snapshots, or revert risky edits.","plainChildren":""},{"type":"item","level":1,"content":"File Timeline and standard Git history complement checkpointing for undo/rollback workflows.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SpecDrivenDevelopment","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Other","plainChildren":""},{"type":"item","level":1,"content":"Cline's approach centers on the Model Context Protocol (MCP), memory-bank files and checkpoint-driven iterations (plan → act → checkpoint → review). These mechanisms serve a spec-like governance model for automated changes and tool integrations rather than a named external SDD framework.","plainChildren":""}]}]}],"sourcePath":"cline.md"},{"type":"header","level":1,"content":"CodeLayer - https://github.com/humanlayer/humanlayer","children":[{"type":"text","content":"Open-source IDE to orchestrate AI coding agents built by HumanLayer."},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"codelayer-0.1.0-20251003-140552-nightly (2025-10-03)"}]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Editor","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"[4] Active community, frequent releases","plainChildren":""},{"type":"item","level":1,"content":"[5] Innovative AI-agent orchestration and productivity gains reported by users","plainChildren":""}]}]},{"type":"header","level":2,"content":"Repository","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"https://github.com/humanlayer/humanlayer","plainChildren":""}]}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Any","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"CodeLayer is an open-source, keyboard-first IDE and orchestration layer for AI coding agents (built on top of Claude Code). It focuses on \"context engineering\" and workflow orchestration so teams can use multiple AI agents in parallel to solve complex problems across large codebases. Key platform ideas include parallel Claude Code sessions (MULTICLAUDE), battle-tested agent workflows, worktree-aware git operations, and ergonomics for fast, keyboard-driven developer flows."}]},{"type":"header","level":2,"content":"BYOK","children":[]},{"type":"header","level":2,"content":"LocalOffline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Primarily designed to run with Claude Code / Anthropic-backed sessions rather than purely local model hosting]","plainChildren":""}]}]},{"type":"header","level":2,"content":"FreeTrial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"GitSupport","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Terminal","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Apache-2.0","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[]},{"type":"header","level":2,"content":"Notes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Focus: orchestration of AI agents rather than just code completion — useful for teams working on large, legacy, or complex systems.","plainChildren":""},{"type":"item","level":1,"content":"Innovative features: Advanced Context Engineering and MULTICLAUDE (parallel Claude Code sessions across worktrees and cloud workers).","plainChildren":""},{"type":"item","level":1,"content":"Community & activity: ~5.5k stars, ~409 forks (active contributions and many releases; rapid iteration cadence).","plainChildren":""},{"type":"item","level":1,"content":"Polyglot codebase: frontend/tooling in TypeScript, backend/perf in Go; other languages for utilities.","plainChildren":""},{"type":"item","level":1,"content":"Use cases: team-scale AI-assisted development, PR generation/augmentation, multi-agent workflows, productivity tooling for dev teams.","plainChildren":""},{"type":"item","level":1,"content":"Caveats: depends on Claude Code (Anthropic) for core model capabilities, so on-prem / fully local usage is limited unless adapted by contributors.","plainChildren":""},{"type":"item","level":1,"content":"License is permissive (Apache 2.0) — good for commercial adoption and modification.","plainChildren":""},{"type":"item","level":1,"content":"Repo contains legacy HumanLayer SDK and documentation for historical context and SDK features.","plainChildren":""}]}]},{"type":"header","level":2,"content":"ContextManagement","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"CodeLayer / HumanLayer provides multiple explicit context-management mechanisms: session-scoped context across Claude Code sessions, file and region pinning (attach files or file ranges to a session), worktree-aware context (each session can be bound to a git worktree/branch), context windows and prompt templates for engineered context snapshots, message/thread history preserved per session, and state objects that are carried through human approval flows and webhooks. These combine to enable deterministic context engineering and reproducible agent runs.","plainChildren":""}]}]},{"type":"header","level":2,"content":"DirectFileReferences","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"CodeLayer integrates with the repository and git worktrees so sessions can directly reference files, open diffs, and operate on file ranges. Sessions surface file metadata (path, revision, worktree) in prompts and diffs so agents and humans can operate on precise file references. The HumanLayer SDK also allows including file-like payloads in approvals and function calls so external systems can reconstruct the referenced files.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"HumanLayer exposes lifecycle and integration hooks via webhooks and SDK callbacks: function_call.* and human_contact.* events, agent message events, and agent_email.received (agent webhooks). These let external systems react to approval requests, completed function calls, agent launches, and other lifecycle events. The SDK also supports local callbacks/handlers to intercept or decorate tool calls (e.g., require approval before a side-effecting operation).","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"The product supports reusable, user-triggered commands in two forms: (1) a keyboard-driven command palette / keybindings inside the CodeLayer IDE for launching common actions, sessions, or agent flows; and (2) integrations with messaging channels (Slack/email) where HumanLayer can surface approval prompts or trigger agents via message-based interactions (including Slack workflows or command-like interactions).","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"CodeLayer is built for multi-agent orchestration: MULTICLAUDE enables running multiple Claude Code sessions in parallel (effectively specialized subagents) bound to separate worktrees or tasks. The HumanLayer SDK pattern also encourages defining specialized agent/tool functions (including \"human as a tool\") that act as subagents for task-specific workflows and human-in-the-loop approvals.","plainChildren":""}]}]},{"type":"header","level":2,"content":"CustomModes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Users can create specialist session modes by configuring models, prompt templates, and session settings (e.g., model type, temperature, tool access). The IDE and SDK permit different session types/workflows (review, refactor, PR authoring, exploratory), and CodeLayer's session-forking and template features let teams codify repeatable modes for specific developer tasks.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"The platform is extensible: CodeLayer is open-source and designed to be extended via configuration, model selection, and SDK integrations. HumanLayer's SDK and webhooks let teams bundle commands, agent behaviors, and approval hooks into higher-level integrations (e.g., repo automation, CI hooks, Slack routing). The repo and SDK patterns enable building custom integrations or plugins that orchestrate agents and human approvals.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Checkpoints are supported via git/worktree integration (explicit worktrees per session, diffs, and commits) plus session archiving and approval audit logs. Because CodeLayer operates alongside git, standard git workflows (commits, branches, resets) provide reversible checkpoints; HumanLayer also records approval histories and function-call traces for audit and rollback reasoning.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SpecDrivenDevelopment","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Other","plainChildren":""},{"type":"item","level":1,"content":"HumanLayer / CodeLayer does not advertise a named spec-driven development framework like Tessl or BMAD; instead it emphasizes \"context engineering\" and battle-tested multi-agent workflows. Teams typically codify workflows via session templates, prompt engineering artifacts, and SDK-driven approval specs rather than a formalized external SDD framework.","plainChildren":""}]}]}],"sourcePath":"codelayer.md"},{"type":"header","level":1,"content":"Continue - https://continue.dev","children":[{"type":"text","content":"Open-source AI coding assistant focused on developer control, model choice, and IDE/CLI integration."},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"v (2025-10-19)"}]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Editor","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"[4] Strong customization and model choice","plainChildren":""},{"type":"item","level":1,"content":"[4] Good IDE & CLI coverage (VS Code, JetBrains, terminal)","plainChildren":""},{"type":"item","level":1,"content":"[3] Hub & team features maturing (1.0 release)","plainChildren":""}]}]},{"type":"header","level":2,"content":"Repository","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"https://github.com/continuedev/continue","plainChildren":""}]}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Any","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Continue is built to be extensible via blocks, MCP integrations and a hub for sharing assistants.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"Continue is an open-source AI coding assistant and platform that brings AI capabilities into editors (VS Code, JetBrains), the terminal (CLI) and CI/CD workflows. It emphasizes developer control: choose models (cloud or local), customize prompts and agents, and run fully local/offline when required. The platform includes IDE extensions, a CLI (cn) with interactive and headless modes, and an optional Continue Hub for sharing and managing assistant building blocks."}]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"You can configure and use your own API keys and model endpoints, and switch between local/remote models.","plainChildren":""}]}]},{"type":"header","level":2,"content":"LocalOffline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Supports local model workflows (e.g. via Ollama/local LLMs) and headless/offline operation for air-gapped environments.","plainChildren":""}]}]},{"type":"header","level":2,"content":"FreeTrial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"A free/solo tier exists (open-source extensions + hub access for public/shared blocks). Paid team/enterprise tiers add governance and private deployment options.","plainChildren":""}]}]},{"type":"header","level":2,"content":"GitSupport","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Native integrations (MCP-style integrations) for GitHub and git workflows; automation via CLI for PR/comments/summaries.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Terminal","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"The `cn` CLI provides an interactive TUI and a headless mode for scripted and CI uses.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"The project is open-source and community contributions are actively encouraged.","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Apache-2.0","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Integrates with Model Context Protocols for adding context providers (GitHub, Jira, etc.) and usable via the hub.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Strengths:","plainChildren":""},{"type":"item","level":1,"content":"Model-agnostic: swap between OpenAI, Anthropic, local LLMs, etc.","plainChildren":""},{"type":"item","level":1,"content":"Full-stack integration: editor + terminal + CI/CD automation paths.","plainChildren":""},{"type":"item","level":1,"content":"Privacy-first options: private data planes & local-only operation available for enterprises.","plainChildren":""},{"type":"item","level":1,"content":"Extensible hub: shareable building blocks and verified partner integrations.","plainChildren":""},{"type":"item","level":1,"content":"Limitations & considerations:","plainChildren":""},{"type":"item","level":1,"content":"1.0 release stabilizes core features but some team/enterprise workflows continue to evolve.","plainChildren":""},{"type":"item","level":1,"content":"Running high-quality local models requires additional infrastructure (GPU/memory) and ops work.","plainChildren":""},{"type":"item","level":1,"content":"Use cases:","plainChildren":""},{"type":"item","level":1,"content":"Individual developers: in-editor autocomplete, chat, and edit-by-instruction.","plainChildren":""},{"type":"item","level":1,"content":"Teams: shared assistants, governance policies, and private deployments.","plainChildren":""},{"type":"item","level":1,"content":"CI/CD: automated refactors, batch code updates, and repository-level maintenance via headless agents.","plainChildren":""},{"type":"item","level":1,"content":"Competitive positioning:","plainChildren":""},{"type":"item","level":1,"content":"Competes with GitHub Copilot, Codeium, Cursor, and commercial offerings, but differentiates on openness, model choice, and privacy.","plainChildren":""},{"type":"item","level":1,"content":"Useful links:","plainChildren":""},{"type":"item","level":1,"content":"Official site / docs: https://continue.dev","plainChildren":""},{"type":"item","level":1,"content":"Hub: https://hub.continue.dev","plainChildren":""},{"type":"item","level":1,"content":"GitHub: https://github.com/continuedev/continue","plainChildren":""}]}]},{"type":"header","level":2,"content":"ContextManagement","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Methods for managing and updating context:","plainChildren":""},{"type":"item","level":1,"content":"Conversation-level context (chat state / memory) maintained by the agent across messages.","plainChildren":""},{"type":"item","level":1,"content":"Extensions and tools: enable/disable extensions (platform__manage_extensions) to change available capabilities at runtime.","plainChildren":""},{"type":"item","level":1,"content":"File edits: directly update repository files via developer__text_editor (view/insert/write/str_replace/undo_edit) to change canonical project context.","plainChildren":""},{"type":"item","level":1,"content":"Subagents / tasks: pass contextual parameters to dynamic_task__create_task and subagent__execute_task so specialized subagents operate with explicit context.","plainChildren":""},{"type":"item","level":1,"content":"Analysis tools: use developer__analyze and developer__shell to gather and refresh context (code structure, file contents) before making changes.","plainChildren":""},{"type":"item","level":1,"content":"Sources:","plainChildren":""},{"type":"item","level":1,"content":".tessl/framework/agents.md (project spec & workflow guidance)","plainChildren":""},{"type":"item","level":1,"content":"developer extension tool descriptions (developer__text_editor, developer__analyze, platform__manage_extensions)","plainChildren":""}]}]},{"type":"header","level":2,"content":"DirectFileReferences","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Files can be directly referenced by path in tool calls and task context:","plainChildren":""},{"type":"item","level":1,"content":"developer__text_editor accepts absolute or repo-relative paths for view/write/insert/str_replace operations.","plainChildren":""},{"type":"item","level":1,"content":"todo__read and todo__write read/write the TODO file contents.","plainChildren":""},{"type":"item","level":1,"content":"developer__analyze accepts a path to a directory or file to inspect.","plainChildren":""},{"type":"item","level":1,"content":"Shell commands can operate on files and the output can be read back into the conversation.","plainChildren":""},{"type":"item","level":1,"content":"Practical notes:","plainChildren":""},{"type":"item","level":1,"content":"When editing, use exact relative paths from the repo root (as used by the developer extension).","plainChildren":""},{"type":"item","level":1,"content":"developer__text_editor supports an undo_edit operation for safer iterations.","plainChildren":""},{"type":"item","level":1,"content":"Sources:","plainChildren":""},{"type":"item","level":1,"content":"Developer extension tool docs (developer__text_editor, developer__analyze, todo__read/todo__write)","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Lifecycle-like attachment points available:","plainChildren":""},{"type":"item","level":1,"content":"Scheduled jobs (platform__manage_schedule) provide lifecycle actions (create, run_now, pause, unpause, delete, inspect, sessions) that act like hooks for recurring automation.","plainChildren":""},{"type":"item","level":1,"content":"Subagent/task lifecycle: dynamic_task__create_task and subagent__execute_task expose start/finish semantics and can be monitored via their responses and session content (platform schedule sessions API).","plainChildren":""},{"type":"item","level":1,"content":"developer__text_editor undo_edit provides a simple edit-level rollback hook.","plainChildren":""},{"type":"item","level":1,"content":"Sources:","plainChildren":""},{"type":"item","level":1,"content":"platform__manage_schedule tool description","plainChildren":""},{"type":"item","level":1,"content":"dynamic_task__create_task and subagent__execute_task tool descriptions","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"The environment provides reusable slash commands that users can trigger from the CLI:","plainChildren":""},{"type":"item","level":1,"content":"/exit or /quit — Exit the session","plainChildren":""},{"type":"item","level":1,"content":"/t — Toggle between Light/Dark/Ansi themes","plainChildren":""},{"type":"item","level":1,"content":"/? or /help — Display help message","plainChildren":""},{"type":"item","level":1,"content":"Comments:","plainChildren":""},{"type":"item","level":1,"content":"These are small, user-facing commands; broader automation is implemented via the platform and developer tools rather than additional built-in slash commands.","plainChildren":""},{"type":"item","level":1,"content":"Sources:","plainChildren":""},{"type":"item","level":1,"content":"Session command list provided in the runtime instructions at the top of this environment","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Specialized subagents and task workflows are supported:","plainChildren":""},{"type":"item","level":1,"content":"Use dynamic_task__create_task to spawn tasks with custom instructions, extension scoping, and execution settings.","plainChildren":""},{"type":"item","level":1,"content":"Use subagent__execute_task to run tasks created by the dynamic task system; supports sequential or parallel execution modes.","plainChildren":""},{"type":"item","level":1,"content":"Subagents can be given explicit context and are intended for parallelizable or long-running subtasks.","plainChildren":""},{"type":"item","level":1,"content":"Sources:","plainChildren":""},{"type":"item","level":1,"content":"dynamic_task__create_task and subagent__execute_task tool descriptions","plainChildren":""}]}]},{"type":"header","level":2,"content":"CustomModes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Specialist modes can be created by combining extensions, execution settings, and curated prompts:","plainChildren":""},{"type":"item","level":1,"content":"Enable/disable specific extensions (platform__manage_extensions) to tailor available tools for the mode.","plainChildren":""},{"type":"item","level":1,"content":"Create dynamic tasks or scheduled recipes (platform__manage_schedule) that run with a specific configuration to emulate a mode.","plainChildren":""},{"type":"item","level":1,"content":"Use prompt engineering and subagent settings to constrain behavior (e.g., read-only auditing mode vs. active-editing mode).","plainChildren":""},{"type":"item","level":1,"content":"Sources:","plainChildren":""},{"type":"item","level":1,"content":"platform__manage_extensions, dynamic_task__create_task, platform__manage_schedule tool descriptions","plainChildren":""}]}]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Extension/recipe model allows bundling commands, agents and hooks:","plainChildren":""},{"type":"item","level":1,"content":"Extensions are enable/disable units (platform__manage_extensions) that change the agent's available toolset.","plainChildren":""},{"type":"item","level":1,"content":"Scheduled recipe jobs (platform__manage_schedule create) can package recurring workflows.","plainChildren":""},{"type":"item","level":1,"content":"dynamic_task__create_task tasks can be used as reusable, parameterized operations that behave like plugins when stored and invoked programmatically.","plainChildren":""},{"type":"item","level":1,"content":"Sources:","plainChildren":""},{"type":"item","level":1,"content":"platform__manage_extensions","plainChildren":""},{"type":"item","level":1,"content":"platform__manage_schedule","plainChildren":""},{"type":"item","level":1,"content":"dynamic_task__create_task","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Undo and recovery mechanisms:","plainChildren":""},{"type":"item","level":1,"content":"developer__text_editor undo_edit provides local edit rollback for the last text_editor operation.","plainChildren":""},{"type":"item","level":1,"content":"Git operations via developer__shell (git commit, git revert, git reset) can be used to create and restore checkpoints in repository history.","plainChildren":""},{"type":"item","level":1,"content":"When using todo__read/todo__write and plan files, maintain incremental commits to enable reverting high-level work.","plainChildren":""},{"type":"item","level":1,"content":"Sources:","plainChildren":""},{"type":"item","level":1,"content":"developer__text_editor tool description (undo_edit)","plainChildren":""},{"type":"item","level":1,"content":"developer__shell usage for git commands","plainChildren":""}]}]},{"type":"header","level":2,"content":"SpecDrivenDevelopment","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Tessl","plainChildren":""},{"type":"item","level":1,"content":"This project explicitly uses Tessl for Spec Driven Development. See .tessl/framework/agents.md and the project's Spec Driven Development documentation for detailed workflows and rules.","plainChildren":""},{"type":"item","level":1,"content":"Sources:","plainChildren":""},{"type":"item","level":1,"content":".tessl/framework/agents.md","plainChildren":""},{"type":"item","level":1,"content":"docs/spec-driven-development.md","plainChildren":""}]}]}],"sourcePath":"continue.md"},{"type":"header","level":1,"content":"DevoxxGenie - https://github.com/devoxx/DevoxxGenieIDEAPlugin","children":[{"type":"text","content":"An AI assistant plugin for IntelliJ IDEA that can use both local and cloud LLMs."},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"v0.x (initial releases 2024)"}]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Editor","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"[5] Strong support for local LLMs and RAG","plainChildren":""},{"type":"item","level":1,"content":"[4] Very useful for Java/IDEA users; UI and workflows continue improving","plainChildren":""}]}]},{"type":"header","level":2,"content":"Repository","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"https://github.com/devoxx/DevoxxGenieIDEAPlugin","plainChildren":""}]}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Java","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"DevoxxGenie is an IntelliJ IDEA plugin (100% Java-based) that provides an LLM-powered coding assistant inside the IDE. It was created by Stephan Janssen and focuses on flexibility: developers can connect cloud LLMs (OpenAI, Anthropic, Mistral, Google Gemini, etc.) or run models locally (Ollama, LMStudio, GPT4All, Llama.cpp, Exo and others). Key capabilities include Retrieval-Augmented Generation (RAG) for semantic code search, a project scanner, AST-aware context inclusion, multimodal drag-and-drop for images, streaming responses, chat history stored locally, and Model Context Protocol (MCP) integration."}]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"LocalOffline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Supports running local LLM backends (Ollama, GPT4All, Llama.cpp, LMStudio, etc.) and a fully-local RAG setup via Chroma DB + embeddings.","plainChildren":""}]}]},{"type":"header","level":2,"content":"FreeTrial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"GitSupport","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Terminal","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"MIT","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"RAG: Introduced in early releases (v0.4.0+). Uses local embeddings (e.g. Ollama + Nomic Text) and stores vectors in a local Chroma DB (often run via Docker) to provide semantic search over a project without sending source code to cloud providers.","plainChildren":""},{"type":"item","level":1,"content":"DEVOXXGENIE.md: The plugin can generate a DEVOXXGENIE.md project descriptor (via settings or the `/init` prompt) which is added to the system prompt to improve contextual responses.","plainChildren":""},{"type":"item","level":1,"content":"Multimodal: Drag-and-drop image support works with multimodal models (Google Gemini, Anthropic Claude, ChatGPT 4.x, LLaVA local models, etc.).","plainChildren":""},{"type":"item","level":1,"content":"Streaming: Responses stream token-by-token for an interactive feel.","plainChildren":""},{"type":"item","level":1,"content":"Cost Management: Includes a token cost estimator to preview input token costs when using cloud-based LLMs; remember output tokens also count toward billing.","plainChildren":""},{"type":"item","level":1,"content":"Requirements: Requires JDK 17+ and IntelliJ IDEA 2023.3.4+ (or compatible recent versions).","plainChildren":""},{"type":"item","level":1,"content":"Use cases: Code explanation, unit-test generation, code review/suggestions, natural-language code search, debugging with screenshots, and project-aware Q&A.","plainChildren":""},{"type":"item","level":1,"content":"Good fit for teams that need local/offline LLM execution or want flexible model selection inside IntelliJ.","plainChildren":""}]}]},{"type":"header","level":2,"content":"ContextManagement","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Project Scanner: include entire project, specific packages, or selected files for prompt context.","plainChildren":""},{"type":"item","level":1,"content":"DEVOXXGENIE.md: generate and maintain a project descriptor that is injected into the system prompt.","plainChildren":""},{"type":"item","level":1,"content":"RAG (Retrieval-Augmented Generation): local embeddings + Chroma DB for semantic retrieval of relevant code instead of sending entire codebase.","plainChildren":""},{"type":"item","level":1,"content":"Chat memory configuration: configurable message history length (default ~10) stored locally.","plainChildren":""},{"type":"item","level":1,"content":"Include/exclude patterns and .gitignore awareness: filter files and directories with wildcards and respect .gitignore to avoid sending irrelevant or sensitive files.","plainChildren":""},{"type":"item","level":1,"content":"AST-aware context: automatic inclusion of parent class and related symbols to improve code-understanding prompts.","plainChildren":""}]}]},{"type":"header","level":2,"content":"DirectFileReferences","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Drag-and-drop files or images directly into the input field to attach them to the prompt.","plainChildren":""},{"type":"item","level":1,"content":"Explicitly add open files, specific files or directories via the Project Scanner or the UI to include them in context.","plainChildren":""},{"type":"item","level":1,"content":"Copy/paste code snippets into the prompt; responses preserve syntax highlighting and can reference exact file paths when applicable.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"The plugin does not expose a documented lifecycle hook system for third‑party attachments; integrations are done via MCP servers or by extending the plugin source (JetBrains plugin APIs).","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Supports prompt-style slash commands from the input field (notably `/init` to create a DEVOXXGENIE.md project descriptor).","plainChildren":""},{"type":"item","level":1,"content":"Commands and shortcuts are entered directly in the chat input and can be combined with context selections (files, images, project scanner options).","plainChildren":""},{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"MCP (Model Context Protocol) integration: connect to external MCP servers which act as specialized agents/subagents for tool execution and richer workflows.","plainChildren":""},{"type":"item","level":1,"content":"RAG and embedding pipelines function as retrieval subagents (local embedding provider + Chroma DB) to augment generation.","plainChildren":""},{"type":"item","level":1,"content":"The architecture (Langchain4J + Java) enables integration with external model servers and agent-like workflows.","plainChildren":""}]}]},{"type":"header","level":2,"content":"CustomModes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"DEVOXXGENIE.md + saved prompts: create project-specific prompt templates and system prompts to tailor the assistant's behaviour.","plainChildren":""},{"type":"item","level":1,"content":"Per-model settings: choose different LLM providers, model parameters, memory sizes and token cost constraints to create tailored working modes.","plainChildren":""},{"type":"item","level":1,"content":"UI options (RAG on/off, project scanner scope, AST context inclusion) act as mode configuration switches.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"DevoxxGenie itself is a JetBrains plugin and can be extended by modifying its source or contributing upstream; it supports connectors to different model backends (local or cloud) and MCP servers.","plainChildren":""},{"type":"item","level":1,"content":"Prompts, MCP connectors and embedding/RAG pipelines are the primary extensibility points exposed to users and integrators.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"While DevoxxGenie doesn't provide a built-in \"checkpoint/undo\" system for code edits, typical IDE workflows provide recovery: IntelliJ Local History, VCS (Git) commits and rollbacks, and saved chat history to re-run decisions.","plainChildren":""},{"type":"item","level":1,"content":"Chat history stored locally allows re-opening prior conversations and re-applying previously used prompts/contexts.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SpecDrivenDevelopment","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Other","plainChildren":""},{"type":"item","level":1,"content":"No specific spec-driven development framework is used by DevoxxGenie upstream; development follows standard JetBrains plugin practices (Java, Langchain4J) and conventional release/versioning workflows.","plainChildren":""}]}]}],"sourcePath":"devoxx-genie.md"},{"type":"header","level":1,"content":"EasyCode - https://easycode.ai","children":[{"type":"text","content":"A local-first, agentic IDE focused on taking projects from idea to production with an opinionated Next.js + Supabase stack."},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"v1.0 (2025-10-19)"}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"[4] Strong for solo builders and founders who want to ship quickly","plainChildren":""},{"type":"item","level":1,"content":"[3] Opinionated stack limits applicability for teams with existing, different stacks","plainChildren":""},{"type":"item","level":1,"content":"Tradeoff: deep integration and \"finish-first\" workflow vs flexibility","plainChildren":""}]}]},{"type":"header","level":2,"content":"Repository","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"TypeScript","plainChildren":""},{"type":"item","level":1,"content":"JavaScript","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"VS Code extension available (integrates chat, slash commands, inline quick edits)","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"EasyCode is a local-first AI-powered development environment that emphasizes finishing applications rather than only generating prototypes. It pairs an opinionated full-stack (Next.js + Supabase) with agentic features: project-wide context management, a planning workflow, file-by-file implementation suggestions, an integrated visual/data-flow debugger, and one-click deployment tooling. The product runs primarily on the user machine (local-first), keeping code and data under developer control and reducing cloud-credit surprises."}]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"LocalOffline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Local-first architecture; code and context are kept on the developer's machine rather than sent to third-party servers for model training or storage","plainChildren":""}]}]},{"type":"header","level":2,"content":"FreeTrial","children":[]},{"type":"header","level":2,"content":"GitSupport","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Integrates with local repositories and provides VS Code extension workflows","plainChildren":""}]}]},{"type":"header","level":2,"content":"Terminal","children":[]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Proprietary","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[]},{"type":"header","level":2,"content":"Notes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Target users: non-technical founders, indie hackers, solo developers and consultants who need predictable time-to-product and prefer a guided, integrated workflow.","plainChildren":""},{"type":"item","level":1,"content":"Strengths: strong guidance from planning → implementation → debug → deploy, generous local credit model, tight integration for the chosen stack, agentic debugging and human developer credits for blockers.","plainChildren":""},{"type":"item","level":1,"content":"Limitations: locked-in stack (Next.js + Supabase), limited team collaboration features compared with cloud IDEs, no public OSS repo or permissive license available as of this note.","plainChildren":""},{"type":"item","level":1,"content":"Use-case fit: excellent for new projects or MVPs that can accept the opinionated stack; less suitable for migrating large existing codebases using other technologies.","plainChildren":""}]}]}],"sourcePath":"easycodeai.md"},{"type":"header","level":1,"content":"Firebase - https://firebase.google.com","children":[{"type":"text","content":"A cloud-first, AI-powered development environment from Google that combines prototyping agents, a full IDE, and managed Firebase backend provisioning to accelerate building web and mobile apps from prototype to production."},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"v0.1 (2025-04-22 preview)"}]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Editor","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"[5] Rapid prototyping and automated backend provisioning","plainChildren":""},{"type":"item","level":1,"content":"[4] Deep Gemini integration for code assistance and UI generation","plainChildren":""},{"type":"item","level":1,"content":"[3] Vendor lock-in concerns; not open-source","plainChildren":""}]}]},{"type":"header","level":2,"content":"Repository","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"JavaScript","plainChildren":""},{"type":"item","level":1,"content":"TypeScript","plainChildren":""},{"type":"item","level":1,"content":"Go","plainChildren":""},{"type":"item","level":1,"content":"Java","plainChildren":""},{"type":"item","level":1,"content":"Other","plainChildren":""},{"type":"item","level":1,"content":"Support for other backend languages via templates and runtime options (examples include Go and Java in templates)","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Integrations: Figma import (Builder.io plugin), GitHub/GitLab/Bitbucket import, template gallery","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"Firebase Studio is an integrated, agentic development workspace built to speed application development by combining an App Prototyping agent (natural-language and image-driven app creation), a CodeOSS-based IDE (VS Code-compatible experience), and automatic Firebase service provisioning (Authentication, Firestore, Hosting, etc.). It uses Google's Gemini models to power conversational prototyping, contextual code assistance, and in-IDE help. Typical workflows include \"describe an app in plain language → prototype generated app → switch to code to refine → one-click deploy to Firebase Hosting.\" The service is optimized for rapid MVPs, full-stack AI apps, and teams that want managed infrastructure with minimal setup."}]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Gemini API keys and AI resources are provisioned as part of the workspace flow; explicit BYOK for model keys is not a first-class, user-driven workflow in the initial preview.","plainChildren":""}]}]},{"type":"header","level":2,"content":"LocalOffline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Firebase Studio is a cloud-hosted workspace; the environment and AI features run in Google-managed infrastructure.","plainChildren":""}]}]},{"type":"header","level":2,"content":"FreeTrial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Available during preview; typical Firebase usage quotas and billing apply once services are provisioned beyond free tier limits.","plainChildren":""}]}]},{"type":"header","level":2,"content":"GitSupport","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Import from GitHub, GitLab, Bitbucket; code workspace exposes repo integration and basic Git operations.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Terminal","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Full coding workspace includes terminal access for builds, package managers, and CLI workflows.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Proprietary","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"App Prototyping agent: Create Next.js web app prototypes from natural language, images, or Figma designs. The agent can add auth and database patterns automatically when requested.","plainChildren":""},{"type":"item","level":1,"content":"Automated backend provisioning: Prompts that specify data/auth needs result in recommended App Blueprints (Firestore, Firebase Auth, Hosting) and one-click provisioning when publishing.","plainChildren":""},{"type":"item","level":1,"content":"Gemini integration: The environment is powered by Gemini models (Gemini in Firebase, upgraded to Gemini 2.5 during 2025 previews), providing code completion, refactor suggestions, test generation, and conversational guidance contextualized to the workspace.","plainChildren":""},{"type":"item","level":1,"content":"Templates & import: Large template gallery (dozens of starter apps) plus the ability to import existing projects or compressed archives from source control.","plainChildren":""},{"type":"item","level":1,"content":"Deployment: One-click publish to Firebase App Hosting with preview URLs and QR codes for quick device testing; handles builds and CDN deployment.","plainChildren":""},{"type":"item","level":1,"content":"Collaboration: Shareable workspaces and real-time collaboration for teams; supports rapid feedback cycles.","plainChildren":""},{"type":"item","level":1,"content":"Privacy & security considerations: Workspaces may provision AI resources and API keys automatically; teams should evaluate data residency and key management requirements (enterprise BYOK and compliance workflows may be limited in the initial preview).","plainChildren":""},{"type":"item","level":1,"content":"Best fit: Fast prototyping, startups and teams building Firebase-backed web/mobile apps, AI-enhanced frontends, and teams that prefer managed backend provisioning and tight Firebase integration.","plainChildren":""},{"type":"item","level":1,"content":"Limitations: Cloud-only, proprietary, potential vendor lock-in to Firebase/GCP services; enterprises with strict BYOK or on-prem requirements should validate security/compliance.","plainChildren":""}]}]},{"type":"header","level":2,"content":"ContextManagement","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Chat- and workspace-centered context: Gemini-in-Firebase chat + the Code OSS workspace provide the active context (open files, project settings, App Blueprints, Genkit configuration, and provisioned Firebase resources). Methods to update context include editing files in the IDE, committing to the integrated Git repo, changing project/settings in the workspace, re-running prototype prompts, and interacting with the in-IDE chat (Gemini) which reads workspace files to inform responses. There is no public programmatic \"context API\" documented in the preview — context is primarily managed via the workspace and chat.","plainChildren":""}]}]},{"type":"header","level":2,"content":"DirectFileReferences","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Files can be directly referenced and accessed inside the workspace: open files in the Code OSS-based IDE, import repositories (GitHub/GitLab/Bitbucket), upload archives, and use plugins (e.g., Builder.io Figma import) to bring design files into the project. Gemini and the App Prototyping agent access the workspace files to provide contextual code generation and edits. There is no public external file-reference API documented beyond the workspace and VCS integration.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[]},{"type":"header","level":2,"content":"SlashCommands","children":[]},{"type":"header","level":2,"content":"Subagents","children":[]},{"type":"header","level":2,"content":"CustomModes","children":[]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Firebase Studio exposes integrations and plugin-like extensions in the preview (examples: Builder.io Figma import, Genkit integration, template gallery, and Git provider integrations). These are enabled/configured through the workspace UI (import plugin/integration or select templates) and by provisioning AI resources (Gemini/Genkit) into the workspace; developer-facing documentation for authoring third-party plugins or bundling commands/agents/hooks is not publicly detailed in the preview documentation.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Undo and rollback are handled primarily via standard version control (Git) integration: commits, branches, and repo history allow reverting agent-made changes. Workspace share URLs, preview deployments and published app versions provide additional reference points, but there is no documented first-class \"agent checkpoint\" system independent of source control in the preview.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SpecDrivenDevelopment","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Other","plainChildren":""},{"type":"item","level":1,"content":"Firebase Studio does not advertise a named spec-driven development framework in public previews; its development patterns are centered on templates, App Blueprints, and the App Prototyping agent rather than a formal SDD framework like Tessl or SpecKit.","plainChildren":""}]}]}],"sourcePath":"firebase_studio.md"},{"type":"header","level":1,"content":"From021 - https://from021.io","children":[{"type":"text","content":"An AI-powered product definition platform that helps teams convert ideas into implementation-ready product specifications, wireframes, and developer-facing artifacts."},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"v (2025-10-19)"}]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Editor","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"[4] Strong for product managers and founders who need fast, structured PRDs","plainChildren":""},{"type":"item","level":1,"content":"[3] May be less suitable for engineering-first teams that require deep technical customization","plainChildren":""}]}]},{"type":"header","level":2,"content":"Repository","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"From021 is a cloud SaaS product that automates the product-definition workflow: vision & goals, MVP prioritization, product requirements, user journeys and wireframes, implementation guidance, and AI prompt / ticket export. It generates Product Requirement Documents (PRDs), suggested tech stacks, data models, API endpoints, and exportable tickets or AI prompts to integrate with development tools and project management systems.\n\nThe platform emphasizes a structured process (uses MoSCoW prioritization) and targets agencies, product managers, and founders who want to compress weeks of planning into minutes. Outputs are aimed at making handoff to engineering faster and reducing ambiguity during execution."}]},{"type":"header","level":2,"content":"BYOK","children":[]},{"type":"header","level":2,"content":"LocalOffline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"From021 is a hosted web service (cloud SaaS)","plainChildren":""}]}]},{"type":"header","level":2,"content":"FreeTrial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"The product advertises a free trial that does not require a credit card","plainChildren":""}]}]},{"type":"header","level":2,"content":"GitSupport","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Terminal","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Proprietary","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Integrations / exports: the product advertises exports to project management and developer tools (examples mentioned: Trello, JIRA, v0, Lovable, Cursor) so it can fit into existing workflows for ticketing and prototype generation.","plainChildren":""},{"type":"item","level":1,"content":"Output types: PRDs, user flows, wireframes, tech stack recommendations, implementation guidelines, AI prompts for code assistants.","plainChildren":""},{"type":"item","level":1,"content":"Target users: Agencies (client scoping & handoff), Product Managers (fast PRD creation), Founders (rapid product definition and prioritization).","plainChildren":""},{"type":"item","level":1,"content":"Pricing & privacy: commercial SaaS; BYOK / self-hosting options are not publicly documented (leave as unknown). Users with strict data residency or security needs should contact From021 for details.","plainChildren":""},{"type":"item","level":1,"content":"Competitors / context: positioned near other AI-assisted product tools (e.g., ChatPRD) but focuses on structured customization and exportable developer artifacts rather than fully automatic summaries.","plainChildren":""}]}]},{"type":"header","level":2,"content":"ContextManagement","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Step-by-step product-definition UI (vision & goals, MVP prioritization, PRD generation) that captures and updates product context.","plainChildren":""},{"type":"item","level":1,"content":"MoSCoW prioritization controls to manage feature importance within the project context.","plainChildren":""},{"type":"item","level":1,"content":"Editable PRDs, user journeys and wireframes in the web UI; outputs can be revised and re-generated.","plainChildren":""},{"type":"item","level":1,"content":"Export capabilities (PRDs, user stories, AI prompts, tickets) to external tools to persist context outside the platform.","plainChildren":""}]}]},{"type":"header","level":2,"content":"DirectFileReferences","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"No public feature documented for directly referencing repository files or attaching arbitrary external files as \"live\" references in the product context; inputs are primarily web-form/text-driven with export connectors.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"No public developer hooks or lifecycle event attachments are documented for From021.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"There is no documentation of slash-commands or user-triggered reusable commands; interactions are performed through the web UI.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"From021 does not document the ability to define specialized AI subagents or task-specific agent workflows; AI appears to be built-in to the product flows.","plainChildren":""}]}]},{"type":"header","level":2,"content":"CustomModes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"There is no public support documented for creating persistent custom \"modes\" that change agent behavior; users can adjust inputs and settings per project to influence generated outputs.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"From021 does not expose a plugin system for bundling commands/agents/hooks. Integrations are provided as export connectors (examples: Trello, JIRA, v0, Lovable, Cursor) rather than a plugin marketplace or SDK.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"No explicit checkpoint/undo/versioning mechanism is documented publicly; inquire with the vendor for data retention, revision history, or rollback capabilities.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SpecDrivenDevelopment","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Other","plainChildren":""},{"type":"item","level":1,"content":"Not applicable — From021 is a SaaS product focused on product definition and does not advertise using the listed spec-driven development frameworks.","plainChildren":""}]}]}],"sourcePath":"from021.md"},{"type":"header","level":1,"content":"GitHub Copilot - https://github.com/features/copilot","children":[{"type":"text","content":"AI pair-programmer and code assistant integrated across popular IDEs and GitHub."},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"vN/A (2025-10-19)"}]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Editor","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"[5] Strong, context-aware code completion and multi-file assistance","plainChildren":""},{"type":"item","level":1,"content":"[4] Mature IDE integrations and collaboration features","plainChildren":""},{"type":"item","level":1,"content":"[3] Proprietary service with privacy/enterprise trade-offs","plainChildren":""}]}]},{"type":"header","level":2,"content":"Repository","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"JavaScript","plainChildren":""},{"type":"item","level":1,"content":"TypeScript","plainChildren":""},{"type":"item","level":1,"content":"Python","plainChildren":""},{"type":"item","level":1,"content":"Go","plainChildren":""},{"type":"item","level":1,"content":"Java","plainChildren":""},{"type":"item","level":1,"content":"C#","plainChildren":""},{"type":"item","level":1,"content":"Ruby","plainChildren":""},{"type":"item","level":1,"content":"PHP","plainChildren":""},{"type":"item","level":1,"content":"C/C++","plainChildren":""},{"type":"item","level":1,"content":"Swift","plainChildren":""},{"type":"item","level":1,"content":"Rust","plainChildren":""},{"type":"item","level":1,"content":"SQL","plainChildren":""},{"type":"item","level":1,"content":"Shell","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Editor and IDE integrations (VS Code, Visual Studio, JetBrains, Xcode, Vim/Neovim, Eclipse), GitHub Marketplace extensions and CLI/Terminal integrations","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"GitHub Copilot is a cloud-hosted AI coding assistant from GitHub (Microsoft) that provides inline code completions, whole-function and multi-file suggestions, a conversational Copilot Chat interface, and autonomous coding agent features. It leverages multiple large models (including GPT-family and Claude models) to offer natural-language-to-code generation, contextual completions based on repository contents, and developer workflows such as generating pull requests, writing tests, and refactoring.\n\nCopilot is positioned as an AI pair programmer: suggestions appear as you type in supported editors, and Copilot Chat enables interactive Q&A and multi-file code transformations. Enterprise offerings add organization-level controls, knowledge bases for chat context, and workflow features that let Copilot act on GitHub issues and propose pull requests."}]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"No public, general-purpose \"bring your own key\" option for the cloud-hosted Copilot service. Enterprise plans provide data controls and policy management but do not expose a documented BYOK for model keys as of 2025-10-19.","plainChildren":""}]}]},{"type":"header","level":2,"content":"LocalOffline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Any offline/local-only model hosting is not offered for the standard Copilot cloud service. Some organizations use enterprise features to limit data sharing; however, Copilot itself runs in GitHub/Microsoft cloud.","plainChildren":""}]}]},{"type":"header","level":2,"content":"FreeTrial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Copilot has free tiers (e.g., Copilot Free for qualifying users) and trial/paid plans (Pro/Business/Enterprise) with different capabilities.","plainChildren":""}]}]},{"type":"header","level":2,"content":"GitSupport","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Integrates with GitHub workflows: PR description generation, PR creation by the Copilot agent, and issue-to-PR workflows in enterprise features.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Terminal","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Copilot Chat is available in supported terminals (Windows Terminal Canary, GitHub CLI integrations) and can be used from the command line in supported environments.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Proprietary","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Copilot provides model selection and multi-model access (e.g., GPT-4o, Claude variants) in certain plans; model availability varies by tier.","plainChildren":""},{"type":"item","level":1,"content":"Copilot Chat supports multi-file edits from a single prompt and can incorporate repository context and organization knowledge bases in Enterprise.","plainChildren":""},{"type":"item","level":1,"content":"The Copilot autonomous coding agent can be assigned GitHub issues and produce pull requests for review; this increases automation but requires careful review for correctness and security.","plainChildren":""},{"type":"item","level":1,"content":"Privacy/data usage: Enterprise tiers offer stronger controls and indemnity options; evaluate data residency and IP policies if using Copilot on proprietary codebases.","plainChildren":""}]}]},{"type":"header","level":2,"content":"ContextManagement","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Methods available for managing and updating context:","plainChildren":""},{"type":"item","level":1,"content":"Editor-provided references: client.file (active file content) and client.selection (current selection) passed when the Copilot Editor Context permission is granted.","plainChildren":""},{"type":"item","level":1,"content":"GitHub references: github.current-url and github.repository to ground chat requests to a repository or page context.","plainChildren":""},{"type":"item","level":1,"content":"Copilot Spaces and Knowledge Bases: curated collections of Markdown/docs that can be attached as grounding context for Copilot Chat in organization/enterprise settings.","plainChildren":""},{"type":"item","level":1,"content":"Model Context Protocol (MCP) / extension APIs: allow explicit programmatic injection of context and integration with external systems.","plainChildren":""},{"type":"item","level":1,"content":"Chat variables and explicit file references: using chat commands/variables (e.g., #file, #editors or file anchors) to reference or include specific files in a conversation.","plainChildren":""},{"type":"item","level":1,"content":"User-controlled exclusions: context exclusion lists and per-file opt-outs to prevent sharing sensitive files.","plainChildren":""}]}]},{"type":"header","level":2,"content":"DirectFileReferences","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"How files can be directly referenced in context:","plainChildren":""},{"type":"item","level":1,"content":"client.file provides the full text of the active editor file to extensions when permitted.","plainChildren":""},{"type":"item","level":1,"content":"Chat-specific file anchors and #file-like references can be used to point Copilot Chat at particular repository files for multi-file edits and analysis.","plainChildren":""},{"type":"item","level":1,"content":"Copilot Chat in IDEs can operate on multiple open files (multi-file edits) when the chat prompt references them; in the web UI, github.current-url links a chat to the current page/PR/file view.","plainChildren":""},{"type":"item","level":1,"content":"Repository-level knowledge bases let you include specific documentation files as searchable context the assistant can consult.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Are there any lifecycle events for the agent generated that can be attached to:","plainChildren":""},{"type":"item","level":1,"content":"Agents/skillsets provide extension points for request handling and response generation (agent lifecycle handling for incoming chat requests, response formatting, and function-call style interactions).","plainChildren":""},{"type":"item","level":1,"content":"GitHub Apps and Copilot Extensions integrate via the Copilot Extensibility APIs which expose request/context arrival and response phases; developers implement handlers to process and respond to chat/agent requests.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Is there support for re-usable commands that can be manually triggered by the user:","plainChildren":""},{"type":"item","level":1,"content":"Copilot Chat supports conversational triggers and structured commands/inputs in the chat UI; extensions/agents can expose command-like actions that users invoke from the chat or editor context.","plainChildren":""},{"type":"item","level":1,"content":"In IDE integrations, extension commands (command palette, context menu, chat commands) let users trigger predefined behaviors or workflows.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Is it possible to define specialized AI subagents for task-specific workflows ? If so, explain how.","plainChildren":""},{"type":"item","level":1,"content":"Copilot's extensibility distinguishes lightweight skillsets (task-focused handlers) from full agents, enabling developers to build specialized capabilities that act as subagents for constrained workflows.","plainChildren":""},{"type":"item","level":1,"content":"Skillsets encapsulate routing, prompt templates, function evaluation and response shaping for focused tasks; agents provide custom logic and broader orchestration and may call other services or models.","plainChildren":""}]}]},{"type":"header","level":2,"content":"CustomModes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Can the user create specialist modes that enable you to tailor the chat experience for specific tasks.","plainChildren":""},{"type":"item","level":1,"content":"Custom instructions, persistent prompt files, Copilot Spaces, and workspace-level knowledge bases allow teams to define tailored modes and default context for chat sessions (for example: testing mode, security-aware suggestions, or style-guides).","plainChildren":""}]}]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Is there a method of bundling together commands, agents and hooks ? If so, explain how'","plainChildren":""},{"type":"item","level":1,"content":"Copilot Extensions / GitHub Apps act as bundles that package skillsets/agents, commands, and integration hooks; they are installed as apps or extensions in IDEs and on GitHub and include permission configuration (including Copilot Editor Context).","plainChildren":""},{"type":"item","level":1,"content":"Organization-managed Copilot Spaces and knowledge bases let admins distribute curated plugins/contexts across teams.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Is it possible to undo actions taken by the agent by using checkpoints or if autocommitted to git, reversing the history ?","plainChildren":""},{"type":"item","level":1,"content":"Editor undo and local history: any automatic edits suggested by Copilot must be accepted by the user in the editor, and typical editor undo/redo and local history remain available.","plainChildren":""},{"type":"item","level":1,"content":"PR/commit workflow: when Copilot creates commits or PRs (agent-driven), standard git workflows allow reverting commits, closing or reverting PRs, and using branch-based reviews to avoid autocommit risk.","plainChildren":""},{"type":"item","level":1,"content":"Preview and review steps: Copilot Chat multi-file edits are surfaced for review before commit in supported integrations; enterprise policies can enforce review gates.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SpecDrivenDevelopment","children":[]}],"sourcePath":"github_copilot.md"},{"type":"header","level":1,"content":"GitHub Copilot Workspace - https://github.com/features/copilot","children":[{"type":"text","content":"A cloud-hosted, agentic development environment experiment from GitHub (technical preview). Copilot Workspace combined multi-agent planning, editable specifications, and automated implementation to help developers plan, write, test and iterate on code using natural language prompts."},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"Archived v0.1 (2025-05-30)"}]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Editor","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"[4] Innovative workflow and planning UX (spec + editable plan)","plainChildren":""},{"type":"item","level":1,"content":"[3] Integration with Codespaces and VS Code is useful","plainChildren":""},{"type":"item","level":1,"content":"[2] Limited availability — technical preview ended / not generally available","plainChildren":""}]}]},{"type":"header","level":2,"content":"Repository","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Any","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"GitHub Copilot Workspace was an experimental \"agentic\" IDE hosted by GitHub that let developers describe tasks in natural language, review an auto-generated specification and a concrete editable plan, and then apply changes across a repository. It used multiple specialized agents (planning, brainstorm, repair, follow-up) to propose implementations, run tests, and iteratively fix failures. The environment integrated with Codespaces, provided an integrated terminal, and offered a VS Code extension to continue sessions locally."}]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"LocalOffline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"All processing was cloud-hosted on GitHub's infrastructure; no documented offline/local model execution.","plainChildren":""}]}]},{"type":"header","level":2,"content":"FreeTrial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"GitSupport","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Terminal","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Proprietary","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Technical preview was sunset on 2025-05-30; many concepts (agent workflows, follow-ups, plan-driven edits) were later folded into broader GitHub Copilot features and Copilot Spaces.","plainChildren":""},{"type":"item","level":1,"content":"Known features: editable two-stage steering (specification + plan), brainstorm agent, repair agent for failing tests, follow-up system to fix dependent files across large repositories, integrated terminal with secure port forwarding, Codespaces integration, VS Code extension for session continuity.","plainChildren":""},{"type":"item","level":1,"content":"Model: GitHub reported experimenting with multiple models and selected GPT-4o for the Workspace preview; subsequent Copilot features support multiple model backends.","plainChildren":""},{"type":"item","level":1,"content":"Limitations: no documented BYOK or local/offline execution; service was cloud-only and proprietary. Pricing and GA plans were not published for the technical preview prior to sunset.","plainChildren":""},{"type":"item","level":1,"content":"Useful when comparing AI coding environments for enterprise adoption: strong UX for large-scope edits and planning, but lack of on-prem/local model options and the preview's discontinuation reduce viability for locked-down environments.","plainChildren":""}]}]},{"type":"header","level":2,"content":"ContextManagement","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Editable two-stage steering: Specification (current vs desired state) and concrete Plan that can be edited to change downstream code generation.","plainChildren":""},{"type":"item","level":1,"content":"Session context versioning and history: Copilot Workspace tracked the session and allowed regeneration after spec/plan edits.","plainChildren":""},{"type":"item","level":1,"content":"Regenerate/undo workflow: Edits to spec or plan trigger regeneration of downstream steps; generated diffs are editable and can be reverted or revised.","plainChildren":""},{"type":"item","level":1,"content":"Codespaces / VS Code continuity: Context (file references, diffs, session) could be opened in a Codespace or VS Code extension to continue working locally.","plainChildren":""}]}]},{"type":"header","level":2,"content":"DirectFileReferences","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Plans explicitly list repository files that will be created, modified, or deleted; generated outputs are presented as file-level diffs.","plainChildren":""},{"type":"item","level":1,"content":"Generated diffs and the plan allow direct navigation to and editing of specific files by path within the workspace UI (and via Codespaces/VS Code).","plainChildren":""},{"type":"item","level":1,"content":"The system operates on the repository itself, so file paths in the plan map directly to repo files and can be applied as commits/PRs.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"No public lifecycle hook API was documented for attaching custom code to Workspace events. Automation and sequencing were handled internally by built-in agents and the follow-up system rather than user-attachable hooks.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Interaction model was natural-language driven (tasks, specs, plans) rather than a slash-command interface documented for user-triggered commands.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Copilot Workspace used specialized built-in agents (e.g., brainstorm agent, plan agent, repair agent, follow-up) to handle different stages of the Task→Spec→Plan→Code workflow.","plainChildren":""},{"type":"item","level":1,"content":"These agents coordinated to propose specs, generate concrete plans, produce code diffs, run tests, and attempt repairs when failures occurred.","plainChildren":""},{"type":"item","level":1,"content":"There was no public surface documented for users to author or register their own custom agents; the agent set and behavior were provided by the Workspace service.","plainChildren":""}]}]},{"type":"header","level":2,"content":"CustomModes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"There was no documented feature for users to create specialist modes that change the overall chat/agent behavior beyond editing specs/plans and choosing when to regenerate.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"While the Workspace integrated with developer tooling (Codespaces, VS Code extension) and could open sessions in those environments, there was no documented plugin system for bundling custom commands, agents, and hooks inside Workspace itself.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Workspace tracked session state and maintained a history of edits; generated changes were presented as diffs and could be revised, undone, or committed as PRs.","plainChildren":""},{"type":"item","level":1,"content":"While not marketed as a \"checkpoint\" API, the combination of session versioning, editable specs/plans, and Git-backed commits/PRs provided checkpoint-like rollback and recovery mechanisms.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SpecDrivenDevelopment","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Other","plainChildren":""},{"type":"item","level":1,"content":"GitHub Copilot Workspace implemented its own spec-driven workflow (Task → Spec → Plan → Code). This built-in approach functions as an internal spec-driven development method distinct from the listed frameworks; it produces editable specifications and concrete file-level plans which are then applied as code diffs and PRs.","plainChildren":""}]}]}],"sourcePath":"github_copilot_workspace.md"},{"type":"header","level":1,"content":"Google AI Studio - https://aistudio.google.com","children":[{"type":"text","content":"Browser-based development environment from Google for prototyping and experimenting with Gemini models and multimodal generative AI"},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"(2025-10-19)"}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"[5] Excellent for rapid prototyping and multimodal experimentation with Gemini family","plainChildren":""},{"type":"item","level":1,"content":"[4] Strong integration path to Vertex AI for production deployments","plainChildren":""},{"type":"item","level":1,"content":"[3] Limited transparency on enterprise pricing / BYOK / offline hosting","plainChildren":""}]}]},{"type":"header","level":2,"content":"Repository","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Web UI","plainChildren":""},{"type":"item","level":1,"content":"Python","plainChildren":""},{"type":"item","level":1,"content":"Node.js","plainChildren":""},{"type":"item","level":1,"content":"Swift","plainChildren":""},{"type":"item","level":1,"content":"Kotlin","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Integrates with Vertex AI and supports function-calling/tool integrations","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"Google AI Studio is a web-based IDE and playground from Google that exposes the Gemini family of models (text, multimodal/vision, and Live/voice-enabled variants) through a unified, multimodal workflow. It aims to let developers, researchers and product teams prototype interactions that combine text, images, voice, screen-sharing and external context (URLs, Maps grounding) and then export working client/server snippets to accelerate production integration. The environment is primarily browser-hosted and intended for quick iteration, A/B style model comparisons, and as a stepping stone into Google Cloud's Vertex AI for enterprise scale."}]},{"type":"header","level":2,"content":"BYOK","children":[]},{"type":"header","level":2,"content":"LocalOffline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Studio is a cloud-hosted web application; there is no known supported offline/self-hosted distribution of the Studio UI or Gemini models.","plainChildren":""}]}]},{"type":"header","level":2,"content":"FreeTrial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Core prototyping and experimentation features of AI Studio are available without charge.","plainChildren":""}]}]},{"type":"header","level":2,"content":"GitSupport","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Studio offers code export but does not act as a git host. Exported snippets are intended to be copied into developer repositories.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Terminal","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Interaction is through the web UI (Playground, chat, multimodal inputs) and exported code; no integrated shell/terminal is advertised.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Studio and Gemini are proprietary Google services; there are no public source repositories for the hosted Studio environment.","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Proprietary","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[]},{"type":"header","level":2,"content":"Notes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Multimodal strength: first-class support for text, images, voice, camera and screen-sharing makes Studio a powerful prototyping environment for rich interactions.","plainChildren":""},{"type":"item","level":1,"content":"Live and device-specific features: some Live/voice/screen features are available only on supported mobile devices (newer Android flagships) and via Chrome on desktop; capabilities and stability can vary by platform.","plainChildren":""},{"type":"item","level":1,"content":"Code export: Studio generates runnable SDK snippets (Python, Node.js, mobile SDKs) to help move experiments to production quickly.","plainChildren":""},{"type":"item","level":1,"content":"Vertex AI path: clear migration/upgrade path to Vertex AI for organizations that need enterprise controls, data governance and scalable deployment.","plainChildren":""},{"type":"item","level":1,"content":"Pricing & enterprise details: core Studio use is free for prototyping, but Google documents and community reports indicate advanced grounding or high-volume production may incur costs—validate with Google Cloud sales or the Vertex AI pricing pages for production plans.","plainChildren":""},{"type":"item","level":1,"content":"BYOK / data residency: no public documentation found indicating BYOK or self-hosted Gemini; expect data to be processed in Google Cloud unless an enterprise contract or Vertex AI offering provides specific guarantees.","plainChildren":""}]}]}],"sourcePath":"googleaistudio.md"},{"type":"header","level":1,"content":"GPT Pilot - https://github.com/Pythagora-io/gpt-pilot/","children":[{"type":"text","content":"Open-source/Source-available AI developer companion that generates full-stack applications using multi-agent LLM workflows."},{"type":"header","level":2,"content":"Version","children":[]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Editor","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"[4] Strong at end-to-end prototype and feature generation","plainChildren":""},{"type":"item","level":1,"content":"[3] Requires active human oversight for correctness, design and edge cases","plainChildren":""}]}]},{"type":"header","level":2,"content":"Repository","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"https://github.com/Pythagora-io/gpt-pilot","plainChildren":""}]}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Python","plainChildren":""},{"type":"item","level":1,"content":"JavaScript","plainChildren":""},{"type":"item","level":1,"content":"TypeScript","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"GPT Pilot (by Pythagora) is a source-available AI developer assistant designed to automate large parts of the software development lifecycle. It uses a multi-agent workflow to: clarify requirements, design architecture, break work into tasks, generate code, run tests, and iterate with human reviews. It targets generating production-ready features (not just snippets) and integrates with developer tooling like a VS Code extension and a CLI."}]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Supports multiple LLM providers (OpenAI, Anthropic/Claude, Groq) via configuration — effectively a vendor-agnostic/BYOK model.","plainChildren":""}]}]},{"type":"header","level":2,"content":"LocalOffline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Can be run locally or inside Docker; configurable to use local LLM endpoints or self-hosted inference where supported.","plainChildren":""}]}]},{"type":"header","level":2,"content":"FreeTrial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"The open/source-available GPT Pilot codebase is free to run; Pythagora also offers a commercial Pythagora Pro product with paid features.","plainChildren":""}]}]},{"type":"header","level":2,"content":"GitSupport","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Terminal","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"CLI-driven project creation and workspace management are supported.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"The project is distributed under a Functional Source License (FSL) / \"Fair Source\" style license (source-available) rather than an OSI-approved open-source license.","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"FSL","plainChildren":""},{"type":"item","level":1,"content":"Functional Source License (FSL) / Fair Source (source-available, not MIT/Apache/GPL)","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"BYOK: Configure your own API keys (OpenAI, Anthropic, Groq, etc.) in config.json or environment variables; no vendor lock-in by default.","plainChildren":""},{"type":"item","level":1,"content":"Local & Docker: Official examples and docker-compose are provided; workspace defaults to a local folder and Postgres is supported for persistence.","plainChildren":""},{"type":"item","level":1,"content":"Requirements: Python 3.9+; example-config.json / .env templates provided in the repo.","plainChildren":""},{"type":"item","level":1,"content":"Workflow: Generates programmatic unit/integration tests as it develops features; asks for human review at checkpoints (\"95% automated / 5% human oversight\" principle).","plainChildren":""},{"type":"item","level":1,"content":"License implications: FSL is source-available with usage restrictions (often includes time-limited commercial restrictions or non-compete terms). This is different from permissive OSS licenses (MIT/Apache) or copyleft licenses (GPL); review the FSL text before using in commercial or competitive products.","plainChildren":""},{"type":"item","level":1,"content":"Integration: Has a Pythagora VS Code extension for integrated usage; also usable purely via CLI for automation.","plainChildren":""},{"type":"item","level":1,"content":"Limitations: Not fully autonomous — human guidance required for ambiguous requirements, architectural decisions and final QA. Cost exposure comes from your chosen LLM provider when using BYOK.","plainChildren":""},{"type":"item","level":1,"content":"Useful links:","plainChildren":""},{"type":"item","level":1,"content":"Repository: https://github.com/Pythagora-io/gpt-pilot","plainChildren":""},{"type":"item","level":1,"content":"Project site: https://www.pythagora.ai","plainChildren":""},{"type":"item","level":1,"content":"PyPI package: https://pypi.org/project/gpt-pilot/","plainChildren":""}]}]},{"type":"header","level":2,"content":"ContextManagement","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"GPT Pilot uses a multi-part context management strategy designed for large codebases: context-rewinding, recursive conversations, and TDD-driven checkpoints. It maintains a project file/folder tree with human-readable descriptions and generates pseudocode summaries for functions and files. Before implementing a step it: (1) presents the workspace tree + descriptions so the LLM can narrow relevant files, (2) supplies pseudocode summaries for candidate files so the LLM can identify relevant functions, then (3) fetches the actual code for the selected files into the implementation conversation. This selective fetching + pseudocode approach keeps the LLM prompt size bounded while preserving the necessary local context.","plainChildren":""}]}]},{"type":"header","level":2,"content":"DirectFileReferences","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Files and folders are represented in the workspace with descriptions; GPT Pilot can present a project tree and selectively fetch files into the active conversation. It also stores generated code in a workspace (CLI-driven) and integrates with Git, VS Code, and a local workspace so the system can operate on real files, commit changes, and run tests. The pseudocode+file-description layer lets the system reference files at function-level granularity before pulling full source.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[]},{"type":"header","level":2,"content":"SlashCommands","children":[]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"GPT Pilot implements a multi-agent/subagent architecture with specialized roles (Product Owner, Specification Writer, Software Architect, DevOps, Tech Lead, Developer, Code Monkey, Reviewer, Troubleshooter, Debugger, Technical Writer). These agents are orchestrated to break down requirements into tasks/steps, generate pseudocode, implement code, run tests, and request human review. The agent behaviours and orchestration are implemented in the codebase and can be inspected/extended by modifying the project's agent orchestration/configuration (i.e., adding or changing agent logic requires code/config edits).","plainChildren":""}]}]},{"type":"header","level":2,"content":"CustomModes","children":[]},{"type":"header","level":2,"content":"Plugins","children":[]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"The workflow explicitly includes human review checkpoints and automated test generation at two granularities (unit tests after steps, integration/e2e tests after tasks). Work is persisted in a workspace with Git support and a CLI/VS Code integration, enabling manual rollbacks or inspection. The system's \"95% automated / 5% human oversight\" model makes checkpoints first-class (stop-and-review before progressing).","plainChildren":""}]}]},{"type":"header","level":2,"content":"SpecDrivenDevelopment","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Other","plainChildren":""},{"type":"item","level":1,"content":"GPT Pilot does not advertise one of the named spec frameworks; instead it uses a task/spec decomposition model combined with TDD and multi-agent roles (product-owner/spec-writer → architect → task decomposition → implementation steps + programmatic test goals). The workflow is spec-like (clear programmatic goals, user_review_goals, and auto-test generation) but implemented within the project-specific agent/task framework rather than a published spec-driven framework listed above.","plainChildren":""}]}]}],"sourcePath":"gpt-pilot.md"},{"type":"header","level":1,"content":"JetBrains AI Assistant - https://www.jetbrains.com/ai/","children":[{"type":"text","content":"A deeply integrated AI assistant built into JetBrains IDEs (IntelliJ IDEA, PyCharm, WebStorm, CLion, DataGrip, etc.) that combines JetBrains' code understanding with selectable large language models to provide contextual chat, completions, refactorings, test and doc generation, and multi-file edits."},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"v2025.2 (2025-08-25)"}]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Editor","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"[5] Deep IDE integration and strong project-aware context","plainChildren":""},{"type":"item","level":1,"content":"[4] Multiple model/provider support and improving local/offline options","plainChildren":""},{"type":"item","level":1,"content":"[3] Feature parity between cloud and local models is limited","plainChildren":""}]}]},{"type":"header","level":2,"content":"Repository","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Java","plainChildren":""},{"type":"item","level":1,"content":"Kotlin","plainChildren":""},{"type":"item","level":1,"content":"JavaScript","plainChildren":""},{"type":"item","level":1,"content":"TypeScript","plainChildren":""},{"type":"item","level":1,"content":"Python","plainChildren":""},{"type":"item","level":1,"content":"C/C++","plainChildren":""},{"type":"item","level":1,"content":"Go","plainChildren":""},{"type":"item","level":1,"content":"Rust","plainChildren":""},{"type":"item","level":1,"content":"PHP","plainChildren":""},{"type":"item","level":1,"content":"Ruby","plainChildren":""},{"type":"item","level":1,"content":"C#","plainChildren":""},{"type":"item","level":1,"content":"SQL","plainChildren":""},{"type":"item","level":1,"content":"Shell","plainChildren":""},{"type":"item","level":1,"content":"Other","plainChildren":""},{"type":"item","level":1,"content":"YAML, JSON, Markdown, Text","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"IDE plugin surface for different JetBrains products","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"JetBrains AI Assistant embeds AI workflows directly inside JetBrains IDEs and leverages the IDEs' static-analysis capabilities to provide context-aware help: inline completions, whole-function generation, conversational chat that understands the open project, multi-file diffs, automated test and documentation generation, commit message suggestions, and debugging assistance. JetBrains provides a model picker and automatic model selection to balance cost, latency and accuracy. The product emphasizes workflow continuity — minimizing context switching away from the IDE — and supports both cloud providers and local model servers for privacy-sensitive environments."}]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"LocalOffline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Local model/server support (Ollama, LM Studio and any server compatible with OpenAI-style endpoints) enables offline workflows and on-device completions. JetBrains added expanded local model support in 2025, including connections to llama.cpp/LiteLLM-style hosts and code-tuned models (Qwen, DeepSeek-Coder, Mellum variants).","plainChildren":""}]}]},{"type":"header","level":2,"content":"FreeTrial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Core inline completions and many local workflows are free. Cloud-based features may use provider credits; JetBrains changed to a credit/quota model in 2025 for cloud usage visibility.","plainChildren":""}]}]},{"type":"header","level":2,"content":"GitSupport","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Assistive features for commit messages, PR descriptions, refactor-aware changes, and multi-file edits that can be staged/reviewed in the IDE.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Terminal","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"AI Assistant is provided inside JetBrains IDE UIs; there is no native terminal-only assistant shipped as a separate TUI (some IDE features can be used alongside integrated terminals).","plainChildren":""}]}]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Proprietary","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Strong advantage: combines JetBrains' long investment in static analysis with LLMs to produce higher-quality, context-aware suggestions and safer refactorings.","plainChildren":""},{"type":"item","level":1,"content":"Local vs cloud trade-offs: local model support enables private/offline use but may provide a reduced feature set compared to cloud models (e.g., some agent workflows and advanced reasoning may be cloud-only).","plainChildren":""},{"type":"item","level":1,"content":"Enterprise: AI Pro has been bundled into some JetBrains subscription tiers (All Products Pack, dotUltimate) since 2025.1 — check licensing for org-wide access and admin quota controls.","plainChildren":""},{"type":"item","level":1,"content":"Model & quota transparency: 2025 updates introduced clearer credit accounting and model cost visibility to help teams manage cloud usage.","plainChildren":""},{"type":"item","level":1,"content":"Good fit for teams already standardized on JetBrains IDEs or for users needing strong on-device privacy controls via local model hosting.","plainChildren":""}]}]},{"type":"header","level":2,"content":"ContextManagement","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"JetBrains AI Assistant supports project-aware context management. In \"Codebase\" mode it automatically gathers context from the open project (open files, project tree, symbols, recent commits, and selected files). Users can also manually add context items (files, folders, images, symbols, commits) via the \"Add context\" UI in the chat, or reference specific files/symbols using in-chat @ references. Automatic context gathering can be disabled to restrict the assistant's view.","plainChildren":""}]}]},{"type":"header","level":2,"content":"DirectFileReferences","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"The assistant can reference and include specific files and folders as explicit context for a chat or agent action. Users may add files/folders to the context panel or mention them with @-style references in chat to ensure the model uses that file content. In agent mode, multi-file edits are previewed and can be applied to the working tree.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"No public, documented lifecycle \"hooks\" specific to the AI Assistant (e.g., webhooks or plugin lifecycle events tied to assistant actions) are exposed in JetBrains' public AI Assistant documentation. However, JetBrains IDEs provide a plugin SDK with listener and extension points for IDE events, so plugin authors can hook into IDE lifecycle events and potentially integrate with or extend AI workflows via the general plugin API.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"There is no widely-documented, global \"slash command\" mechanic inside JetBrains AI Chat analogous to chat-platform slash commands. Users invoke functionality through the chat UI, mode selection (Chat vs Agent), context buttons, and model/option menus rather than typed slash commands. Some quick actions (e.g., apply suggestion, accept completion, run tests) are exposed as UI controls rather than textual slash commands.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"JetBrains provides an autonomous \"agent\" capability (often referenced as Junie or Agent mode) that can plan and execute multistep tasks: run tests or terminal commands, make multi-file edits, and report progress. This functions as a specialized subagent for complex workflows where the assistant performs a sequence of actions with user review points.","plainChildren":""}]}]},{"type":"header","level":2,"content":"CustomModes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"The product exposes distinct interaction modes (Chat mode and Agent/Autonomous mode) and allows selecting different model providers and configurations (cloud vs local models). However, there is no publicly-documented facility for end-users to create arbitrary custom \"modes\" beyond the provided chat/agent workflows and model/configuration choices.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"JetBrains IDEs support a rich plugin ecosystem. AI Assistant itself is delivered as IDE-integrated functionality and can interoperate with other plugins. Plugin authors can use the IntelliJ Platform plugin SDK to extend IDE behavior, integrate model endpoints, or build complementary tooling that works alongside the AI Assistant.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"The assistant supports review-before-apply for generated edits (preview diffs). Users can accept or reject changes. Additionally, JetBrains IDEs provide VCS integration (Git) and Local History, enabling undo/revert of applied changes even if the assistant makes edits. These mechanisms together act as checkpoints for recovery.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SpecDrivenDevelopment","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Other","plainChildren":""},{"type":"item","level":1,"content":"None specific: JetBrains AI Assistant is not tied to a named spec-driven development framework in public documentation. It integrates with IDE workflows rather than prescribing a particular spec-driven development methodology.","plainChildren":""}]}]}],"sourcePath":"jetbrains_ai_assistant.md"},{"type":"header","level":1,"content":"Jolt - https://www.usejolt.ai","children":[{"type":"text","content":"AI assistant for making multi-file, large-codebase changes and code understanding."},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"(2025-10-19)"}]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Editor","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"[4] Strong for large, production codebases with multi-file edits and deep context","plainChildren":""}]}]},{"type":"header","level":2,"content":"Repository","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"TypeScript","plainChildren":""},{"type":"item","level":1,"content":"JavaScript","plainChildren":""},{"type":"item","level":1,"content":"Python","plainChildren":""},{"type":"item","level":1,"content":"Go","plainChildren":""},{"type":"item","level":1,"content":"Ruby","plainChildren":""},{"type":"item","level":1,"content":"Java","plainChildren":""},{"type":"item","level":1,"content":"Kotlin","plainChildren":""},{"type":"item","level":1,"content":"Scala","plainChildren":""},{"type":"item","level":1,"content":"C# / .NET","plainChildren":""},{"type":"item","level":1,"content":"HTML/CSS","plainChildren":""},{"type":"item","level":1,"content":"GraphQL","plainChildren":""},{"type":"item","level":1,"content":"Rust","plainChildren":""},{"type":"item","level":1,"content":"PHP","plainChildren":""},{"type":"item","level":1,"content":"Other","plainChildren":""},{"type":"item","level":1,"content":"Protocol Buffers","plainChildren":""},{"type":"item","level":1,"content":"Markdown / MDX","plainChildren":""},{"type":"item","level":1,"content":"SCSS / LESS","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Integrates with IDEs (VS Code, Cursor), web app and desktop client; supports multi-repo context and external LLMs","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"Jolt is a commercial AI coding assistant designed for large production codebases (100K+ lines). It emphasizes global \"HyperContext\" awareness of an entire codebase so users can ask questions, make changes, and apply multi-file edits without manually selecting context files. Jolt can generate implementation plans, create coherent multi-file patches, locate root causes for bugs from logs, and help with documentation and refactors across big repositories."}]},{"type":"header","level":2,"content":"BYOK","children":[]},{"type":"header","level":2,"content":"LocalOffline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Jolt operates as a cloud service with IDE integrations; offline/local-only usage is not advertised.","plainChildren":""}]}]},{"type":"header","level":2,"content":"FreeTrial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Commercial product with demos / trials and enterprise sales channels.","plainChildren":""}]}]},{"type":"header","level":2,"content":"GitSupport","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Can produce git patches and integrate with repositories; IDE extensions apply changes directly]","plainChildren":""}]}]},{"type":"header","level":2,"content":"Terminal","children":[]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Proprietary","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[]},{"type":"header","level":2,"content":"Notes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Core differentiator: \"HyperContext\" — Jolt maintains awareness of the whole codebase to reliably surface relevant files and produce consistent multi-file edits.","plainChildren":""},{"type":"item","level":1,"content":"Integrations: Web app, desktop app, and IDE extensions (notably VS Code and Cursor).","plainChildren":""},{"type":"item","level":1,"content":"Models & backends: Uses a mix of LLM providers (publicly referenced: Google Gemini, Anthropic, OpenAI) for generation and search.","plainChildren":""},{"type":"item","level":1,"content":"Security & compliance: Marketed for enterprise use and claims SOC 2 Type II compliance for handling sensitive codebases.","plainChildren":""},{"type":"item","level":1,"content":"Target audience: Engineering teams working on large, legacy or multi-repo production systems where single-file assistants struggle.","plainChildren":""},{"type":"item","level":1,"content":"Common workflows: Chat-based edits for smaller changes, editable implementation plans for complex multi-file work, and automatic context discovery across repos and dependencies.","plainChildren":""},{"type":"item","level":1,"content":"Useful links:","plainChildren":""},{"type":"item","level":1,"content":"Main site: https://www.usejolt.ai","plainChildren":""},{"type":"item","level":1,"content":"Docs / support: https://docs.usejolt.ai","plainChildren":""}]}]},{"type":"header","level":2,"content":"ContextManagement","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"HyperContext: Jolt's primary method is an automatic, global \"HyperContext\" index that discovers and maintains context across entire repositories (multi-repo support) so users do not need to manually select files. It runs in the web app and IDE extensions and keeps awareness of local, unsaved/changed files when used via IDE plugins.","plainChildren":""},{"type":"item","level":1,"content":"Automatic context discovery: Jolt identifies relevant files for a task (callsites, tests, configs, module boundaries) and surfaces them in chat and in the UI.","plainChildren":""},{"type":"item","level":1,"content":"Scope controls: In IDEs and the web app users can narrow workspace/repo scope (open folders, repo selection) so HyperContext focuses on a subset of files rather than the whole enterprise index.","plainChildren":""},{"type":"item","level":1,"content":"Use cases: code comprehension, multi-file feature work, cross-file refactors, root-cause analysis from logs.","plainChildren":""}]}]},{"type":"header","level":2,"content":"DirectFileReferences","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Jolt can reference specific files and produce direct multi-file edits and git-style patches. Files are referenced in several ways:","plainChildren":""},{"type":"item","level":1,"content":"Automatic selection: HyperContext locates and highlights relevant files for a given request.","plainChildren":""},{"type":"item","level":1,"content":"Explicit selection in IDE extensions: users can open/pin files or select ranges to anchor changes.","plainChildren":""},{"type":"item","level":1,"content":"Chat references: users may refer to file paths or paste snippets in chat to anchor edits.","plainChildren":""},{"type":"item","level":1,"content":"Export/patch: edits can be exported or applied as patches (or applied directly via IDE integration) so changes map back to repository files.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"CustomModes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"No public documentation of built-in checkpoint/undo features. Jolt supports exporting patches and integrates with git/IDE workflows, so rollbacks are typically handled via VCS (branches, commits) or IDE undo rather than an internal checkpoint system.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SpecDrivenDevelopment","children":[]}],"sourcePath":"jolt.md"},{"type":"header","level":1,"content":"Kilo Code - https://github.com/Kilo-Org/kilocode","children":[{"type":"text","content":"Open-source AI coding assistant / VS Code extension"},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"(2025-10-19)"}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"[4] Strong open-source AI coding assistant with broad model support and automation features","plainChildren":""},{"type":"item","level":1,"content":"[3] Some UI/issue rough edges reported; model consistency and cost management need attention","plainChildren":""},{"type":"item","level":1,"content":"note: active community -> frequent updates","plainChildren":""}]}]},{"type":"header","level":2,"content":"Repository","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"https://github.com/Kilo-Org/kilocode","plainChildren":""}]}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Any","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"MCP (Model Context Protocol) Server Marketplace for custom tools and integrations","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"Kilo Code is an open-source AI coding assistant implemented primarily as a Visual Studio Code extension. It combines natural-language code generation, multi-mode workflows (Architect, Coder, Debugger), and task automation to help developers plan, implement, and debug code within the editor. Kilo Code emphasizes context-awareness (project-level memory and indexing), extensibility via an MCP marketplace, and multi-model support so teams can choose models that match their needs for cost, latency, and privacy."}]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"supports connecting your own model/provider credentials when desired","plainChildren":""}]}]},{"type":"header","level":2,"content":"LocalOffline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"can be used with local model runtimes such as Ollama / LM Studio for offline or on-prem usage","plainChildren":""}]}]},{"type":"header","level":2,"content":"FreeTrial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"new users get onboarding credits via the platform (also can operate with your own keys)","plainChildren":""}]}]},{"type":"header","level":2,"content":"GitSupport","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"deep Git/GitHub integration patterns for generating commit messages, searching codebase, and automating repo tasks","plainChildren":""}]}]},{"type":"header","level":2,"content":"Terminal","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"incorporates terminal/CLI execution capabilities (inherited from Cline-style tooling) for running commands and automations","plainChildren":""}]}]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"source available on GitHub, community contributions encouraged","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"MIT","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"supports MCP Server Marketplace (JSON-based tool integrations / extensions)","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Memory Bank: per-project persistent memory (stored in project files like .kilocode/rules/memory-bank/) that helps the assistant remember project-specific details and reduces repeated context prompts.","plainChildren":""},{"type":"item","level":1,"content":"Multi-mode design: Architect mode (planning & scaffolding), Coder mode (implementation), Debugger mode (investigation & fixes). Custom modes are supported for specialized workflows.","plainChildren":""},{"type":"item","level":1,"content":"Model Flexibility: Connects to many LLM providers (Claude, Gemini, OpenAI models, and local LMs). The platform can optionally provide credits to new users and also supports direct purchase of tokens at provider prices.","plainChildren":""},{"type":"item","level":1,"content":"Automation & Orchestration: Automates repetitive tasks such as refactors, dependency updates, test runs, and repository-wide edits with user approval. Also includes browser automation in some flows.","plainChildren":""},{"type":"item","level":1,"content":"Installation: Available on the Visual Studio Marketplace; can also be built and installed from source (.vsix). Development mode supports live reloading via F5 in VS Code.","plainChildren":""},{"type":"item","level":1,"content":"Strengths: Open-source, highly extensible (MCP), strong context-awareness and project memory, multi-model support including offline options.","plainChildren":""}]}]}],"sourcePath":"kilocode.md"},{"type":"header","level":1,"content":"Marblism - https://marblism.ai","children":[{"type":"text","content":"AI platform offering role-specific \"AI Employees\" for business automation and an AI app builder that generates full‑stack React/Node projects."},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"v (2025-10-19)"}]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Editor","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"[4] Strong for SMBs, solopreneurs and rapid prototyping","plainChildren":""},{"type":"item","level":1,"content":"[3] Generated code often needs manual hardening for production","plainChildren":""}]}]},{"type":"header","level":2,"content":"Repository","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"JavaScript","plainChildren":""},{"type":"item","level":1,"content":"TypeScript","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"Marblism provides two complementary offerings: (1) a suite of role-specific \"AI Employees\" (Eva, Penny, Sonny, Stan, Cara, Linda) that autonomously handle business tasks such as inbox/calendar triage, SEO blog writing, social scheduling, lead generation/outreach, customer support, and basic legal document review; and (2) an AI app builder that scaffolds full‑stack React + Node applications (DB schema, backend endpoints, front-end pages, auth, basic integrations) from prompts. The platform focuses on fast onboarding and autonomous operation for non-technical founders and small teams."}]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"LocalOffline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"FreeTrial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"GitSupport","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Generates/clones GitHub repositories for created apps","plainChildren":""}]}]},{"type":"header","level":2,"content":"Terminal","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Proprietary","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Primary value: replaces or augments routine human work for small teams (email, content, social, outreach, support) and accelerates prototyping for web apps.","plainChildren":""},{"type":"item","level":1,"content":"Notable AI Employees: Eva (assistant/inbox & calendar), Penny (SEO/blog), Sonny (social media), Stan (sales outreach), Cara (support), Linda (legal review).","plainChildren":""},{"type":"item","level":1,"content":"App builder features: creates DB schemas, backend APIs, front-end pages, authentication (JWT/Google), S3 uploads, mail integration; targeted at React + Node stacks.","plainChildren":""},{"type":"item","level":1,"content":"Pricing: positioned affordably (examples cited $39/month for unlimited AI Employees tasks); also offers tiered app-builder plans / free tier for limited use.","plainChildren":""},{"type":"item","level":1,"content":"Strengths: very fast prototyping, simple onboarding (<30 minutes), GitHub repo output, useful for MVPs and solo founders.","plainChildren":""},{"type":"item","level":1,"content":"Limitations: not enterprise-grade (compliance, on-premises), limited tech stack (React/Node), generated code usually needs manual review/hardening for production, documentation/support primarily community/Discord.","plainChildren":""}]}]},{"type":"header","level":2,"content":"ContextManagement","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Marblism uses role-specific \"AI Employees\" (e.g., Eva, Penny, Sonny) that retain task- and role-level context for ongoing autonomous workflows. Context is also supplied and updated via connected accounts and integrations (email/calendar, GitHub, S3, mail) and through app-builder prompts and project settings during onboarding and app scaffolding. Public documentation does not detail the exact persistence model or memory API exposed to end users.","plainChildren":""}]}]},{"type":"header","level":2,"content":"DirectFileReferences","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Files can be referenced indirectly by the platform when the app builder generates or clones GitHub repositories: generated project files and assets are written to a repo that users can inspect and pull. The platform also supports uploads/attachments (e.g., S3 uploads) and integrates with GitHub which enables direct file access via repository links. There is no public documentation of a generic file-browse API for arbitrary external files beyond these integrations.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Integrations (GitHub repository creation/push, mail integrations, S3 uploads, and external account connections) imply event-driven interactions and integration endpoints that can function like hooks for automation. The product surface indicates output/actions (repo push, deployed app artifacts) that external systems can react to. There is no explicit public reference to a user-facing \"webhooks management\" UI or exhaustive lifecycle hook API in the available product notes.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"The platform exposes reusable role-driven actions via its AI Employees (pre-built role behaviours that can be triggered to perform tasks like inbox triage, social scheduling, outreach). While not literally described as \"slash commands,\" these role actions act as repeatable, triggerable automation primitives in the product. There is no public mention of a chat-style slash-command syntax for end users.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Marblism's \"AI Employees\" are functionally specialized subagents tailored to distinct business roles (e.g., inbox/calendar assistant, SEO/blog writer, sales outreach, customer support). Users pick and configure these agents for task-specific workflows; the app builder similarly scaffolds role-specific modules and endpoints for generated apps. The platform therefore supports the concept of specialized subagents, though details about exposing developer-level subagent creation or a public SDK are not documented.","plainChildren":""}]}]},{"type":"header","level":2,"content":"CustomModes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Users can customize how the AI Employees operate via onboarding choices, role selection, and prompt/configuration templates used by the app builder. This allows creation of specialist operational modes (e.g., a Penny configuration for SEO-focused output versus a Stan configuration for sales outreach). There is no public documentation describing an exposed \"custom mode\" editor or marketplace; customization appears to be driven through role settings and prompt inputs.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Generated code and projects are pushed to GitHub repositories, which provides standard version-control checkpoints (commits, branches, revert). Because the platform writes to Git repos, users can undo or revert generated changes via normal Git workflows. There is no widely advertised separate \"checkpoint/restore\" feature beyond standard VCS usage in public product notes.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SpecDrivenDevelopment","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Other","plainChildren":""},{"type":"item","level":1,"content":"Marblism does not publicly advertise adherence to a named spec-driven development methodology from the list above. Its product model centers on role templates, prompt-driven scaffolding and generated repositories rather than an explicit spec-driven framework like Tessl.","plainChildren":""}]}]}],"sourcePath":"marblism.md"},{"type":"header","level":1,"content":"MarsX - https://marsx.dev","children":[{"type":"text","content":"A development platform that blends AI, no-code/low-code and traditional pro-code to accelerate building web & mobile apps using a micro-app architecture."},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"v (2024)"}]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Editor","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"[4] Rapid app composition and strong modular approach","plainChildren":""},{"type":"item","level":1,"content":"[4] Active open-source presence but ecosystem maturity varies by microapp","plainChildren":""}]}]},{"type":"header","level":2,"content":"Repository","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"https://github.com/MarsX-dev/devhunt","plainChildren":""}]}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"JavaScript","plainChildren":""},{"type":"item","level":1,"content":"TypeScript","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"MarsX is an open-source development platform and marketplace that combines AI assistance, no-code visual tooling, and traditional coding through a \"Micro-App\" architecture. Micro-apps are self-contained modules (UI, backend logic, DB schema, admin panels) that can be composed to build full applications quickly. The platform emphasizes rapid prototyping, reuse via a Micro AppStore, and an AI-driven workflow that tunes models per micro-app to suggest implementations and accelerate developer productivity."}]},{"type":"header","level":2,"content":"BYOK","children":[]},{"type":"header","level":2,"content":"LocalOffline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"MarsX is primarily a cloud platform with a web-based IDE and Micro AppStore.","plainChildren":""}]}]},{"type":"header","level":2,"content":"FreeTrial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"MarsX offers a usable free plan and the core Mars engine is available as open-source.]","plainChildren":""}]}]},{"type":"header","level":2,"content":"GitSupport","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Terminal","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Cloud IDE typically exposes developer tooling; advanced users can work with code directly.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"MIT","plainChildren":""},{"type":"item","level":1,"content":"Core engine: MIT (varies by individual micro-app)","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[]},{"type":"header","level":2,"content":"Notes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Core strengths: dramatic reduction in boilerplate (claims up to ~90% less code), modular micro-app composition, and an AI-assisted workflow that learns from micro-app usage.","plainChildren":""},{"type":"item","level":1,"content":"Marketplace model: micro-apps are contributed by third-party developers and may be free or premium; this enables rapid assembly but introduces variability in quality and licensing.","plainChildren":""},{"type":"item","level":1,"content":"Ideal for startups, rapid prototypes, and teams that want to combine visual editing with direct code access.","plainChildren":""},{"type":"item","level":1,"content":"Considerations: reliance on the MarsX ecosystem for micro-apps can create lock-in for large projects; evaluate individual micro-app licenses and security posture for production use.","plainChildren":""},{"type":"item","level":1,"content":"Usefull links:","plainChildren":""},{"type":"item","level":1,"content":"https://marsx.dev/","plainChildren":""},{"type":"item","level":1,"content":"https://github.com/MarsX-dev","plainChildren":""},{"type":"item","level":1,"content":"https://github.com/MarsX-dev/devhunt","plainChildren":""}]}]},{"type":"header","level":2,"content":"ContextManagement","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"MarsX uses a micro-app abstraction to limit and manage AI context: each Micro-App encapsulates UI, backend logic, DB schema and has its own AI model/fine-tuning lifecycle so the AI is given only the Micro‑App’s surface instead of an entire monolithic codebase.","plainChildren":""},{"type":"item","level":1,"content":"Per-Micro-App model fine-tuning and usage aggregation: models are refined from Micro‑App usage and telemetry so suggestions and completions are contextually scoped to the Micro‑App’s domain.","plainChildren":""},{"type":"item","level":1,"content":"Project-level context in the cloud IDE: the workspace exposes a project structure and component metadata (Micro‑App manifest/config) that the platform and AI use to resolve dependencies and orchestration between Micro‑Apps.","plainChildren":""},{"type":"item","level":1,"content":"AI Landing Page Builder and natural-language-driven UI generation: developers provide high-level prompts; the AI synthesizes UI/components using Micro‑App primitives, effectively managing prompt/context to the relevant Micro‑Apps.","plainChildren":""}]}]},{"type":"header","level":2,"content":"DirectFileReferences","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"The platform exposes Git and direct code editing in the cloud IDE, enabling developers to modify microapp source files directly within the workspace.","plainChildren":""},{"type":"item","level":1,"content":"Micro‑Apps are packaged with manifests and source files that can be inspected and edited in the IDE or via Git, allowing direct references to files (components, API handlers, schema files) within a project.","plainChildren":""},{"type":"item","level":1,"content":"When exporting or integrating externally, microapps can be published to the marketplace or pulled as packages; code can also be cloned via Git for local work.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Unknown","plainChildren":""},{"type":"item","level":1,"content":"The public materials describe microapps, AI models and marketplace mechanics, but do not provide an explicit list of lifecycle hooks or plugin hooks exposed to developers (e.g., pre-deploy, post-install hooks). Detailed hook semantics are not available in public docs discovered.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Unknown","plainChildren":""},{"type":"item","level":1,"content":"There's no explicit public documentation indicating the presence of a slash-command interface inside the MarsX IDE or chat interfaces. The platform does have a conversational AI interface for Micro‑App interactions, but whether it supports user-defined slash commands is not documented.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"MarsX's per-Micro‑App AI models act like specialized subagents: each microapp carries a model fine-tuned to its domain and usage, serving as a focused assistant for that micro-app's features.","plainChildren":""},{"type":"item","level":1,"content":"The AI orchestrator coordinates between Micro‑App models when they are composed, effectively creating runtime subagent interactions where the parent microapp model delegates to child microapp models.","plainChildren":""}]}]},{"type":"header","level":2,"content":"CustomModes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Unknown","plainChildren":""},{"type":"item","level":1,"content":"There is no clear public documentation showing a user-facing \"modes\" system for switching the IDE or AI into different specialist modes. The platform does support hybrid No-Code/Code workflows and per-microapp model tuning which effectively create contextual modes, but explicit custom-mode APIs or user-creatable modes are not documented.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"MarsX provides a Micro‑App marketplace that acts like a plugin system: Micro‑Apps are bundled units containing UI, backend logic, DB schemas, admin panels and metadata which can be installed into projects to add functionality.","plainChildren":""},{"type":"item","level":1,"content":"Micro‑Apps function as self-contained extensions that can be shared, versioned, monetized (free/premium) and composed together, similar to a plugin ecosystem for full‑stack features.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Git integration and source control: MarsX exposes Git support for projects/microapps, enabling standard commit/rollback workflows and history-based recovery.","plainChildren":""},{"type":"item","level":1,"content":"Micro‑App versioning and marketplace releases provide another checkpoint mechanism: published microapps can be versioned and rolled back to prior published releases.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SpecDrivenDevelopment","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Other","plainChildren":""},{"type":"item","level":1,"content":"MarsX follows a Micro‑App driven composition model rather than a named external spec-driven framework; the platform relies on self-contained Micro‑App manifests/specs (UI + API + DB schema) as the canonical unit of composition and reuse.","plainChildren":""}]}]}],"sourcePath":"marsx.md"},{"type":"header","level":1,"content":"Mistral Code - https://mistral.ai","children":[{"type":"text","content":"Mistral Code is an enterprise-focused AI coding assistant from Mistral AI that brings code generation, conversational help, and multi-step developer automation into IDEs and private deployments. It bundles several specialized models (Codestral, Codestral Embed, Devstral, Mistral Medium) and offers cloud, reserved, and air-gapped on-premises deployment options for secure enterprise use."},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"v1 (2025-06-04)"}]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Editor","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"[5] Strong enterprise focus with on-prem and air-gapped deployment options","plainChildren":""},{"type":"item","level":1,"content":"[4] Broad language coverage (80+ languages) and multi-model architecture","plainChildren":""}]}]},{"type":"header","level":2,"content":"Repository","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Any","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Fine-tuning / post-training on private repos","plainChildren":""},{"type":"item","level":1,"content":"Integration via plugins and Continue.dev","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"Mistral Code is a packaged AI developer assistant designed for enterprise adoption. Announced in mid-2025, it combines multiple specialized models to handle code completion (Codestral), embeddings and code search (Codestral Embed), agentic multi-step developer tasks (Devstral), and chat-style assistance (Mistral Medium). The product emphasizes security, governance and observability: teams can run it in the cloud, on reserved capacity, or fully on-premises in air-gapped GPU environments so that source code never leaves company boundaries. It integrates with developer IDEs (private beta for VSCode and JetBrains via Continue), supports fine-tuning on private codebases, and provides admin controls, RBAC, audit logs, metrics, and approval workflows to fit regulated environments."}]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Supports private deployments and enterprise key management practices through on-prem/air-gapped setups","plainChildren":""}]}]},{"type":"header","level":2,"content":"LocalOffline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Supports air-gapped on-premises GPU deployment for fully offline operation","plainChildren":""}]}]},{"type":"header","level":2,"content":"FreeTrial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Private beta availability; general availability and trial terms may vary","plainChildren":""}]}]},{"type":"header","level":2,"content":"GitSupport","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Integrates with repositories for retrieval-augmented generation, code search, and fine-tuning","plainChildren":""}]}]},{"type":"header","level":2,"content":"Terminal","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Agentic capabilities can reason over terminal output, run commands, and propose diffs under configurable approval flows","plainChildren":""}]}]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Proprietary","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Assuming continue.dev functionality is kept - doublecheck","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Core model stack: Codestral (autocomplete / fill-in-the-middle), Codestral Embed (embeddings / search), Devstral (agentic workflows), Mistral Medium (chat assistance).","plainChildren":""},{"type":"item","level":1,"content":"Built on top of the Continue open tooling for IDE integration (<https://continue.dev>), with private beta plugins for VSCode and JetBrains.","plainChildren":""},{"type":"item","level":1,"content":"Designed to address common enterprise blockers: connectivity & data residency, customization (fine-tuning), deeper task coverage (multi-step workflows), and consolidated SLAs.","plainChildren":""},{"type":"item","level":1,"content":"Adopted in production by organizations for hybrid/hardened deployments (examples reported: banks, large enterprises, system integrators).","plainChildren":""},{"type":"item","level":1,"content":"Not a drop-in open-source model; organizations seeking fully open-source stacks should evaluate the underlying Mistral model releases and Continue separately.","plainChildren":""},{"type":"item","level":1,"content":"Useful where governance, observability, and private-model customization are required for regulated codebases.","plainChildren":""}]}]},{"type":"header","level":2,"content":"ContextManagement","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"RAG / semantic retrieval via Codestral Embed: Mistral Code indexes repositories and returns relevant snippets for prompt construction.","plainChildren":""},{"type":"item","level":1,"content":"IDE-based context aggregation: open-file buffers, git diffs, terminal history and static-analysis metadata are used by the plugin to build contextual prompts for completions and agent tasks.","plainChildren":""},{"type":"item","level":1,"content":"Agent session state for multi-step workflows (Devstral): agents persist task state across steps (scan → edit → test → PR) and Mistral Console exposes usage/acceptance metrics.","plainChildren":""},{"type":"item","level":1,"content":"Admin controls to configure which context sources are allowed (repo indexing, terminal, local files) in enterprise/on‑prem deployments.","plainChildren":""}]}]},{"type":"header","level":2,"content":"DirectFileReferences","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Files can be directly referenced via the embedding index and semantic search (path-based results and file snippets returned to the assistant).","plainChildren":""},{"type":"item","level":1,"content":"IDE plugin and agentic workflows operate on explicit files: open/edit staged changes, create draft pull requests, and include file paths in diffs/commits.","plainChildren":""},{"type":"item","level":1,"content":"Private/on‑prem deployments keep repository indexing local so file references never leave the customer environment.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[]},{"type":"header","level":2,"content":"SlashCommands","children":[]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Devstral provides agentic workflows (specialized agents) that perform multi-step, multi-file engineering tasks: scanning a repo, making edits, running tests, and drafting PRs.","plainChildren":""},{"type":"item","level":1,"content":"Agents can be composed to chain retrieval → reasoning → edit → verification steps; enterprise flows include approval/authorization gates before applying changes.","plainChildren":""}]}]},{"type":"header","level":2,"content":"CustomModes","children":[]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Official IDE plugins for VS Code and JetBrains (private beta/GA progression) integrate completions, semantic search and one-click automations into the editor UI.","plainChildren":""},{"type":"item","level":1,"content":"Integration with Continue.dev and the plugin model enables embedding Mistral Code features into IDE/tooling workflows and connecting to enterprise infrastructure (SSO, audit logs).","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Agentic edits are surfaced as draft changes / pull requests and pass through configurable approval workflows; audit logs record actions so changes can be reviewed and reversed via normal git history.","plainChildren":""},{"type":"item","level":1,"content":"On‑prem deployments and RBAC reduce risk of unwanted auto-commits; standard VCS workflows (branches, PRs) serve as checkpoints for undoing agent actions.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SpecDrivenDevelopment","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Other","plainChildren":""},{"type":"item","level":1,"content":"Mistral Code is not tied to a single spec-driven development framework; it is designed to integrate with existing engineering workflows and can be used alongside SDD approaches (Tessl, SpecKit, etc.) via agentic automation and code generation, but it does not natively implement a particular SDD toolchain.","plainChildren":""}]}]}],"sourcePath":"mistral-code.md"},{"type":"header","level":1,"content":"Nuanced MCP Server - https://nuanced.ai","children":[{"type":"text","content":"Nuanced provides compiler-grade code intelligence (call graphs, symbols, types, dataflow) to AI coding agents via an MCP server that runs analysis locally and serves precise context slices to LLMs."},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"v— (2025-10-19)"}]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Editor","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[]},{"type":"header","level":2,"content":"Repository","children":[]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"TypeScript","plainChildren":""},{"type":"item","level":1,"content":"JavaScript","plainChildren":""},{"type":"item","level":1,"content":"Python","plainChildren":""},{"type":"item","level":1,"content":"Other","plainChildren":""},{"type":"item","level":1,"content":"advertised: total support for 8 languages; TypeScript and Python are prominent","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"Nuanced is an MCP (Model Context Protocol) server and code-intelligence layer that supplies AI coding assistants with compiler-grade facts about a repository: static call graphs, symbol tables (fully-qualified names and paths), inferred types, dataflow and control-flow information. Rather than sending raw file text or embeddings, Nuanced serves on-demand subgraphs of precisely the code relevant to a prompt, enabling agents to follow real call chains across files, reason about downstream impact (\"blast radius\"), and reduce hallucinations. Its design emphasizes local-first analysis so that repository code and analysis results remain on user infrastructure while providing integration points for IDEs, CI, and custom agents."}]},{"type":"header","level":2,"content":"BYOK","children":[]},{"type":"header","level":2,"content":"LocalOffline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Local-first MCP server: analysis runs on the user's machine or infrastructure; code/context does not need to be uploaded to external APIs.","plainChildren":""}]}]},{"type":"header","level":2,"content":"FreeTrial","children":[]},{"type":"header","level":2,"content":"GitSupport","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Terminal","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Provides an npm package and CLI for setup/configuration; integrates with developer workflows.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Nuanced began as an open-source call-graph/context library; core components have been published for community use.","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Nuanced is explicitly implemented as an MCP server to deliver structured code context to LLM-based agents.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Built by former GitHub engineers experienced in large-scale code intelligence and search.","plainChildren":""},{"type":"item","level":1,"content":"Key capabilities: static call graphs, symbol-level context, inferred types, dataflow/control-flow facts, and on-demand context subgraphs for prompts.","plainChildren":""},{"type":"item","level":1,"content":"Integrations: used with AI assistants and tools (examples reported: Cursor, Claude Code, Codex workflows) and integrates with LSP tooling and IDEs.","plainChildren":""},{"type":"item","level":1,"content":"Benefits: reduces LLM token spend (reported up to ~33% in company materials), improves accuracy of generated code, limits hallucinations by giving models precise code facts, and helps predict downstream impact of edits.","plainChildren":""},{"type":"item","level":1,"content":"Language support: strong TypeScript support, official Python support announced; company advertises support for eight languages in total with broader support available via enterprise offerings.","plainChildren":""},{"type":"item","level":1,"content":"Deployment: installable via npm (npm package / CLI), configured as an MCP server; designed to run locally or on-prem for secure codebases.","plainChildren":""},{"type":"item","level":1,"content":"Tradeoffs/Unknowns: full license details and exact language-by-language feature parity are not always documented in public materials; enterprise features and expanded language support may be gated under paid plans.","plainChildren":""},{"type":"item","level":1,"content":"Good fit for: teams using LLMs to assist coding on large/complex repos, organizations requiring local analysis for security/privacy, and tooling vendors building LLM-powered code assistants.","plainChildren":""}]}]}],"sourcePath":"nuanced.md"},{"type":"header","level":1,"content":"Ona (Gitpod) - https://ona.com","children":[{"type":"text","content":"Cloud development environments reimagined as autonomous AI engineering platform."},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"v1.0 (2025-09-01)"}]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Editor","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"[4] Strong enterprise features and security posture","plainChildren":""},{"type":"item","level":1,"content":"[5] Highly productive autonomous agents for routine engineering tasks","plainChildren":""}]}]},{"type":"header","level":2,"content":"Repository","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"https://github.com/gitpod-io/gitpod","plainChildren":""}]}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Any","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"Ona is the rebrand and strategic evolution of Gitpod into an AI-first software engineering platform. Building on Gitpod's one-click, preconfigured cloud development environments, Ona layers autonomous AI \"agents\" that can plan, implement, test, review, and (with guardrails) deploy code inside secure, sandboxed environments. The platform is organized around three core pillars: Ona Environments (declarative, API-first dev environments with sandboxing and VPC deployment options), Ona Agents (autonomous AI collaborators that operate via natural language, IDE integrations, or automation pipelines), and Ona Guardrails (RBAC, audit trails, command controls, and compliance features for enterprise governance). Ona targets developer productivity at scale for both individual teams and large regulated enterprises."}]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"LocalOffline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Ona supports private VPC and on-prem/private-hosted deployments for enterprises but is not a fully offline/local-only product.","plainChildren":""}]}]},{"type":"header","level":2,"content":"FreeTrial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"GitSupport","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Terminal","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Core Gitpod components remain open-source; some agent and enterprise-grade features are commercial/proprietary.","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"MIT","plainChildren":""},{"type":"item","level":1,"content":"core open-source components","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Ona represents a shift from IDE-as-product to \"mission control\" for autonomous engineering agents; the rebrand reflects this broader scope.","plainChildren":""},{"type":"item","level":1,"content":"Autonomous agents can operate with high independence inside sandboxed environments, enabling workflows where agents co-author, test, and merge code with minimal human intervention.","plainChildren":""},{"type":"item","level":1,"content":"Enterprise features include VPC deployment, SSO/OIDC, RBAC, command deny lists, and full audit trails—important for regulated industries.","plainChildren":""},{"type":"item","level":1,"content":"Reported internal metrics (company) indicate substantial productivity gains (agents co-authoring a large share of merged PRs); real-world gains will vary by org and workflow maturity.","plainChildren":""},{"type":"item","level":1,"content":"Good fit for teams that want to adopt AI-driven automation while retaining strict governance and compliance controls.","plainChildren":""},{"type":"item","level":1,"content":"Limitations: true autonomous workflows require careful policy and guardrail configuration; smaller teams without enterprise needs may not need the full Ona stack.","plainChildren":""},{"type":"item","level":1,"content":"Recommended evaluation steps: trial with a sandbox project, configure guardrails and VPC options, measure agent outputs against existing PR and review metrics, and validate audit/compliance reporting.","plainChildren":""}]}]},{"type":"header","level":2,"content":"ContextManagement","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Ona provides explicit context management for its AI agents via a repository-level AGENTS.md that the agent loads at the start of a session. Additional context sources include workspace definitions (devcontainer.json), automation manifests (e.g. automations.yml / automation configs), environment variables and prebuild metadata, and repository files the agent can read on demand. These artifacts together let teams define project conventions, commands, and policies that are consistently applied by agents.","plainChildren":""}]}]},{"type":"header","level":2,"content":"DirectFileReferences","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"AGENTS.md is designed to reference other files in the repo; Ona agents will read files referenced there and can access repository files directly in the sandboxed workspace. This enables pointing to style guides, architecture docs, and specific source files rather than duplicating their contents in the main agent config.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Public docs for Gitpod historically exposed lifecycle hooks for workspaces (prebuilds, init/tasks) and Ona surface-level documentation references automation triggers; however, a clearly documented agent lifecycle hooks API (for attaching arbitrary external listeners to agent start/stop events) was not found in the available documentation. If you need explicit agent lifecycle hooks, verify in the Ona docs or with support for the latest agent API.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Ona agents support slash-command style interactions to trigger automations and common engineering tasks from chat or IDE integrations. These commands are intended to quickly invoke tests, CI-like automations, or agent behaviours and are integrated into the agent UX across browser and IDE clients.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Ona is explicitly positioned as \"mission control for your personal team of software engineering agents,\" allowing multiple specialized agents (roles/agents) to be defined and orchestrated for different tasks — e.g., code-gen agents, review agents, release agents — under centralized governance.","plainChildren":""}]}]},{"type":"header","level":2,"content":"CustomModes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Agent behaviour and operating modes can be tailored via repository-level configuration (AGENTS.md), environment definitions, and automation manifests; teams can create specialized profiles/workspace configs that produce distinct agent behaviours or permissions for particular workflows.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Ona integrates with IDE extensions and editor platforms (e.g., VS Code, JetBrains, Cursor, Zed) and exposes automation/extension points; bundling commands and automation into reusable packages is done via workspace/automation configuration and editor extension packs rather than a single \"plugin store\" model.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Ona/Gitpod workflows provide workspace snapshots, prebuilds and the normal git history as mechanisms to revert or recover from agent actions. For enterprise users, Guardrails and audit trails further enable tracing and, where necessary, rolling back changes using standard VCS or snapshot workflows.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SpecDrivenDevelopment","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Other","plainChildren":""},{"type":"item","level":1,"content":"There is no public indication that Ona (Gitpod/Ona) is built around or prescribes a specific external spec-driven development framework such as Tessl or the others listed. Ona provides environment and automation primitives but does not appear to mandate a particular spec-driven methodology.","plainChildren":""}]}]}],"sourcePath":"ona_gitpod.md"},{"type":"header","level":1,"content":"PearAI - https://trypear.ai","children":[{"type":"text","content":"PearAI is an open-source AI-powered code editor that aims to be an all-in-one development environment integrating multiple AI tools and capabilities into a familiar VSCode-like experience. Much of the AI agent functionality is built upon RooCode and Cline."},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"v1.x (active; releases during 2024-2025)"}]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Editor","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"[4] Strong project vision and open-source approach","plainChildren":""},{"type":"item","level":1,"content":"[3] Early-stage rough edges; initial licensing controversy","plainChildren":""}]}]},{"type":"header","level":2,"content":"Repository","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Any","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Fork of VSCode + modular submodules for AI features; supports plugins and integrations","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"PearAI provides a unified AI-first IDE experience by combining the familiarity of VSCode with integrated AI features like contextual chat, project-aware code understanding, inline edits with diffs, and model routing to pick the best available AI model for coding tasks. The platform emphasizes local code privacy while enabling rich multi-file context and automated workflows."}]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Users can supply their own API keys for models (BYOK), enabling use with different model providers and preserving control over credentials.","plainChildren":""}]}]},{"type":"header","level":2,"content":"LocalOffline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"FreeTrial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Free tier available with basic features and BYOK support; paid tiers unlock advanced features","plainChildren":""}]}]},{"type":"header","level":2,"content":"GitSupport","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Integrates with Git workflows; offers @diff referencing of branch changes and commit workflow helpers","plainChildren":""}]}]},{"type":"header","level":2,"content":"Terminal","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Built on VSCode fork; includes integrated terminal and @terminal context command","plainChildren":""}]}]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"MIT","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Core features:","plainChildren":""},{"type":"item","level":1,"content":"Context-aware codebase queries via @codebase, @docs, @diff, @terminal, @problems commands","plainChildren":""},{"type":"item","level":1,"content":"Keyboard-driven workflow: CMD+I for inline edits (with diffs), CMD+L to start chats with selected code, CMD+SHIFT+L to append to chat","plainChildren":""},{"type":"item","level":1,"content":"PearAI Router: automatically routes requests to the best performing AI model available, reducing the need to manage multiple subscriptions","plainChildren":""},{"type":"item","level":1,"content":"PearAI Agent: autonomous coding assistant functionality for automating tasks (planned/early)","plainChildren":""},{"type":"item","level":1,"content":"PearAI Creator, Login, Launch: roadmap features for project generation, auth scaffolding, and deployment (Netlify) respectively","plainChildren":""},{"type":"item","level":1,"content":"History & controversy: PearAI launched with a rocky start after initially shipping under a proprietary license despite significant code coming from Continue.dev; the project later reverted to an open-source license and apologized, stabilizing community trust","plainChildren":""},{"type":"item","level":1,"content":"Audience: developers who want an open-source, AI-first IDE experience with strong project context awareness and extensibility","plainChildren":""}]}]},{"type":"header","level":2,"content":"ContextManagement","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"PearAI provides multiple methods for managing and updating context: project-aware @commands (e.g. @codebase, @code, @filename, @foldername, @docs, @terminal, @diff, @problems), a local codebase index for retrieving relevant snippets, inline selection-to-chat flows (CMD+L / CTRL+L), and a memory layer (Mem0) for persisting conversational or developer-specific context. Users can also add documentation manually to the chat context and supply local files for the assistant to reference.","plainChildren":""}]}]},{"type":"header","level":2,"content":"DirectFileReferences","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"PearAI supports directly referencing files and folders in prompts and chats via commands like @filename and @foldername, attaching files/docs to chats, and including selected code from open editor tabs. The @diff and @code commands enable referencing specific changes and functions across the repo.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"There are no widely documented, first-class \"agent lifecycle\" hook events (e.g., onRequest, onResponse, onApplyPatch) exposed in PearAI's public docs. Extensibility via the VSCode-like extension/plugin model may permit custom integrations that observe editor events, but explicit agent lifecycle hook APIs are not documented.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"PearAI includes reusable slash/command-style actions (examples in product docs include /edit and other command triggers), keyboard shortcuts (CMD/CTRL+I, CMD/CTRL+L, CMD/CTRL+SHIFT+L) and an @-command system to invoke contextual behaviors. These can be reused across chats and workflows to trigger editing, context injection, diffs and more.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"PearAI surfaces agent-like automation features (PearAI Agent is listed as planned/early) and routes tasks to specialized models or toolsets (Aider, Supermaven, Continue, Perplexity, Mem0). Users can achieve subagent-like workflows by combining model routing, tool integrations, and scripted command sequences; PearAI's router automatically selects the best-performing model for each task.","plainChildren":""}]}]},{"type":"header","level":2,"content":"CustomModes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Users can create tailored workflows by configuring model routing, toggling built-in tools, supplying BYOK keys, and using custom command sequences. Because PearAI is a VSCode fork and supports extensions/plugins, teams can implement specialist modes (e.g., a Web3 mode that loads specific docs, models, and snippets) through configuration and extensions.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"PearAI is extensible and built on a VSCode-like architecture; it supports plugins/integrations that can bundle commands, tooling, and integrations. Developers can extend behavior by adding integrations (model providers via BYOK, documentation sources, or custom tooling) and packaging those as extensions/plugins compatible with the environment.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"PearAI presents diffs for inline edits before applying changes, supports local undo in the editor, and integrates with Git so changes can be committed and reverted. The @diff workflow and preview/accept model provide checkpoints prior to committing AI-generated edits; standard Git operations (revert/reset) and editor undo serve as recovery mechanisms.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SpecDrivenDevelopment","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Other","plainChildren":""},{"type":"item","level":1,"content":"PearAI does not appear to target or natively implement a specific spec-driven development framework. It is an AI-first IDE focused on contextual coding assistance, model routing, and extensibility rather than a spec-driven code-generation lifecycle. If teams use PearAI in a spec-driven workflow, they typically map their own specs/docs into the workspace via the @docs and project context features.","plainChildren":""}]}]}],"sourcePath":"pearai.md"},{"type":"header","level":1,"content":"Pythagora - https://pythagora.ai","children":[{"type":"text","content":"A developer-focused AI platform that generates full-stack applications and automated tests from natural language prompts."},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"(2025-10-19)"}]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Editor","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"[4] Strong for rapid prototyping and automated test generation","plainChildren":""},{"type":"item","level":1,"content":"[3] Maturity and enterprise polish can vary depending on use case","plainChildren":""}]}]},{"type":"header","level":2,"content":"Repository","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"JavaScript","plainChildren":""},{"type":"item","level":1,"content":"TypeScript","plainChildren":""},{"type":"item","level":1,"content":"React (frontend)","plainChildren":""},{"type":"item","level":1,"content":"Node.js / Express (backend)","plainChildren":""},{"type":"item","level":1,"content":"SQL","plainChildren":""},{"type":"item","level":1,"content":"SQLite, PostgreSQL","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"Pythagora is an AI-driven development assistant that can generate full-stack web applications and automated unit tests from natural language descriptions. It integrates with developer workflows (notably VS Code) and provides tooling to scaffold frontend and backend code, wire up databases, create authentication flows, and produce Jest-based unit tests. The platform aims to accelerate the 80% of routine development (boilerplate, CRUD, UI scaffolding) so developers can focus on higher-level business logic."}]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"LocalOffline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Requires cloud access to LLMs; not designed for fully offline usage.","plainChildren":""}]}]},{"type":"header","level":2,"content":"FreeTrial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"GitSupport","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Terminal","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Offers CLI commands (e.g. npx pythagora ...) to generate tests and scaffold code.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Proprietary","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Core capabilities:","plainChildren":""},{"type":"item","level":1,"content":"Generate full applications from natural language prompts (frontend + backend + database)","plainChildren":""},{"type":"item","level":1,"content":"Automated unit test generation (Jest), useful for helper functions and standalone units","plainChildren":""},{"type":"item","level":1,"content":"Debugging primitives (logs, breakpoints, step-debugging) to help diagnose generated code","plainChildren":""},{"type":"item","level":1,"content":"Integration with Git hosting (GitHub, GitLab, Bitbucket)","plainChildren":""},{"type":"item","level":1,"content":"Typical use cases:","plainChildren":""},{"type":"item","level":1,"content":"Rapid prototyping and MVP development","plainChildren":""},{"type":"item","level":1,"content":"Internal tooling and admin panels","plainChildren":""},{"type":"item","level":1,"content":"Accelerating freelance or small-team projects","plainChildren":""},{"type":"item","level":1,"content":"Auto-generating unit tests for existing helper code","plainChildren":""},{"type":"item","level":1,"content":"Testing notes:","plainChildren":""},{"type":"item","level":1,"content":"Best results for standalone, exported functions; can generate many tests quickly","plainChildren":""},{"type":"item","level":1,"content":"Example CLI usage reported: `npx pythagora --unit-tests --path ./src/utils/common.js` or target a single function","plainChildren":""},{"type":"item","level":1,"content":"In evaluations, generated tests often uncovered real bugs in subject code","plainChildren":""},{"type":"item","level":1,"content":"Pricing / access:","plainChildren":""},{"type":"item","level":1,"content":"Free starter tier available with usage limits (suitable for learning and small projects)","plainChildren":""},{"type":"item","level":1,"content":"Paid tiers expand capabilities; may include un-watermarked apps, more tokens, and team features","plainChildren":""},{"type":"item","level":1,"content":"Security & privacy:","plainChildren":""},{"type":"item","level":1,"content":"Code is processed via cloud LLMs (OpenAI or Pythagora API); review policies for sensitive code","plainChildren":""},{"type":"item","level":1,"content":"Enterprise features may include team-only access and secure auth bridges","plainChildren":""},{"type":"item","level":1,"content":"Limitations & considerations:","plainChildren":""},{"type":"item","level":1,"content":"Not fully offline — relies on cloud LLMs and internet connectivity","plainChildren":""},{"type":"item","level":1,"content":"Additional remarks:","plainChildren":""},{"type":"item","level":1,"content":"Pythagora behaves more like an autonomous development agent (planning + execution) rather than a line-completion assistant","plainChildren":""},{"type":"item","level":1,"content":"Good complement to developer workflows when paired with code review and CI/CD practices","plainChildren":""}]}]},{"type":"header","level":2,"content":"ContextManagement","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Pythagora manages context through tight VS Code/workspace integration and a project-local \"pythagora core\" directory (or cloud workspace) that the platform scans and updates. Context is maintained via:","plainChildren":""},{"type":"item","level":1,"content":"Workspace file scanning and direct file edits (the extension writes files into your repo/workspace).","plainChildren":""},{"type":"item","level":1,"content":"A project-level config.json (Pythagora Core) where LLM keys, development mode (local/cloud), and other settings are declared.","plainChildren":""},{"type":"item","level":1,"content":"Agent session logs and action traces (visibility into what the AI agents did during a run), which developers can review to understand and update context.","plainChildren":""},{"type":"item","level":1,"content":"Git integration (the usual source-control history acts as a record of context changes).","plainChildren":""}]}]},{"type":"header","level":2,"content":"DirectFileReferences","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Pythagora can be pointed at specific directories and files. Common methods observed include:","plainChildren":""},{"type":"item","level":1,"content":"VS Code extension: operate directly on the open workspace files.","plainChildren":""},{"type":"item","level":1,"content":"CLI flags / commands (examples reported like `--path ./src` or `--unit-tests --path ./src/utils`) to target particular files or folders.","plainChildren":""},{"type":"item","level":1,"content":"Editing the project `config.json` in the Pythagora core path to indicate which files/LLMs/settings to use.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Public documentation does not describe a first-class, user-facing hook or lifecycle API. There may be internal events and the VS Code extension exposes commands, but a formal hooks system (webhooks, lifecycle callbacks) is not documented.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Pythagora exposes CLI-style commands and VS Code command-palette entries. Known examples:","plainChildren":""},{"type":"item","level":1,"content":"`npx pythagora` usage reported for scaffolding and unit-test generation.","plainChildren":""},{"type":"item","level":1,"content":"VS Code commands provided by the extension for starting/stopping the assistant, toggling local/cloud mode, and invoking generation or test runs.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Pythagora is designed around multiple specialized agents (publicly discussed as ~14 agents) that coordinate to plan, generate, review, test, debug and deploy applications. These subagents cover distinct roles such as planning, frontend generation, backend generation, test generation, and debugging.","plainChildren":""},{"type":"item","level":1,"content":"The architecture appears to be orchestrated so that agents pass artifacts and logs among themselves; however, there is no public API documented for creating custom subagents or directly wiring new agent types (the system is opinionated and prebuilt agents do the heavy lifting).","plainChildren":""}]}]},{"type":"header","level":2,"content":"CustomModes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Pythagora supports different development modes and configuration options:","plainChildren":""},{"type":"item","level":1,"content":"Local mode vs Cloud mode (you can run a local Pythagora core path in VS Code or use the hosted/cloud workflow).","plainChildren":""},{"type":"item","level":1,"content":"BYOK (bring-your-own-key) configuration via `config.json` to choose which LLMs to use.","plainChildren":""},{"type":"item","level":1,"content":"Opinionated technology modes (React + Node by default) and settings that steer the generator toward the supported stacks.","plainChildren":""},{"type":"item","level":1,"content":"These modes let teams control where work runs, which models are used, and how the assistant behaves in terms of deployment and file writes.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"The primary integration point is the VS Code extension which bundles commands, editor integrations, and the multi-agent orchestration into a single user-facing plugin. Additionally, Pythagora integrates with Git providers and deployment targets (one-click deploys), and supports configuration via a project-level core directory.","plainChildren":""},{"type":"item","level":1,"content":"There is no public evidence of a broader third-party plugin marketplace or plugin SDK — the VS Code extension and built-in integrations act as the bundling mechanism.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Undo/rollback workflows are supported indirectly via standard Git integration; Pythagora writes real files to the workspace/repo so developers can use their normal VCS workflows to create commits, branches and rollbacks.","plainChildren":""},{"type":"item","level":1,"content":"The platform also provides activity logs and agent traces which can help reconstruct or revert changes.","plainChildren":""},{"type":"item","level":1,"content":"There is no clearly documented in-platform \"checkpoint\" snapshot API (e.g., one-click snapshot/restore) beyond using Git and deployment snapshots.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SpecDrivenDevelopment","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Other","plainChildren":""},{"type":"item","level":1,"content":"Pythagora does not advertise adherence to the named spec-driven development frameworks. Its workflow centers on iterative generation, testing, and deployment powered by multi-agent orchestration rather than a formal SDD methodology. If integrating with a spec-driven process (for example Tessl), teams would rely on exporting the generated code and tests into their spec tooling and version control rather than integrate directly with a Pythagora-native SDD system.","plainChildren":""}]}]}],"sourcePath":"pythagora.md"},{"type":"header","level":1,"content":"Refact.ai - https://refact.ai","children":[{"type":"text","content":"An open-source autonomous AI coding assistant with RAG-powered completions and in-IDE agent features."},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"(2025-10-19)"}]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Editor","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"[5] Excellent context-aware completions and agent capabilities","plainChildren":""},{"type":"item","level":1,"content":"[4] Strong IDE integrations (VS Code, JetBrains, Neovim)","plainChildren":""},{"type":"item","level":1,"content":"[4] Good documentation and deployment guides","plainChildren":""}]}]},{"type":"header","level":2,"content":"Repository","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"https://github.com/smallcloudai/refact","plainChildren":""}]}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Any","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"Refact.ai is an open-source AI coding assistant and autonomous engineering agent that provides context-aware code completion, refactoring, in-IDE chat, debugging, test generation, and autonomous repository operations. It uses Retrieval-Augmented Generation (RAG) to make suggestions grounded in your codebase and supports multiple LLM providers via a BYOK (bring-your-own-key) approach. Refact.ai can be self-hosted (Docker) for on-premises deployments and integrates with common dev tools like GitHub/GitLab, databases, and CI workflows."}]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"LocalOffline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Self-hosted Docker deployment and on-prem options. Can be run without sending code to third-party services when configured to use local/private models and infrastructure.","plainChildren":""}]}]},{"type":"header","level":2,"content":"FreeTrial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"GitSupport","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Terminal","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Agent can execute shell commands, interact with Docker, run tests and debuggers (e.g., pdb) when permitted by deployment configuration.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"BSD-3","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Notable features: RAG-based whole-repo context, unlimited accurate autocompletion (uses models like Qwen2.5-Coder by default for completions), in-IDE chat tied to repo context, autonomous agent actions (branching, commits, PRs).","plainChildren":""},{"type":"item","level":1,"content":"Deployment: Docker images and docs available in the repo for self-hosted/on-prem deployments; enterprise offerings include managed AWS Marketplace images and Nvidia-optimized instances.","plainChildren":""},{"type":"item","level":1,"content":"Enterprise: fine-tuning support for organization codebases and multiple simultaneous fine-tunes for different teams.","plainChildren":""},{"type":"item","level":1,"content":"Benchmarking: ranks highly on SWE-bench (verified) for AI code agents in pass@1 and multimodal tasks.","plainChildren":""},{"type":"item","level":1,"content":"Pricing model: Free tier (e.g., initial \"coins\" allocation such as 5,000), Pro plans and Enterprise plans with additional features and on-prem support.","plainChildren":""},{"type":"item","level":1,"content":"Security & privacy: Self-hosted option allows code to remain inside your network; BYOK gives control over which LLMs and keys are used.","plainChildren":""}]}]},{"type":"header","level":2,"content":"ContextManagement","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Refact.ai uses Retrieval-Augmented Generation (RAG) to maintain and update contextual state across a repository: whole-repo indexing, symbol-aware retrieval, and context windows sourced from the repo index.","plainChildren":""},{"type":"item","level":1,"content":"In-IDE session/chat history is preserved and combined with retrieved artifacts to form answers; users can create custom system prompts to influence context.","plainChildren":""},{"type":"item","level":1,"content":"Explicit context controls: @-commands (e.g., @file, @web, @definition, @references, @tree) let users attach or restrict specific sources of context for a given query.","plainChildren":""},{"type":"item","level":1,"content":"Configurable model selection and BYOK allow controlling which LLM and key are used, indirectly affecting context generation and privacy.","plainChildren":""}]}]},{"type":"header","level":2,"content":"DirectFileReferences","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Files can be referenced directly via IDE integrations and chat: @file uploads, file attachments, and by invoking workspace tree/@tree to point the agent at specific files or directories.","plainChildren":""},{"type":"item","level":1,"content":"RAG indexing maps symbols to file locations (definitions/references), enabling queries like “show usages of X” or “apply changes to file Y” that reference files precisely.","plainChildren":""},{"type":"item","level":1,"content":"The agent can read and operate on repository files (open, edit, commit) when granted appropriate permissions in the self-hosted or hosted deployment.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Refact.ai exposes a set of in-chat @-commands (functionally equivalent to slash commands) such as @web, @file, @definition, @references, and @tree to trigger reusable behaviors and context attachments.","plainChildren":""},{"type":"item","level":1,"content":"Users can create and reuse custom system prompts and prompt templates inside the workspace to replicate common command-like workflows.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Refact.ai supports autonomous agent workflows that can be configured to run multi-step tasks (e.g., run tests, create branches, commit changes, open PRs) and integrate with external tools (Git, Docker, DBs, shell) when enabled.","plainChildren":""},{"type":"item","level":1,"content":"Agents leverage the repo index + tool integrations to execute actions, follow-up on results, and iterate (plan→execute→verify) across the codebase.","plainChildren":""}]}]},{"type":"header","level":2,"content":"CustomModes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Users can define custom system prompts, select specific LLMs, and configure workspace-level settings to create tailored modes for different tasks (refactor, document, test, review).","plainChildren":""},{"type":"item","level":1,"content":"BYOK and model selection let teams create specialized modes that enforce privacy or use tuned models for in-house coding standards.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Refact.ai provides IDE plugins (VS Code, JetBrains, Neovim) and connectors (GitHub/GitLab, databases, Docker) that bundle commands, agent behaviors, and integrations into reusable workflows.","plainChildren":""},{"type":"item","level":1,"content":"Deployments (self-hosted Docker / enterprise images) and extension points allow organizations to integrate custom tools and scripts that the agent can call as part of its actions.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Actions performed by the agent that modify repository state (branches, commits, PRs) are reversible using standard Git operations (revert, reset, branch/commit history) when the agent's git-level permissions are enabled.","plainChildren":""},{"type":"item","level":1,"content":"Self-hosted deployments can enforce additional backup/versioning policies; enterprise deployments support retaining audit logs and rolling back via git or deployment snapshots.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SpecDrivenDevelopment","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Other","plainChildren":""},{"type":"item","level":1,"content":"None : Refact.ai is a code-assistant / autonomous-engineering agent and does not itself prescribe a specific spec-driven development framework","plainChildren":""}]}]}],"sourcePath":"refact.md"},{"type":"header","level":1,"content":"Refraction - https://refraction.dev","children":[{"type":"text","content":"A small, practical AI assistant for developers focused on refactoring, test generation, documentation, and small code transforms rather than real-time in-editor completions."},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"(2025-10-19)"}]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Editor","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"[4] Code generation & refactoring quality","plainChildren":""},{"type":"item","level":1,"content":"[4] Value for money (budget-friendly paid tier)","plainChildren":""}]}]},{"type":"header","level":2,"content":"Repository","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Any","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Editor extensions are available on paid tiers (editor plugins/support mentioned in product features)","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"Refraction is a web-first AI development assistant (refraction.dev) which helps developers automate repetitive tasks: generate unit tests, add or improve documentation, refactor and clean code, generate regular expressions, convert small code snippets between languages, and produce short code implementations from natural-language prompts. It is positioned for improving existing code and producing targeted outputs rather than acting as a continuous real-time code completion engine."}]},{"type":"header","level":2,"content":"BYOK","children":[]},{"type":"header","level":2,"content":"LocalOffline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"FreeTrial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"New users get a limited number of free generations (commonly reported as ~10 free uses) and a short trial period to evaluate the service.","plainChildren":""}]}]},{"type":"header","level":2,"content":"GitSupport","children":[]},{"type":"header","level":2,"content":"Terminal","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Proprietary","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[]},{"type":"header","level":2,"content":"Notes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Pricing: consumer/pro plan pricing reported in public materials at roughly $8/month for the Pro (unlimited generations) tier; Team and Enterprise tiers are available with additional collaboration, billing and SSO/SCIM/audit features.","plainChildren":""},{"type":"item","level":1,"content":"Strengths: fast, focused tooling for test generation, documentation, refactors and small code transforms; broad language coverage (56 languages); inexpensive compared with many other AI-dev assistants.","plainChildren":""},{"type":"item","level":1,"content":"Limitations: not open-source, hosted (no obvious offline/local mode), limited real-time in-editor pairing (it’s oriented around discrete generations rather than streaming in-line completions like Copilot), and limited public detail about the exact underlying model(s) (no explicit, verifiable public claim that it runs on a specific third-party model such as OpenAI).","plainChildren":""},{"type":"item","level":1,"content":"Data & privacy: product materials indicate generations and history are stored to provide a History feature; check Refraction's privacy policy / terms for details before sending sensitive code.","plainChildren":""},{"type":"item","level":1,"content":"Use-cases: adding unit tests, documenting legacy code, refactoring for clarity or minor performance improvements, generating regexes and language-to-language snippet translations.","plainChildren":""}]}]},{"type":"header","level":2,"content":"ContextManagement","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Refraction operates as a web-based code assistant that accepts pasted code snippets and natural-language prompts for discrete generations. There is no public documentation of persistent, project-level context management APIs or advanced context orchestration features.","plainChildren":""}]}]},{"type":"header","level":2,"content":"DirectFileReferences","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"The product provides an editor integration (Sublime Text extension) for in-editor usage, but there is no documentation indicating support for direct file path references, project-wide file indexing, or referencing files on disk via the web UI or an API.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"No public documentation describes lifecycle events, webhooks, or attachable hooks for responding to Refraction events or generation lifecycle stages.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"There is no documented support for user-triggered reusable slash-style commands or command palettes exposed by the product.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Refraction does not document any capability to define or orchestrate specialized AI subagents for task-specific workflows; its model is centered on discrete generation tasks (refactors, tests, docs) per request.","plainChildren":""}]}]},{"type":"header","level":2,"content":"CustomModes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"There is no public information about creating persistent custom modes or specialist modes that alter the assistant's behavior across sessions. The product focuses on one-off, targeted generations rather than configurable modes.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"While Refraction provides an editor integration (a Sublime Text extension) for more convenient in-editor flows, there is no evidence of a broader extensibility/plugin system for bundling commands, agents, and hooks as a platform-facing plugin framework.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"There is no documented checkpoint or undo system for reverting actions; Refraction stores generation history for user review, but this is not presented as a versioned checkpoint/rollback mechanism.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SpecDrivenDevelopment","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Other","plainChildren":""},{"type":"item","level":1,"content":"None — Refraction is a focused developer productivity assistant (refactors, tests, docs) and is not a spec-driven development framework","plainChildren":""}]}]}],"sourcePath":"refraction.md"},{"type":"header","level":1,"content":"RooCode - https://roocode.ai","children":[{"type":"text","content":"RooCode (formerly Roo Cline) is an AI-powered VS Code extension that acts as an autonomous coding assistant with customizable personas (modes), multi-model support, and project-level automation."},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"v3.3 (2024-10-18)"}]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Editor","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"[4] Strong multi-mode assistant with deep VS Code integration","plainChildren":""},{"type":"item","level":1,"content":"[3] Experimental parts (VS Code LLM API, some provider integrations) can be rough","plainChildren":""}]}]},{"type":"header","level":2,"content":"Repository","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"https://github.com/RooCodeInc/Roo-Code","plainChildren":""}]}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Any","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"VS Code extension architecture, custom modes, MCP (Model Context Protocol) servers, and provider/plugin integrations","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"RooCode is designed to be more than an autocomplete plugin — it functions as an autonomous agent inside VS Code that can read/write files, run terminal commands, automate browser interactions, and orchestrate multi-step development tasks. It exposes built-in personas (Code, Architect, Ask, Debug) and allows developers to create custom modes with tailored prompts, file restrictions, and permissions. The extension supports multiple AI providers (OpenAI, Anthropic, Google Gemini, OpenRouter and others) and can be configured to use different models for different tasks to balance cost and capability. It includes features such as cost/token tracking, auto-approve actions (optional autonomy), inline editing, and Model Context Protocol (MCP) integration for controlling external systems."}]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"LocalOffline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Can be configured to use local model runtimes via Ollama / LM Studio or other locally-hosted model endpoints (support and experience depends on provider and model compatibility). Fully offline workflows may be limited compared to cloud API usage.","plainChildren":""}]}]},{"type":"header","level":2,"content":"FreeTrial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"The extension itself is free/open-source; model usage costs depend on the API keys/providers you supply.","plainChildren":""}]}]},{"type":"header","level":2,"content":"GitSupport","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"RooCode can run terminal/cli actions and operate on workspace files; many users run git commands through the integrated terminal or via custom MCP servers.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Terminal","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Supports running terminal commands and automation as part of tasks and modes.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Apache-2.0","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"MCP servers extend RooCode beyond the editor to interact with Docker, databases, browsers and other external tooling.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Operational modes: Code (implementation), Architect (design/architecture), Ask (Q&A/research), Debug (troubleshooting). Modes can auto-switch or be created by users.","plainChildren":""},{"type":"item","level":1,"content":"Provider flexibility: BYOK model lets teams choose vendors and control costs; OpenRouter is commonly supported for multi-provider access.","plainChildren":""},{"type":"item","level":1,"content":"Experimental VS Code Language Model API support is available, but feature parity and cost/usage visibility vary versus direct API connections.","plainChildren":""},{"type":"item","level":1,"content":"Cost tracking and usage reporting help teams monitor token usage across models and sessions.","plainChildren":""},{"type":"item","level":1,"content":"Installation: available on Visual Studio Marketplace; can also be built and installed from source (pnpm/npm workflows, build VSIX).","plainChildren":""},{"type":"item","level":1,"content":"Community & forks: active community forks and experimental branches exist; check the primary repo and its forks for the latest features.","plainChildren":""},{"type":"item","level":1,"content":"Considerations: while powerful, RooCode’s autonomy features require careful configuration (auto-approve actions, file restrictions) to avoid unintended changes. Local/offline model support exists but may require additional setup and offers different capabilities than cloud models.","plainChildren":""}]}]},{"type":"header","level":2,"content":"ContextManagement","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"RooCode provides multiple context-management methods: semantic workspace indexing (configurable embedding providers and vector DBs), explicit file/selection mentions (using `@` to include files, ranges or terminal output), automatic context condensing when length limits are reached, configurable context limits per mode, and a persistent Memory Bank for long-lived project facts. The extension also supports MCP-based context extensions so external systems can contribute contextual data.","plainChildren":""}]}]},{"type":"header","level":2,"content":"DirectFileReferences","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Files and specific ranges can be referenced directly in prompts (via the editor UI and `@` mentions). RooCode can read/write workspace files, present diffs for review, and include terminal output or file snippets inline into the conversation for targeted edits or reasoning.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"RooCode exposes lifecycle-like behaviors via its modes and MCP integrations: custom modes can define pre/post actions and permission rules; MCP servers allow external tooling to register endpoints and respond to agent events; checkpointing and auto-approve flows provide hook points where the user can intercept or allow automated actions. Additionally, VS Code command palette integration and tasks provide natural hook points for automation.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"RooCode integrates with VS Code commands and provides re-usable actions through custom modes and task templates. Users can invoke RooCode functionality from the command palette, configure auto-approve command flows, and reuse mode-specific commands and personas for repeated workflows.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"RooCode supports composing multi-step workflows (Boomerang tasks) and persona-driven sub-workflows that act like subagents. MCP servers and custom modes can delegate specific responsibilities (running tests, managing containers, calling external APIs), enabling specialized subagent-like behavior for task-specific automation.","plainChildren":""}]}]},{"type":"header","level":2,"content":"CustomModes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Users can create specialist modes (personas) with custom instructions, file restrictions, model selections, and permission boundaries. Modes are configurable and can be tied to specific models or providers, allowing tailoring of the assistant for tasks like architecture review, QA, or refactoring.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"RooCode supports extension via MCP plugins/providers and integrates with multiple model providers. Teams can bundle together provider configurations, MCP servers, and custom modes to produce reusable plugin-like setups that encapsulate commands, tools, and integrations.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"RooCode implements checkpointing and diffs: it records change checkpoints (and ties into VS Code timeline/git workflows), shows diffs for review before applying edits, and allows reverting to previous states. Auto-approve settings can be gated with explicit checkpoints to prevent unwanted changes.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SpecDrivenDevelopment","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Other","plainChildren":""},{"type":"item","level":1,"content":"RooCode is an AI coding assistant/IDE extension rather than a spec-driven development framework. It does not ship with a native SDD framework, though it can be used alongside any spec-driven workflow (including Tessl or custom spec tools) by operating on the same workspace files and automating edits based on spec requirements.","plainChildren":""}]}]}],"sourcePath":"roo-code.md"},{"type":"header","level":1,"content":"Runner H - https://www.h.com/","children":[{"type":"text","content":"A web-focused autonomous agent that executes multi-step tasks via natural language, combining compact LLM planning with a vision-language model to interact with arbitrary web pages."},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"v0.9 (2024-05)"}]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Editor","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"[4] Strong web automation and visual robustness","plainChildren":""},{"type":"item","level":1,"content":"[3] Early-stage platform; limited public tooling and ecosystem","plainChildren":""}]}]},{"type":"header","level":2,"content":"Repository","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Python","plainChildren":""},{"type":"item","level":1,"content":"JavaScript","plainChildren":""},{"type":"item","level":1,"content":"Node.js","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"Runner H (from H Company) is an \"action-oriented\" autonomous web agent designed to perform complex, multi-step web tasks from simple natural-language instructions. It uses a compact reasoning LLM (H-LLM) to plan and orchestrate actions and a vision-language model (H-VLM / Holo-1) to visually interpret web pages and locate UI elements. The system is organized as a multi-agent stack (a master planner plus specialized sub-agents) that can run workflows, adapt to UI changes, and integrate with productivity tooling."}]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"LocalOffline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"FreeTrial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Limited beta access was offered during initial launch windows.","plainChildren":""}]}]},{"type":"header","level":2,"content":"GitSupport","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Terminal","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Holo-1 (the VLM) has open-source releases, but Runner H’s orchestration and hosted agent product is closed-source as of initial public information.","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Proprietary","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Core tech: H-LLM (compact ~2B model) for reasoning/planning and H-VLM (Holo-1) as Runner's visual \"eyes\". The stack emphasizes function-calling, planning decomposition, and visual grounding to interact with arbitrary web UIs.","plainChildren":""},{"type":"item","level":1,"content":"Strengths: excels at unstructured, multi-step web automation where traditional API-based integrations or brittle RPA selectors fail. Self-healing/visual adaptation reduces breakage when sites change.","plainChildren":""},{"type":"item","level":1,"content":"Integrations: native connectors for common productivity apps reported (e.g., Google Workspace, Slack, Notion) and extensibility via connectors like Zapier for additional app workflows.","plainChildren":""},{"type":"item","level":1,"content":"Use cases: data extraction across sites, automated form filling and onboarding, multi-site workflows (e-commerce, lead enrichment), and automated testing scenarios that require visual validation.","plainChildren":""},{"type":"item","level":1,"content":"Limitations: early-stage product with limited public SDK/repo; cloud-hosted—which may pose data residency or BYOK concerns for some organisations. Pricing and enterprise controls were evolving during early launches.","plainChildren":""},{"type":"item","level":1,"content":"Related projects: H Company also released Tester H (an AI testing agent) and Holo-1 (open-source VLM) which are part of the same ecosystem.","plainChildren":""}]}]},{"type":"header","level":2,"content":"ContextManagement","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Runner H manages context through session-scoped task state and planner-generated action sequences. The master planner decomposes user requests into subtasks, and the orchestrator + sub-agents maintain per-task state, step logs, and intermediate results. Users can update context via follow-up natural-language instructions, by editing task parameters/templates before execution, or through connectors that persist external state (e.g., Google Sheets or Drive). The platform also supports human-in-the-loop confirmations and QA checks that allow context correction mid-flight.","plainChildren":""}]}]},{"type":"header","level":2,"content":"DirectFileReferences","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Runner H can reference and operate on files through integrated connectors (e.g., Google Workspace—Drive/Sheets, Slack attachments) and by following supplied URLs. Files can be downloaded, parsed (including visual parsing via the VLM), uploaded to target services, and used as inputs to workflows. This is typically done via integrations rather than direct filesystem mounts.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Lifecycle events are available for task orchestration (examples: task_created / task_started / step_executed / step_failed / task_completed). Runner H exposes integration points via built-in connectors and third-party automation platforms (e.g., Zapier) and can emit webhooks or call external services at key events. These hooks support monitoring, approval gates, and downstream automation triggers.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"The platform supports reusable workflows/recipes (templates) that can be invoked on demand. These workflows can be triggered from the Runner H UI or via integrated apps (for example, Slack commands or scheduled jobs through connectors). Users can save common multi-step automations and re-run them as shorthand commands.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Runner H is explicitly built as a multi-agent stack: a master planner (orchestrator) plus specialized sub-agents (browsing, extraction, QA, error-recovery, integrations). Each subagent is optimized for a domain task and the orchestrator coordinates them to complete complex multi-step workflows.","plainChildren":""}]}]},{"type":"header","level":2,"content":"CustomModes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Users can create specialist modes/workflows by configuring custom agents, connectors, and templates. Extensibility is provided through connectors (Google Workspace, Slack, Zapier, etc.), custom workflow templates, and configuration of agent behaviors (e.g., QA thresholds, retry policies). During beta the public SDK surface is limited, but the product is designed to be extensible via connectors and workflow configuration.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Runner H supports a plugin-style integration model via connectors and automation integrations (Zapier, Google Workspace, Slack, webhooks). These bundle together commands, workflows (recipes), and event hooks so teams can package reusable automation bundles and integrate them into broader pipelines.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"The system records step-level logs and maintains run histories that provide the ability to review, replay, and intervene in task execution. There are human-in-the-loop approval gates and a QA/validation agent that can block or confirm changes before finalizing. While not a transactional \"database rollback\" in all cases, Runner H provides operational checkpoints, re-run/undo patterns, and error-recovery strategies to revert or correct actions performed by an agent.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SpecDrivenDevelopment","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Other","plainChildren":""},{"type":"item","level":1,"content":"No specific public spec-driven development framework (e.g., Tessl, BMAD, SpecKit) is documented for Runner H. The platform follows an agent- and workflow-driven architecture rather than a published spec-driven development methodology.","plainChildren":""}]}]}],"sourcePath":"runnerh.md"},{"type":"header","level":1,"content":"SourceAI - https://sourceai.dev","children":[{"type":"text","content":"[ An AI-powered web code generator that converts natural language prompts into working code across many programming languages ]"},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"v (2025-10-19)"}]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Editor","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Repository","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Any","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"SourceAI is a web-based AI code generation tool that accepts natural language requests and returns generated code snippets across many programming languages (Python, C, C++, Java, JavaScript, etc.). The service advertises a simple, one-click interface targeted at making code generation accessible to both developers and non-developers. It uses large language models to interpret user intent and produce runnable code examples."}]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"LocalOffline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"FreeTrial","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"GitSupport","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Terminal","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Proprietary","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Core positioning: simplicity and speed — focused on quick, natural-language-to-code generation rather than deep IDE integrations or collaboration features.","plainChildren":""},{"type":"item","level":1,"content":"Technology: public-facing site indicates use of large language models (public references list GPT-3 / Codex as underlying tech in marketing/third-party summaries).","plainChildren":""},{"type":"item","level":1,"content":"Limitations: public documentation is sparse. There is no clear information on pricing, enterprise features, private model keys (BYOK), repository or IDE integrations, or offline/local deployment options.","plainChildren":""},{"type":"item","level":1,"content":"Example (from site marketing): Python factorial generator for a user-input number (simple, illustrative use case).","plainChildren":""}]}]},{"type":"header","level":2,"content":"ContextManagement","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Public-facing documentation and the product site do not describe any structured context management APIs or persistent session/context update mechanisms (no docs found indicating context windows, memory, or programmatic context updates).","plainChildren":""}]}]},{"type":"header","level":2,"content":"DirectFileReferences","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"There is no public documentation indicating the ability to reference or mount repository files, upload project directories, or directly point the assistant at files in a codebase.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"No evidence in public docs of lifecycle hooks or event callbacks that external systems can attach to.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"The product appears to be a web UI code generator; there is no documentation of reusable slash-style commands or command registries exposed to users.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"No documentation or feature descriptions indicate support for defining or orchestrating specialized subagents for task-specific workflows.","plainChildren":""}]}]},{"type":"header","level":2,"content":"CustomModes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"No public information about creating specialist operational modes or presets beyond simple prompt templates or language selection.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"There is no documented plugin system, extension marketplace, or bundling mechanism for adding new capabilities to the service.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"No documented support for checkpoints, snapshot/undo features, or versioned state management for generated outputs.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SpecDrivenDevelopment","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Other","plainChildren":""},{"type":"item","level":1,"content":"No public evidence that SourceAI integrates with or promotes any formal spec-driven development frameworks (Tessl, SpecKit, OpenSpec, etc.). The product is positioned as a quick natural-language-to-code generator rather than a spec-driven development platform.","plainChildren":""}]}]}],"sourcePath":"sourceai_dev.md"},{"type":"header","level":1,"content":"Sourcegraph - https://sourcegraph.com","children":[{"type":"text","content":"A code intelligence platform for universal code search, navigation, large-scale refactors, and AI-assisted development (Cody)."},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"vN/A (2025-10-19)"}]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Editor","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"[5] Powerful multi-repo code search and navigation at scale","plainChildren":""},{"type":"item","level":1,"content":"[4] Strong enterprise features (batch changes, code insights, self-hosting)","plainChildren":""},{"type":"item","level":1,"content":"[3] License and governance concerns after relicensing/private repo move","plainChildren":""}]}]},{"type":"header","level":2,"content":"Repository","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"https://github.com/sourcegraph/sourcegraph-public-snapshot","plainChildren":""},{"type":"item","level":1,"content":"note: core repo made private Aug 2024; public snapshot available historically)","plainChildren":""}]}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Any","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Integrations: IDE plugins (VS Code, JetBrains, Visual Studio, Eclipse), browser extensions, code host integrations (GitHub, GitLab, Bitbucket), API and webhooks, app/extensions framework","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"Sourcegraph is a platform that provides precise, scalable code search and code navigation across many repositories, languages and code hosts. Core capabilities include universal code search, cross-repository symbol navigation (go-to-definition, find-references), Batch Changes for large-scale automated code edits, Code Insights dashboards, and an integrated AI assistant called Cody which provides context-aware code help and multi-repo reasoning inside IDEs and a chat interface. Deployments can be self-hosted (on-prem) or Sourcegraph Cloud."}]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Sourcegraph Cloud does not publicly advertise a generic BYOK feature; however self-hosted deployments give organizations full control over their infrastructure and encryption boundaries.","plainChildren":""}]}]},{"type":"header","level":2,"content":"LocalOffline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Self-hosted deployments support offline/private hosting and do not require sending code to Sourcegraph cloud. This is a common choice for enterprises with strict data residency or security requirements.","plainChildren":""}]}]},{"type":"header","level":2,"content":"FreeTrial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Free tier/self-hosted free edition for small teams and public code; paid Business/Enterprise plans for larger teams and advanced features.","plainChildren":""}]}]},{"type":"header","level":2,"content":"GitSupport","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Deep integrations with Git-based hosts and workflows; built to index and search Git repositories at scale.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Terminal","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"CLI tooling (e.g., src CLI / developer tools) and integrations that allow scripted interactions and automation.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Historically Apache 2.0 (OSS) until 2023; in 2023–2024 Sourcegraph moved large portions of the project to an enterprise/proprietary license and in Aug 2024 made the core repository private. Some related projects (e.g., parts of Cody or community tooling) remain open source.","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Proprietary","plainChildren":""},{"type":"item","level":1,"content":"Sourcegraph Enterprise (formerly Apache 2.0 for much of the codebase prior to relicensing)","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Cody and the AI integrations support bringing multi-repo and file-context into model prompts (context-enhanced chat); suitable for advanced, model-backed code assistance workflows.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Strengths:","plainChildren":""},{"type":"item","level":1,"content":"Exceptional at searching and navigating very large mono-repos and multi-repo organizations.","plainChildren":""},{"type":"item","level":1,"content":"Batch Changes enables safe, auditable, large-scale automated refactors across repositories.","plainChildren":""},{"type":"item","level":1,"content":"Code Insights provide queryable metrics and dashboards for engineering metrics (migrations, ownership, adoption tracking).","plainChildren":""},{"type":"item","level":1,"content":"Cody adds AI-assisted code understanding and generation with multi-repo context.","plainChildren":""},{"type":"item","level":1,"content":"Self-hosted deployment gives full data control for security-conscious organizations.","plainChildren":""},{"type":"item","level":1,"content":"Considerations:","plainChildren":""},{"type":"item","level":1,"content":"Licensing and openness: Sourcegraph transitioned away from Apache 2.0 and made core components proprietary/private in 2023–2024; this has community and vendor-lock-in implications to evaluate.","plainChildren":""},{"type":"item","level":1,"content":"Cloud vs self-hosted: Cloud provides convenience and managed features but requires trust in vendor; self-hosting removes that but adds operational overhead.","plainChildren":""},{"type":"item","level":1,"content":"Pricing: multiple tiers (free/self-hosted free edition, Business, Enterprise, and Cody-specific tiers). Confirm current pricing with Sourcegraph sales or website for up-to-date details.","plainChildren":""},{"type":"item","level":1,"content":"Useful links / reading:","plainChildren":""},{"type":"item","level":1,"content":"Product: https://sourcegraph.com","plainChildren":""},{"type":"item","level":1,"content":"Company: https://about.sourcegraph.com","plainChildren":""},{"type":"item","level":1,"content":"Historical repo (public snapshot / info): https://github.com/sourcegraph/sourcegraph (status may be private)","plainChildren":""},{"type":"item","level":1,"content":"News/discussion about relicensing and repo privatization: public coverage across developer news sites and community threads (June 2023 – Aug 2024 timeline)","plainChildren":""},{"type":"item","level":1,"content":"When to choose Sourcegraph:","plainChildren":""},{"type":"item","level":1,"content":"You need precise, enterprise-grade code search and cross-repo navigation across thousands of repositories and many languages.","plainChildren":""},{"type":"item","level":1,"content":"You require large-scale automated code changes (Batch Changes) or engineering metrics (Code Insights).","plainChildren":""},{"type":"item","level":1,"content":"You need an AI assistant that can reason across multiple repositories and provide actionable code suggestions (Cody), and you can accept the vendor/license model.","plainChildren":""}]}]},{"type":"header","level":2,"content":"ContextManagement","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Sourcegraph provides multiple methods for managing and updating context:","plainChildren":""},{"type":"item","level":1,"content":"Search contexts: user-defined or admin-defined named sets of repositories and revisions that limit and focus searches and context retrieval.","plainChildren":""},{"type":"item","level":1,"content":"Cody context retrieval: blends keyword search and embedding-based semantic search to select relevant files and snippets for prompts (local file context, open repository context, and remote codebase context via the indexed Sourcegraph instance).","plainChildren":""},{"type":"item","level":1,"content":"Indexing and re-indexing: Sourcegraph continuously indexes repositories; re-indexing keeps file-level and symbol-level context up to date for accurate retrieval.","plainChildren":""},{"type":"item","level":1,"content":"Repository-level configuration: external services and repository sync settings (repos, repositoryQuery, exclude, excludePersonalRepositories) influence what code is available for context.","plainChildren":""}]}]},{"type":"header","level":2,"content":"DirectFileReferences","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Files can be directly referenced in context via Sourcegraph's code search URLs, search contexts, and repository path references. Cody can include specific files/snippets from the Sourcegraph index into prompts; users and integrations can pass file paths or results from search queries to the assistant.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Sourcegraph exposes lifecycle- and integration-related events via external service syncing and webhook mechanisms (note: the `webhooks` property on external service config has been deprecated in favor of dedicated webhook configuration docs). Webhooks enable event-driven updates for repository changes used by features like code monitoring, and Sourcegraph maintains observability for external HTTP requests.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Sourcegraph supports CLI tooling (the `src` CLI and other developer tools) and IDE/browser extension commands that can be triggered by users; while not \"slash commands\" in the chat app sense, integrations and the Cody assistant expose actionable commands and workflows inside IDEs and the web UI.","plainChildren":""},{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Sourcegraph/Cody architecture supports specialized retrieval and LLM components that act like subagents: semantic retrievers (embeddings), keyword search, and completion-tuned LLMs for chat, code action generation, and multi-repo reasoning. Enterprises can deploy dedicated Cody instances (e.g., self-hosted Cody Enterprise) for tailored workflows.","plainChildren":""}]}]},{"type":"header","level":2,"content":"CustomModes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Cody and Sourcegraph provide configurable behaviors via deployment choices (self-hosted vs cloud), search contexts, user-defined settings, and extension points. This enables tailoring the assistant's behavior and retrieval scope for specific teams or workflows.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Sourcegraph provides an extensions framework, IDE plugins, and integrations for IDEs (VS Code, JetBrains, Visual Studio) and code hosts (GitHub, GitLab, Bitbucket). These bundle commands, search capabilities, and code intelligence features that operate together with Cody and the platform.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Sourcegraph's Batch Changes and code change workflows are designed to be auditable and reversible through version control. Administrators can rely on Git history and repository state to revert changes; self-hosted deployments provide full control over commit histories. There is also support for observability and monitoring of external requests.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SpecDrivenDevelopment","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Other","plainChildren":""},{"type":"item","level":1,"content":"[\"Sourcegraph uses a combination of RAG, embeddings and long-context experiments rather than a single spec-driven tool.\"]","plainChildren":""}]}]}],"sourcePath":"sourcegraph.md"},{"type":"header","level":1,"content":"Supermaven - https://www.supermaven.com","children":[{"type":"text","content":"AI-first code completion assistant focused on very large context windows, low-latency completions, and deep codebase understanding."},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"v (2025-10-19)"}]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Editor","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"[5] Performance & speed (sub-300ms completion latency in reported benchmarks)","plainChildren":""},{"type":"item","level":1,"content":"[4] Context awareness & long-range understanding (very large context window enables whole-repo reasoning)","plainChildren":""}]}]},{"type":"header","level":2,"content":"Repository","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Any","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Integrates with major IDEs (VS Code, JetBrains, Neovim) and offers chat integrations; product roadmap and integrations may expand","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"Supermaven is an AI-powered code completion and developer-assistant platform built to provide ultra-fast, context-aware code suggestions across large codebases. It uses a proprietary neural architecture (not a vanilla transformer) optimized for very large context windows and low-latency token generation. Supermaven emphasizes developer flow by surfacing near-instant completions, \"next location\" predictions (jumping to the file/spot where changes are needed), and an AI chat interface tailored to code review, diffs and codebase attachments."}]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"LocalOffline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"FreeTrial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"GitSupport","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Integrates with IDEs and understands repository context; includes features that operate across the repo and work with recent edits","plainChildren":""}]}]},{"type":"header","level":2,"content":"Terminal","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Primary integrations are editor/IDE plugins; Supermaven also provides its own editor/IDE experience rather than a terminal-first tool","plainChildren":""}]}]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Proprietary","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Key differentiators: extremely large context window (public claims up to 1,000,000 tokens in marketing material), very low latency (reported ~250ms), and \"next location prediction\" that can jump to the file/line where the assistant thinks a change belongs.","plainChildren":""},{"type":"item","level":1,"content":"Integrations: official support for Visual Studio Code, JetBrains family of IDEs, and Neovim. Also offers an integrated editor/IDE built around the Supermaven assistant.","plainChildren":""},{"type":"item","level":1,"content":"Models & chat: Supermaven runs its own inference for completions and provides a chat interface that can surface large-context diffs; some product messaging references integrations with third-party models for chat features.","plainChildren":""},{"type":"item","level":1,"content":"Pricing (public tiers, subject to change): Free tier available; Standard plan and Pro plan historically reported at roughly $18/month and $29/month respectively; enterprise plans available for organizations.","plainChildren":""},{"type":"item","level":1,"content":"Best fit: developers and teams working on medium-to-large codebases who need fast, context-rich completions and cross-file reasoning (e.g., refactors, large feature work, legacy code maintenance).","plainChildren":""},{"type":"item","level":1,"content":"Limitations/considerations: proprietary/cloud-hosted service (no confirmed fully offline/self-hosted option), potential privacy and compliance considerations for sensitive code — review enterprise offerings and data handling policies before adoption.","plainChildren":""}]}]},{"type":"header","level":2,"content":"ContextManagement","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Supermaven manages and surfaces context via whole-repo indexing and a very large context window (marketing claims up to ~1,000,000 tokens). Available methods include: workspace/repository indexing, capturing recent edits and file diffs, chat session history (conversation context), and cross-file analysis (\"next location\"/file jump features) so completions are informed by project-wide state.","plainChildren":""}]}]},{"type":"header","level":2,"content":"DirectFileReferences","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Supermaven can reference files directly: its IDE integrations allow jumping to files/lines, attaching files or diffs inside the assistant chat, and applying suggested edits as diffs. The system is explicitly designed to reason over repository files rather than single-file completions.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Public documentation does not describe a user-facing lifecycle hook API for attaching custom event handlers. Integration points are primarily IDE plugin entry points (actions, hotkeys) rather than a documented agent lifecycle hook system.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"While the product exposes hotkeys and chat-driven actions (apply-change, show-diff, jump-to-file), there is no widely-documented generic \"slash command\" system for reusable, user-defined commands in the public docs — behavior is primarily via the chat UI and IDE command palette/hotkeys.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Supermaven provides multi-model chat and specialized behaviors (completion vs. chat) but does not document a facility for users to define autonomous subagents/workflows. There is no public API for composing persistent task-specific subagents.","plainChildren":""}]}]},{"type":"header","level":2,"content":"CustomModes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"There is no public indication that users can author custom assistant modes; available modes are product-provided (completion, chat, refactor suggestions). Customization is via settings and IDE integration rather than creating new assistant modes.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Supermaven ships as IDE plugins (VS Code, JetBrains, Neovim) but it does not advertise a plugin ecosystem for bundling agent behaviors, commands and hooks as user-installable extensions. Integration is through the official plugins rather than a third-party plugin marketplace.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Agent-driven changes are presented as diffs and edits that can be previewed before applying; once applied typical safety nets exist (IDE undo, local VCS/git history). For teams using CI or repo protection, any autocommit workflows would still be revertable through standard git history.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SpecDrivenDevelopment","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Other","plainChildren":""},{"type":"item","level":1,"content":"Not applicable — Supermaven is a developer productivity/code-completion platform, not a spec-driven development framework. It does not advertise alignment with or tooling for the listed spec-driven development systems.","plainChildren":""}]}]}],"sourcePath":"supermaven.md"},{"type":"header","level":1,"content":"Tabby - https://tabby.tabbyml.com","children":[{"type":"text","content":"An open-source, self-hosted AI coding assistant for local code completion and chat."},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"v0.x (2025-10-19)"}]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Editor","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"[4] Strong privacy and self-hosting features (good for sensitive codebases)","plainChildren":""},{"type":"item","level":1,"content":"[4] Good IDE integration and model flexibility, still maturing UX compared to large commercial offerings","plainChildren":""}]}]},{"type":"header","level":2,"content":"Repository","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"https://github.com/TabbyML/tabby","plainChildren":""}]}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Rust","plainChildren":""},{"type":"item","level":1,"content":"TypeScript","plainChildren":""},{"type":"item","level":1,"content":"JavaScript","plainChildren":""},{"type":"item","level":1,"content":"Python","plainChildren":""},{"type":"item","level":1,"content":"Shell","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"Tabby is a self-hosted, open-source AI coding assistant that provides code completion, conversational code chat, and repository-aware suggestions. It is designed to run on your infrastructure (local machine, private cloud, or hosted VMs) and supports multiple LLM backends (e.g., CodeLlama, StarCoder, Ollama-managed models). Tabby focuses on data sovereignty, low-latency completions via adaptive caching and Tree-sitter based context extraction, and editor integrations (VS Code, Neovim/Vim, etc.)."}]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"LocalOffline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Can run fully offline/self-hosted (Docker, from-source). Supports connecting to local model servers such as ollama/llama.cpp backends or on-prem inference stacks.","plainChildren":""}]}]},{"type":"header","level":2,"content":"FreeTrial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Community edition is free & open-source; Team/Enterprise tiers exist commercially for additional features/support.","plainChildren":""}]}]},{"type":"header","level":2,"content":"GitSupport","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Terminal","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Server and agent provide CLI tools; Docker image and direct binary available for server usage.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Apache License 2.0","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Self-hosted alternative to cloud assistants (e.g., Copilot) with emphasis on privacy and repository context.","plainChildren":""},{"type":"item","level":1,"content":"Works with a variety of model backends and allows teams to \"bring your own model\" or provider (BYOM/BYOK).","plainChildren":""},{"type":"item","level":1,"content":"Provides IDE integrations (official and community) for VS Code, Neovim/Vim, and other editors.","plainChildren":""},{"type":"item","level":1,"content":"Quickstart via Docker for local GPU-enabled deployments; building from source requires Rust and native deps.","plainChildren":""},{"type":"item","level":1,"content":"Community edition = Apache-2.0 licensed; Team/Enterprise editions add commercial capabilities.","plainChildren":""},{"type":"item","level":1,"content":"Best experience with access to GPU-backed inference or fast local model runners; smaller models usable for lightweight setups.","plainChildren":""}]}]}],"sourcePath":"tabby.md"},{"type":"header","level":1,"content":"Tabnine - https://www.tabnine.com","children":[{"type":"text","content":"AI-powered code completion and developer assistant focused on privacy and enterprise deployment"},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"v(enterprise/cloud) (2025-10-19)"}]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Editor","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"[4] Strong for enterprises that require data privacy and on-prem deployment","plainChildren":""},{"type":"item","level":1,"content":"[3] Good code-completion quality; real-world accuracy varies by codebase","plainChildren":""}]}]},{"type":"header","level":2,"content":"Repository","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Python","plainChildren":""},{"type":"item","level":1,"content":"JavaScript","plainChildren":""},{"type":"item","level":1,"content":"TypeScript","plainChildren":""},{"type":"item","level":1,"content":"Java","plainChildren":""},{"type":"item","level":1,"content":"C#","plainChildren":""},{"type":"item","level":1,"content":"Go","plainChildren":""},{"type":"item","level":1,"content":"Rust","plainChildren":""},{"type":"item","level":1,"content":"PHP","plainChildren":""},{"type":"item","level":1,"content":"C/C++","plainChildren":""},{"type":"item","level":1,"content":"Other","plainChildren":""},{"type":"item","level":1,"content":"Many other popular languages (wide IDE/language support)","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"Tabnine is a commercial AI coding assistant that emphasizes privacy, flexible deployment, and broad IDE coverage. It provides context-aware inline code completions, an in-IDE chat for code explanation and refactoring, and organization-aware suggestions that learn from your repository and coding patterns. Tabnine targets teams and enterprises that need strong data governance — offering private, on-premises, VPC, and air-gapped deployment models as well as local model execution options so source code can be kept inside controlled environments."}]},{"type":"header","level":2,"content":"BYOK","children":[]},{"type":"header","level":2,"content":"LocalOffline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Supports local model execution and private/on-prem deployments. Offers VPC and air-gapped installation options for organizations with strict data residency and compliance requirements.","plainChildren":""}]}]},{"type":"header","level":2,"content":"FreeTrial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Any additional details: Tabnine sunset its free Basic plan in 2025; access is primarily through paid tiers or enterprise licensing. Trial or pilot options may still be available via sales.","plainChildren":""}]}]},{"type":"header","level":2,"content":"GitSupport","children":[]},{"type":"header","level":2,"content":"Terminal","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Proprietary","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[]},{"type":"header","level":2,"content":"Notes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Strengths: strong privacy and governance features (SSO/SAML, SCIM, role-based access controls), flexible deployment (cloud, private cloud/VPC, on-prem, air-gapped), broad IDE support (VS Code, JetBrains IDEs, Visual Studio), and organization-aware completions that learn project patterns.","plainChildren":""},{"type":"item","level":1,"content":"Limitations: free/basic tier availability was reduced in 2025; on-prem/self-hosted deployments require operational expertise (Kubernetes, infra); most public performance benchmarks are vendor-provided — evaluate with a pilot before enterprise-wide roll-out.","plainChildren":""},{"type":"item","level":1,"content":"Ideal for: regulated industries (finance, healthcare, government, defense) and organizations that need data residency guarantees and enterprise governance.","plainChildren":""}]}]},{"type":"header","level":2,"content":"ContextManagement","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Tabnine maintains and uses workspace context through a local project index and live file analysis. Methods for managing and updating context include:","plainChildren":""},{"type":"item","level":1,"content":"Workspace indexing: Tabnine scans and indexes files in the opened project to provide organization-aware suggestions.","plainChildren":""},{"type":"item","level":1,"content":"Include/exclude patterns: Users can configure which folders/files to exclude from indexing (via IDE plugin settings) to limit or focus context.","plainChildren":""},{"type":"item","level":1,"content":"Re-index / refresh: IDE settings provide ways to re-index or refresh the local project index when the codebase changes.","plainChildren":""},{"type":"item","level":1,"content":"Privacy controls: Enterprise and local deployments allow toggling whether code is sent to cloud models or kept local, which affects what context is available to cloud vs local models.","plainChildren":""},{"type":"item","level":1,"content":"Model selection and scope: Admin-level settings in enterprise deployments can control which models are used and whether organizational learning (repository-level learning) is enabled.","plainChildren":""}]}]},{"type":"header","level":2,"content":"DirectFileReferences","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Tabnine consumes the indexed workspace and open-file contents as direct input for completions. Ways files can be referenced in context:","plainChildren":""},{"type":"item","level":1,"content":"Implicit referencing: The completion engine automatically uses related files from the indexed workspace (imports, definitions, tests) to inform suggestions.","plainChildren":""},{"type":"item","level":1,"content":"Editor-driven references: Opening a file or selecting text in the IDE surfaces that content to the completion/chat features; pasting file content into the chat or prompt allows explicit use of that file's contents.","plainChildren":""},{"type":"item","level":1,"content":"Configuration controls: Include/exclude and scope settings control which files are considered part of the context. There is no documented API to request a file by arbitrary path inside the assistant prompt — use the editor or paste contents into the chat for explicit, ad-hoc references.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"CustomModes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"While Tabnine does not provide a user-facing \"create-your-own-agent\" framework, it exposes configurable modes and behavior controls that let teams tailor the assistant experience:","plainChildren":""},{"type":"item","level":1,"content":"Completion behaviour settings: Options for whole-line vs single-token suggestions, multiline completions, and acceptance behavior.","plainChildren":""},{"type":"item","level":1,"content":"Model & deployment choices: Switch between local, private cloud, or vendor-hosted models; enterprise customers can enable organizational/model training or restrict to local models.","plainChildren":""},{"type":"item","level":1,"content":"Policy & privacy settings: Admin-enforced policies (data-sharing, telemetry, model training opt-outs) alter how the assistant behaves across projects.","plainChildren":""},{"type":"item","level":1,"content":"Workspace configuration: Per-project settings (exclude paths, language-level tuning) effectively produce different operational \"modes\" per repo.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"SpecDrivenDevelopment","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Other","plainChildren":""},{"type":"item","level":1,"content":"Tabnine does not natively implement a spec-driven development framework. It is workflow-agnostic and can be used alongside SDD tools (Tessl, OpenSpec, etc.) but offers no built-in spec-to-code or spec-management features. Enterprise customers can integrate Tabnine into their development workflows (including spec-driven ones) by configuring model training, repository indexing, and IDE settings to align with SDD practices.","plainChildren":""}]}]}],"sourcePath":"tabnine.md"},{"type":"header","level":1,"content":"Theia - https://theia-ide.org","children":[{"type":"text","content":"Eclipse Theia: a modular, extensible, open-source IDE framework for desktop and cloud."},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"v1.65 (2025-10-19)"}]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Editor","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"[5] Strong open-source, vendor-neutral alternative to proprietary IDEs","plainChildren":""},{"type":"item","level":1,"content":"[4] Highly extensible and VS Code extension compatible (via Open VSX)","plainChildren":""},{"type":"item","level":1,"content":"[3] AI-native features matured rapidly in 2025 but still evolving for some production scenarios","plainChildren":""}]}]},{"type":"header","level":2,"content":"Repository","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"https://github.com/eclipse-theia/theia","plainChildren":""}]}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Any","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Modular architecture designed for composing custom IDEs and integrating extensions (supports VS Code extensions via Open VSX)","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"Eclipse Theia is an open-source, modular IDE framework maintained under the Eclipse Foundation. It targets both desktop and cloud IDE scenarios and is designed to be embedded and extended to build tailored developer tools. Theia uses the Monaco editor and the Language Server Protocol (LSP) for language support, is implemented primarily in TypeScript/Node, and aims to provide a vendor-neutral alternative to commercial IDEs while offering compatibility with much of the VS Code extension ecosystem."}]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Theia AI and integrations follow a bring-your-own-key / bring-your-own-model philosophy: you can configure external LLM providers or self-hosted models (e.g., Ollama, LlamaFile, hosted Anthropic/OpenAI keys) depending on deployment and data-control needs.","plainChildren":""}]}]},{"type":"header","level":2,"content":"LocalOffline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Theia can run locally as a desktop app or be self-hosted on-premise. Its AI integrations support local/offline models (where supported by the chosen model runtime) enabling air-gapped or privacy-sensitive deployments.","plainChildren":""}]}]},{"type":"header","level":2,"content":"FreeTrial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Theia is free/open-source (no trials); commercial services built on top of it may have separate licensing/pricing.","plainChildren":""}]}]},{"type":"header","level":2,"content":"GitSupport","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Native Git support via extensions (benefits from VS Code extension ecosystem). Git tooling, source control views and integrations are commonly added through Open VSX extensions.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Terminal","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Integrated terminal available (desktop & web). AI features add inline assistance in terminals in recent AI-enabled builds.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"EPL-2.0","plainChildren":""},{"type":"item","level":1,"content":"Eclipse Public License 2.0 (EPL-2.0)","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Compatibility: Theia aims for compatibility with the VS Code extension ecosystem via Open VSX and the Monaco editor, while remaining a distinct, vendor-neutral project (not a fork of VS Code).","plainChildren":""},{"type":"item","level":1,"content":"AI-native: In 2025 Theia added and matured AI-native capabilities (Theia AI framework), including context-aware assistants, multi-agent workflows, richer image support and native Claude Code IDE integration (1.65).","plainChildren":""},{"type":"item","level":1,"content":"Deployment: Flexible deployment as desktop app (Electron), web-hosted IDE, or embedded component inside platform products.","plainChildren":""},{"type":"item","level":1,"content":"Language support: Broad LSP-based language coverage; good fit for polyglot projects.","plainChildren":""},{"type":"item","level":1,"content":"Governance: Backed by the Eclipse Foundation which provides vendor-neutral stewardship.","plainChildren":""},{"type":"item","level":1,"content":"Use cases: Organizations that need a customizable, self-hosted IDE with strong extension and AI-integration options (especially where data control and on-prem deployment matter) will find Theia well-suited.","plainChildren":""},{"type":"item","level":1,"content":"Caveats: While AI features advanced rapidly in 2025, some integrations and workflows remain actively evolving—evaluate maturity for critical production use and test the specific provider/model setup you plan to use.","plainChildren":""}]}]},{"type":"header","level":2,"content":"ContextManagement","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Theia provides multiple, well-defined mechanisms for managing and updating context: workspace scopes (user/workspace/folder) for preferences; a WorkspaceService and WorkspaceState for persisting extension-specific data; context keys and keybinding/menu \"when\" expressions to gate UI and commands; editor/selection/active widget context propagated by the frontend; and programmatic APIs (e.g. ContextKeyService, PreferenceService, WorkspaceService) that extensions use to observe and update context.","plainChildren":""}]}]},{"type":"header","level":2,"content":"DirectFileReferences","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Theia exposes direct file and URI APIs for referencing and manipulating files: FileSystem/FileSystemProvider (backend), URI objects, WorkspaceService for workspace roots, and EditorManager/EditorOpener for opening files. Extensions typically use these services to resolve file paths, create/open editors (EditorManager.open(uri)), and watch file changes (FileSystem.watch). Theia also interoperates with VS Code-style URIs when using VS Code plugins.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Theia provides lifecycle and contribution hooks via well-known contribution interfaces: FrontendApplicationContribution (initialize, onStart, onStop), BackendApplicationContribution, CommandContribution, MenuContribution, KeybindingContribution, and LanguageClient contributions. Extensions register disposables and use activation events (commands, file types, workspace events) to run code at specific lifecycle points. There are also workspace events (onDidChangeWorkspace, onWillSaveTextDocument, onDidChangeTextDocument) and backend/frontend RPC lifecycle hooks.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Theia has a first-class commands system. Extensions declare commands via CommandContribution and register handlers with CommandRegistry; commands appear in the Command Palette and can be bound to keybindings or menus. Users can manually trigger commands from the palette, context menus, or keybindings. Commands can be enabled/disabled via context expressions and can execute either frontend logic or delegate work to the backend/container.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"While Theia does not mandate a specific \"AI subagent\" framework, it fully supports implementing specialized subagents via extensions: backend services or microservices (HTTP/WebSocket/RPC) that host LLMs or agent orchestration, frontend contributions that present agent UIs (views, webviews, quick-open), and integration points for multi-agent workflows (task APIs, terminals, debug adapters). Projects like Theia AI (and other community extensions) demonstrate how to implement multi-agent assistants and orchestrate them from Theia extensions.","plainChildren":""}]}]},{"type":"header","level":2,"content":"CustomModes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Theia supports custom \"modes\" through language/monaco registrations, custom editors, themes, keymaps, and preference scopes. Extensions can register language contributions (syntax, tokens, language IDs), Monaco editor modes, and view/editor behavior, enabling specialist modes tailored for tasks (e.g., embedded development, data science notebooks, AI copilots).","plainChildren":""}]}]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Theia bundles commands, contributions, and lifecycle hooks via the extension/package model. An extension is packaged with frontend and optional backend parts and declares contribution points (commands, menus, views, preferences) in its package.json. Theia also supports VS Code-style plugins (via the plugin extension) and Open VSX packaging to reuse existing VS Code extensions.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Theia provides several mechanisms that function as checkpoints or enable recovery: workspace state persistence (open editors, layout), crash/restart recovery, cloud/workspace snapshots in managed deployments, and extensible local-history or snapshot extensions. For source-controlled checkpoints, Theia integrates with Git extensions (commit/branch/rollback) so users can revert changes via standard VCS workflows. For richer checkpoint semantics, authors typically add an extension (local history, snapshotting service, or backend snapshot API).","plainChildren":""}]}]},{"type":"header","level":2,"content":"SpecDrivenDevelopment","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Tessl","plainChildren":""},{"type":"item","level":1,"content":"Theia itself is an IDE framework and does not enforce a particular spec-driven development tool, but it is compatible with SDD workflows. In projects that use Tessl (like this repo), Theia can be extended to surface Tessl specs, run Tessl tools via tasks/terminals, and provide editor integrations (syntax highlighting, quick actions) for Tessl-managed specs.","plainChildren":""}]}]}],"sourcePath":"theia.md"},{"type":"header","level":1,"content":"Trae AI - https://trae.ai","children":[{"type":"text","content":"A modern AI-powered IDE and coding assistant (\"The Real AI Engineer\") focused on end-to-end developer workflows, built as a VS Code fork with multimodel access and autonomous builder/agent modes."},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"v1.3.0 (2025-04-xx)"}]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Editor","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"[5] Strong end-to-end workflow and multimodel access","plainChildren":""},{"type":"item","level":1,"content":"[4] Excellent web/dev tooling and deployment integration","plainChildren":""},{"type":"item","level":1,"content":"[4] Rapid feature development but proprietary with privacy considerations","plainChildren":""}]}]},{"type":"header","level":2,"content":"Repository","children":[{"type":"text","content":"-"}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Any","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"Trae is an AI-first IDE intended to act as a full software engineering partner rather than only a completion tool. It is a fork of Visual Studio Code, so extensions, shortcuts and editor familiarity carry over. Trae provides multimodel access (examples: Claude 3.7 Sonnet, GPT-4o, Gemini 2.5 Pro in early releases), integrated chat, builder/agent modes that plan and execute multi-file changes, SOLO mode for autonomous project delivery, and one-click web deployment (Vercel). It emphasizes planning-first workflows (Builder Mode) and agent-driven automation (SOLO and custom agents), plus multimodal inputs (screenshots/designs) and a bilingual interface (English and Simplified Chinese)."}]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"LocalOffline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Trae runs cloud models and does not currently advertise a fully local/offline mode","plainChildren":""}]}]},{"type":"header","level":2,"content":"FreeTrial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"As of early 2025 Trae was distributed free with access to several premium models included","plainChildren":""}]}]},{"type":"header","level":2,"content":"GitSupport","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Terminal","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Proprietary","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Model Context Protocol support added in v1.3.0 to enable custom agents and richer context handling","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Built on VS Code so migration is low-friction for users of VS Code or Cursor.","plainChildren":""},{"type":"item","level":1,"content":"Distinguishing features: Builder Mode (planning + controlled execution), SOLO Mode (autonomous project creation), multimodel access, and one-click Vercel deploys.","plainChildren":""},{"type":"item","level":1,"content":"Strong emphasis on end-to-end web development workflows with integrated previews, browser/webview support, and terminal integration.","plainChildren":""},{"type":"item","level":1,"content":"Supports multimodal inputs (screenshots, design assets) to inform coding and debugging.","plainChildren":""},{"type":"item","level":1,"content":"Privacy/Trust considerations: Proprietary product with cloud-hosted model usage — review organizational policy before use in sensitive codebases.","plainChildren":""},{"type":"item","level":1,"content":"Competitive positioning: Targets Cursor and GitHub Copilot users but differentiates on zero-cost premium-model access, autonomous agent flows, and built-in deployment tooling.","plainChildren":""}]}]},{"type":"header","level":2,"content":"ContextManagement","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"[Trae maintains and updates context using a combination of codebase indexing, persistent project \"rules\" files, and Model Context Protocol (MCP) sessions. The IDE indexes repository files and open buffers to provide file-level and project-level context to agents; rules/metadata files persist project conventions and preferences so the agent remembers them across sessions; MCP enables explicit context objects to be attached to agent calls (scoped contexts for tasks, file lists, or external resources). The Builder/ SOLO flows present \"execution previews\" before changes are applied so users can review and refine context or constraints.]","plainChildren":""},{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"DirectFileReferences","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"[Files can be directly referenced via the editor and agent commands: the Builder/agent can accept file paths or scoped file selections, the chat supports inline file references and #Context-like selectors, and the system indexes files so agents can open, diff, and patch specific files. Editor integration also permits selecting an open file or range to provide explicit context to the agent.]","plainChildren":""},{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"[Trae exposes lifecycle checkpoints in its planning+execution model: planning / preview (\"think-before-doing\"), execution (apply changes), deploy, and error/rollback. Through MCP-custom agents and the Builder API, users can attach pre-plan constraints, intercept previews, validate planned modifications, and trigger post-execution actions (e.g., run tests or create commits). While exact hook names/SDK methods depend on Trae's MCP client implementation, these lifecycle attachment points are available conceptually and via custom agents.]","plainChildren":""},{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"[Trae supports natural-language command syntax and special inline/directives (examples reported: @Agent, #Context) and provides chat/command surfaces (sidebar/inline). These act like reusable, user-invoked commands and can be used to scope agent behavior, request specific actions, or switch modes (e.g., invoking Builder or SOLO).]","plainChildren":""},{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"[Trae enables specialized subagents via the MCP client and custom agent definitions (SOLO, Builder, and user-defined agents). Users can create task-specific agents (e.g., testing agent, refactor agent, deploy agent) that encapsulate particular workflows and tool access scopes; these subagents can be invoked from the main Builder flow or chat.]","plainChildren":""},{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"CustomModes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"[Trae provides multiple specialist modes out-of-the-box (Builder Mode, SOLO Mode, SOLO Builder) and supports creating tailored workflows via custom agents and MCP-driven sessions. Modes change how the agent plans, previews, and executes changes (manual-review vs autonomous execution), and can be switched by command or configuration.]","plainChildren":""},{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"[Trae supports extensions and plugin-like integration via its VS Code ancestry (VS Code extensions compatibility) and by exposing MCP for bundling agent behaviors and tool integrations. Developers can package commands, agents, and hook logic in extension form or via MCP client modules to compose reusable feature bundles.]","plainChildren":""},{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"[Trae provides undo and checkpointing through several mechanisms: execution previews (inspect changes before apply), native Git/VCS integration (stage/commit/checkout to revert), and the Builder's planned-change workflow which can be canceled or rolled back. These combined affordances let teams undo agent actions or restore prior states.]","plainChildren":""},{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"SpecDrivenDevelopment","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"BMAD","plainChildren":""},{"type":"item","level":1,"content":"SpecKit","plainChildren":""},{"type":"item","level":1,"content":"OpenSpec","plainChildren":""},{"type":"item","level":1,"content":"Tessl","plainChildren":""},{"type":"item","level":1,"content":"AgentOS","plainChildren":""},{"type":"item","level":1,"content":"ClaudeFlow","plainChildren":""},{"type":"item","level":1,"content":"SPARC","plainChildren":""},{"type":"item","level":1,"content":"SuperClaude","plainChildren":""},{"type":"item","level":1,"content":"Other","plainChildren":""},{"type":"item","level":1,"content":"[Trae is not tied to a specific spec-driven development framework. It integrates with project rules/metadata and MCP-driven agents so it can be used alongside spec-driven workflows (including Tessl or other frameworks) but does not formally implement or require one of the listed SDD frameworks.]","plainChildren":""}]}]}],"sourcePath":"trae.md"},{"type":"header","level":1,"content":"Void Editor - http://voideditor.com","children":[{"type":"text","content":"Open-source, privacy-first AI code editor built as a fork of Visual Studio Code that connects directly to LLMs (local or cloud) without routing data through a private backend. "},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"v0.1 (2025-01 beta)"}]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Editor","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"[4] Strong privacy and model-flexibility design","plainChildren":""},{"type":"item","level":1,"content":"[4] Rapidly evolving; Beta early UX rough edges","plainChildren":""}]}]},{"type":"header","level":2,"content":"Repository","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"https://github.com/voideditor/void","plainChildren":""}]}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Any","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"Void is an open-source, privacy-focused AI code editor that forks the Visual Studio Code experience and adds first-class AI-assisted coding features. Its core differentiator is that it never acts as an intermediary for model inference: the editor connects directly to whatever model or provider you configure (local or cloud), giving users full control of where their code and prompts are sent. Features include Tab autocomplete, inline Quick Edit, an integrated Chat with multiple modes (Chat, Agent, Gather), Agent Mode for multi-file automated edits, checkpoints for LLM changes, and tooling integrations for local model runtimes."}]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"LocalOffline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Supports running local/open-source models via integrations (Ollama, LM Studio, local runners) so inference can remain on-device or on-prem.","plainChildren":""}]}]},{"type":"header","level":2,"content":"FreeTrial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Core editor is free and open-source.","plainChildren":""}]}]},{"type":"header","level":2,"content":"GitSupport","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Terminal","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Apache-2.0","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Privacy-first architecture: no private backend proxying—connections go directly from the editor to the chosen model provider or local runtime.","plainChildren":""},{"type":"item","level":1,"content":"Model flexibility: works with local open-source models and major cloud providers (OpenAI, Anthropic, Google, etc.) by configuring your own keys or local endpoints.","plainChildren":""},{"type":"item","level":1,"content":"Agent Mode enables the AI to perform repository-wide tasks (read/write/delete files, run terminal commands) — use with care and review generated changes via checkpoints.","plainChildren":""},{"type":"item","level":1,"content":"Good choice for teams or individuals who need AI assistance but require data residency or on-prem constraints.","plainChildren":""}]}]},{"type":"header","level":2,"content":"ContextManagement","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Void maintains multi-file and workspace-level context via file indexing and a project-aware workspace model. The editor exposes this context to its AI features in several ways:","plainChildren":""},{"type":"item","level":1,"content":"File indexing / workspace awareness: Void builds an index of the repository so the AI can reason over multiple files (cross-file references, symbol lookup, project-level search).","plainChildren":""},{"type":"item","level":1,"content":"Chat attachments & contextual chat: users can include files or open buffers in the contextual AI chat so that the model receives precise file-level context for questions or fixes.","plainChildren":""},{"type":"item","level":1,"content":"Prompt / request customization: the underlying prompts sent to models are visible and editable, enabling explicit control of what context is injected and how it is framed.","plainChildren":""},{"type":"item","level":1,"content":"Model/context selection: users can choose local vs cloud models and control token/context-window usage (selecting models with different context sizes) to manage how much of the project fits into a single request.","plainChildren":""}]}]},{"type":"header","level":2,"content":"DirectFileReferences","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Files can be directly referenced and provided to the AI workflows:","plainChildren":""},{"type":"item","level":1,"content":"Inline edits: AI can propose and apply edits directly to files opened in the editor (Ctrl+K inline editing and Fast Apply for large files).","plainChildren":""},{"type":"item","level":1,"content":"Chat file attachments: the chat UI supports attaching files and referencing file paths so the assistant works from concrete file content.","plainChildren":""},{"type":"item","level":1,"content":"Agent & Gather modes: Gather mode reads files in a read-only fashion for analysis; Agent mode can access and operate on files when permitted.","plainChildren":""},{"type":"item","level":1,"content":"Command palette & search: file paths and search results can be used as inputs to AI actions (search + act workflows).","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Void provides keyboard-driven commands and a command palette (similar to VS Code) and exposes shortcuts for AI actions (examples: Ctrl+K for inline edits, Ctrl+L for chat). These commands are manually triggerable and reusable via the palette or keybindings.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Void supports autonomous \"Agent Mode\" which runs multi-step workflows where the model can read files, propose changes, and run terminal commands. While not described as a formal multi-agent framework, Agent Mode functions as a specialized subagent that can be granted permissions (read/write/terminal) and operate semi-autonomously.","plainChildren":""},{"type":"item","level":1,"content":"Users can select models for Agent Mode (local or cloud) and control behavior through editable prompts and configuration, enabling task-specific agent behaviors (e.g., code-rewrite agent, audit agent via Gather Mode).","plainChildren":""}]}]},{"type":"header","level":2,"content":"CustomModes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Void ships with specialized modes (Agent Mode, Gather Mode, Chat) and supports prompt and model configuration so users can create tailored workflows. Users can:","plainChildren":""},{"type":"item","level":1,"content":"Save or edit prompts and model choices to approximate custom modes.","plainChildren":""},{"type":"item","level":1,"content":"Use workspace settings and extensions (VS Code-compatible) to persist custom behavior per-project.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Because Void is a VS Code fork, it inherits the extension/plugin model. In addition to built-in integrations (Ollama, DocSearch, etc.), developers can add extensions or propose new integrations via the project's plugin/extension mechanisms. This allows bundling commands, AI integrations, and UI elements into installable packages.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Multiple mechanisms exist to undo or revert agent actions:","plainChildren":""},{"type":"item","level":1,"content":"Editor undo stack: AI-applied edits are regular editor changes and can be undone with the editor's undo/redo commands.","plainChildren":""},{"type":"item","level":1,"content":"Git / source control: typical Git workflows (commits, branches) can be used to checkpoint and revert agent changes; teams can require PRs for AI changes.","plainChildren":""},{"type":"item","level":1,"content":"Read-only modes: Gather Mode provides a safe, read-only analysis option to avoid accidental changes.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SpecDrivenDevelopment","children":[{"type":"text","content":"<!-- Appended research note: sources used during research: Void project website and docs, public blog posts and community coverage (Hacker News, product posts). -->"},{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Other","plainChildren":""},{"type":"item","level":1,"content":"Void Editor is not itself a spec-driven-development tool; it is an AI-powered code editor. There is no native mapping to the named SDD frameworks (BMAD, SpecKit, OpenSpec, Tessl, AgentOS, ClaudeFlow, SPARC, SuperClaude). However, Void's prompt-editing, workspace awareness and Agent/Gather modes can be combined with external SDD tooling (e.g., Tessl or a spec runner) by using extensions or workspace scripts to enforce spec-driven workflows.","plainChildren":""}]}]}],"sourcePath":"void-editor.md"},{"type":"header","level":1,"content":"Windsurf - https://windsurf.ai","children":[{"type":"text","content":"AI-powered agentic IDE and coding assistant focused on whole-project understanding and multi-file edits"},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"v1.0 (2025-10-19)"}]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Editor","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"[4] Strong whole-repo understanding, multi-file edits, and iterative AI flows","plainChildren":""},{"type":"item","level":1,"content":"[3] Proprietary platform with limited offline/local options compared with fully open-source alternatives","plainChildren":""}]}]},{"type":"header","level":2,"content":"Repository","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"https://windsurf.ai","plainChildren":""}]}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Python, JavaScript/TypeScript, Go, Java, Ruby, C#, and most common programming languages (broad support via language-agnostic indexing)","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"Windsurf is an AI-powered, agentic development environment (IDE-like) designed to understand entire codebases, perform multi-file edits, and run iterative \"AI flows\" that plan, modify, and validate changes across a project. It emphasizes deep indexing of repositories to provide context-aware code generation (not just token-level autocomplete), memory of project and team preferences, and integration with terminals and development workflows. Windsurf evolved from previous offerings in the space (notably Codeium-era projects) and targets both individual developers and teams who want higher-level automation and collaboration between humans and AI."}]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"LocalOffline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Windsurf is primarily a cloud-hosted agent; local/offline modes are limited compared with some local-first tools (though integrations and enterprise offerings may offer stronger controls).","plainChildren":""}]}]},{"type":"header","level":2,"content":"FreeTrial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"GitSupport","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Terminal","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Proprietary","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Core features: Cascade (agentic flows with Write Mode and Chat Mode) with MCP support, Supercomplete (intent-aware completions across files), memory for team/project preferences, deep indexing for semantic repo understanding, multi-file edits, and terminal integration.","plainChildren":""},{"type":"item","level":1,"content":"Workflow: Windsurf indexes the repository to build a semantic map, then offers both targeted inline edits and larger multi-file changes through planned flows that can ask for confirmations and iteratively validate results.","plainChildren":""},{"type":"item","level":1,"content":"Use cases: rapid feature development, refactoring across large codebases, onboarding and enabling non-technical stakeholders to participate in app development, automated bug fixing and repeated task automation.","plainChildren":""},{"type":"item","level":1,"content":"Positioning: competes with agentic IDEs and advanced copilots (e.g., Cursor AI and other commercial copilots) by focusing on whole-project context and automated multi-file transformations.","plainChildren":""},{"type":"item","level":1,"content":"Privacy & controls: offers enterprise features (including BYOK) to help with key management; however, as a proprietary cloud service it may not meet all offline/local security needs.","plainChildren":""},{"type":"item","level":1,"content":"Background: built on advances in code-level LLM tooling; product messaging highlights agentic behavior (planning, execution, checkpoints) rather than only completion.","plainChildren":""},{"type":"item","level":1,"content":"Community artifacts: there are community-driven helper files and rules (e.g., .windsurfrules) circulated to help guide AI assistants on code style and project rules; these can be found in various GitHub repos but the main product is not open-source.","plainChildren":""}]}]},{"type":"header","level":2,"content":"ContextManagement","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Indexing Engine: Windsurf builds a full-codebase index that allows the agent to fetch relevant context from anywhere in the repo rather than only recent or open files. This index powers higher-quality completions and context-aware flows.","plainChildren":""},{"type":"item","level":1,"content":"@-mentions & scoped references: Cascade supports mentioning specific files, symbols or sections to narrow the working context for a task or conversation.","plainChildren":""},{"type":"item","level":1,"content":"Memories & AI Rules: Persistent user-defined rules and automatically generated memories let you keep long-lived project preferences, API choices, and style constraints for future sessions.","plainChildren":""}]}]},{"type":"header","level":2,"content":"DirectFileReferences","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Symbol/file references: You can directly reference files, functions or classes in conversation (via @-style references and the Cascade UI) so the agent resolves and uses the exact code locations.","plainChildren":""},{"type":"item","level":1,"content":"File uploads and images: Files and screenshots can be attached/uploaded into Cascade for the agent to inspect and generate corresponding code or changes.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"AI Flows lifecycle: Cascade's flows have explicit stages (plan -> generate -> request approval -> execute commands -> iterate) that can be treated like lifecycle events and instrumented with rules and approvals.","plainChildren":""},{"type":"item","level":1,"content":"Terminal/command approval hooks: Before executing terminal commands or making repo changes, Cascade prompts for confirmation and displays diffs, enabling an attachable checkpoint/approval step.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Command palette & inline commands: Windsurf provides contextual command suggestions (including terminal commands) and an inline/command-palette style interface for invoking reusable commands or code transformations.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Specialized flows & model selection: Cascade supports creating distinct AI flows with specific settings (model choice, memory, rules) to act like specialized subagents for task-specific workflows (e.g., refactor agent, test-generator agent).","plainChildren":""},{"type":"item","level":1,"content":"Autonomous vs. assistant modes: Write Mode runs more autonomously (multi-step execution), effectively letting a sub-flow perform a sequence of edits and terminal actions under supervision.","plainChildren":""}]}]},{"type":"header","level":2,"content":"CustomModes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Mode presets & rules: Users can pick between Write / Chat / Legacy modes and define AI rules and memories to create behaviourally customised modes for the assistant.","plainChildren":""},{"type":"item","level":1,"content":"Persistence: Memories and project-level rules make these custom modes repeatable across sessions.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"VS Code extension compatibility: As a VS Code fork, Windsurf can leverage the existing extension/plugin ecosystem to bundle commands, linters, debuggers and UI integrations.","plainChildren":""},{"type":"item","level":1,"content":"AI rules + extensions: Windsurf's AI rules and Cascade flows can be combined with extensions to create reusable bundles of behavior (commands + hooks + rules).","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Approval & diffs: Cascade shows diffs and asks for approval before applying code changes or running terminal commands, providing a human-in-the-loop checkpoint.","plainChildren":""},{"type":"item","level":1,"content":"VCS integration: Because it operates inside a code editor and integrates with terminals, standard git workflows (commit, branch, revert) can be used to undo or roll back changes.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SpecDrivenDevelopment","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Other","plainChildren":""},{"type":"item","level":1,"content":"Windsurf is not tied to a single, opinionated spec-driven development framework. Instead it provides flexible automation primitives (flows, rules, memories, extensions) that teams can use to implement SDD processes such as Tessl or other internal spec workflows.","plainChildren":""}]}]}],"sourcePath":"windsurf.md"},{"type":"header","level":1,"content":"Zed - https://zed.dev","children":[{"type":"text","content":"A next-generation, high-performance code editor focused on speed, real-time collaboration, and integrated AI assistance. Built in Rust with a GPU-rendered UI and a local-first philosophy for AI models."},{"type":"header","level":2,"content":"Version","children":[{"type":"text","content":"vN/A (2025-10-19)"}]},{"type":"header","level":2,"content":"Classification","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Code/Editor","plainChildren":""}]}]},{"type":"header","level":2,"content":"Rating","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"[5] Exceptional performance and responsiveness (GPU-driven UI, Rust)","plainChildren":""},{"type":"item","level":1,"content":"[4] Strong collaboration and AI integration, extension ecosystem still growing","plainChildren":""}]}]},{"type":"header","level":2,"content":"Repository","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"https://github.com/zed-industries/zed","plainChildren":""}]}]},{"type":"header","level":2,"content":"Languages","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Any","plainChildren":""}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Extension registry available; growing ecosystem but smaller than VS Code's marketplace","plainChildren":""}]}]},{"type":"header","level":2,"content":"Description","children":[{"type":"text","content":"Zed is a modern code editor engineered for low latency and smooth UX. It renders its UI on the GPU (GPUI approach) and is written in Rust, which together produce very fast startup, typing responsiveness, and large-file handling. Zed emphasizes real-time collaboration (multi-user editing, shared notes, chat) and tight integration with AI: an Assistant Panel for conversational, project-aware assistance and inline transformations that apply AI-suggested diffs directly in-editor. Zed also supports multibuffer editing, an integrated terminal, robust language support via Tree-sitter/WebAssembly and LSP, and a first-class Vim mode."}]},{"type":"header","level":2,"content":"BYOK","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Zed supports OpenAI-compatible providers and can be configured to use local LLM hosts (e.g., Ollama) so you can run models with your own keys or entirely offline.","plainChildren":""}]}]},{"type":"header","level":2,"content":"LocalOffline","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Zed can be configured to use local LLMs (via Ollama or other OpenAI-compatible endpoints) so prompts and code can stay on-device. It also supports running Ollama on remote GPU hosts (SSH/port-forwarding) if needed.","plainChildren":""}]}]},{"type":"header","level":2,"content":"FreeTrial","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"The editor and source are available openly; binaries are freely downloadable. (See \"Notes\" about binary EULA nuance.)","plainChildren":""}]}]},{"type":"header","level":2,"content":"GitSupport","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Integrates with Git workflows; project-aware features and diagnostics help with common VCS tasks.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Terminal","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Built-in integrated terminal and task runner.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Opensource","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Core source available on GitHub","plainChildren":""}]}]},{"type":"header","level":2,"content":"License","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"GPL","plainChildren":""},{"type":"item","level":1,"content":"GPL-3.0 (core editor), AGPL for certain server/collab components; other crates/components may use Apache/MIT for specific parts","plainChildren":""}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"MCP servers are integrated similar to other extensions like e.g. theming","plainChildren":""}]}]},{"type":"header","level":2,"content":"Prompts","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Tools","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":2,"content":"Resources","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""}]}]},{"type":"header","level":2,"content":"Notes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Performance: Uses a GPU-first rendering approach (handcrafted shaders) and is implemented in Rust — developers report substantially lower typing latency and better handling of very large files compared with many existing editors.","plainChildren":""},{"type":"item","level":1,"content":"AI features: Assistant Panel exposes the full LLM request (editable) and supports slash-commands (/file, /tab, /terminal, /diagnostics, /fetch). Inline transformations let you select code and apply AI-generated diffs (accept/reject), including multiple-cursor transformations. A `/workflow` concept is being expanded for orchestrating multi-step, multi-file changes.","plainChildren":""},{"type":"item","level":1,"content":"Collaboration: Built-in real-time collaboration, chat, shared notes and session-aware AI so teams can co-edit with shared assistant context. Some collab components are licensed under AGPL.","plainChildren":""},{"type":"item","level":1,"content":"Local models & privacy: Zed supports connecting to local model hosts like Ollama; this enables on-device model usage and BYOK workflows. Zed also supports OpenAI-compatible APIs if you prefer hosted models.","plainChildren":""},{"type":"item","level":1,"content":"Extensions: Extension registry now exists, enabling community contributions, but the ecosystem is younger and smaller than VS Code's—growing quickly.","plainChildren":""},{"type":"item","level":1,"content":"Binary vs source nuance: While the source is open under GPL/AGPL, the binaries distributed from zed.dev have their own EULA and the Zed team has noted this could diverge from the source in future distributions (similar to other editor projects). Review the repo and zed.dev terms if license specifics are important for your use case.","plainChildren":""},{"type":"item","level":1,"content":"Good fit: Developers who prioritize low-latency editing, collaboration-first workflows, and integrated AI (especially teams wanting local model hosting) will find Zed compelling. If you depend on a very mature extension marketplace, account for that gap today.","plainChildren":""}]}]},{"type":"header","level":2,"content":"ContextManagement","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Zed exposes the entire AI request/interaction as an editable text buffer in the Assistant/Agent Panel, allowing you to manage and mutate context directly (edit prior messages, remove sections, fork conversations by copying buffers) [zed.dev docs].","plainChildren":""},{"type":"item","level":1,"content":"Context can be programmatically and interactively extended via slash commands that inject file contents, terminal output, diagnostics or HTTP responses into the assistant buffer (see /file, /tab, /terminal, /diagnostics, /fetch) which are inserted as folded blocks you can expand or collapse for fine-grained control.","plainChildren":""},{"type":"item","level":1,"content":"The inline assistant can combine local selection context with the assistant panel buffer when invoked, enabling targeted transformations while preserving broader context.","plainChildren":""}]}]},{"type":"header","level":2,"content":"DirectFileReferences","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Files and whole directory trees can be inserted into the assistant panel using the /file command (or /tab for open tabs). Inserted content appears as folded blocks containing the file text; directory trees are inserted recursively as nested folds so you can include precise file-level context in prompts [zed.dev docs].","plainChildren":""},{"type":"item","level":1,"content":"You can also insert selected text from the main editor into the assistant buffer via keyboard shortcuts or the command palette, and the Agent Panel tools can navigate and open files as the agent reads your workspace.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Hooks","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"Public documentation does not describe a documented lifecycle \"hooks\" API (e.g., editor lifecycle events exposed as hook callbacks) for third-party integrations. Zed does provide extension points (WebAssembly-based extensions, MCP servers) but explicit hook-style lifecycle events are not clearly documented in the available sources.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SlashCommands","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Zed supports a set of slash commands in the Assistant/Agent Panel for context injection:","plainChildren":""},{"type":"item","level":1,"content":"/file — insert file or directory tree contents","plainChildren":""},{"type":"item","level":1,"content":"/tab — insert contents of currently open tabs","plainChildren":""},{"type":"item","level":1,"content":"/terminal — insert terminal output","plainChildren":""},{"type":"item","level":1,"content":"/diagnostics — insert aggregated diagnostics across the workspace","plainChildren":""},{"type":"item","level":1,"content":"/fetch — insert the response from an arbitrary HTTP URL","plainChildren":""},{"type":"item","level":1,"content":"Slash commands render inserted content as editable, foldable blocks inside the assistant buffer so you can control token usage and visibility when composing prompts.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Subagents","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"No","plainChildren":""},{"type":"item","level":1,"content":"There is no explicit public documentation describing named \"subagents\" you can define and register. Zed does provide an Agent Panel with tool calling, profiles that restrict or grant tool access, and MCP server integration for custom tools — these enable agentic workflows, but the term \"subagent\" (as separately definable autonomous agents) is not documented in the sources used.","plainChildren":""}]}]},{"type":"header","level":2,"content":"CustomModes","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Zed supports configurable Assistant profiles (assistant.profiles in settings.json) which let you create custom agent/tool configurations (e.g., Read-only, Write-enabled, Minimal) governing what the assistant can access and do. Profiles can be created and edited via the UI or by modifying settings.json directly.","plainChildren":""},{"type":"item","level":1,"content":"The editor also supports extensibility (extensions, settings, keymaps), so you can compose specialist workflows or modes via extensions plus profile/policy configuration.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Plugins","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"Zed has an extension system and a growing registry; extensions can add functionality and integrate with editor workflows. Extension development leverages WebAssembly and platform extension points, and MCP servers can provide additional tool capabilities to the Agent Panel.","plainChildren":""},{"type":"item","level":1,"content":"The ecosystem is younger and smaller than VS Code's marketplace but is expanding; community and first-party extensions are distributed via the registry.","plainChildren":""}]}]},{"type":"header","level":2,"content":"Checkpoints","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Yes","plainChildren":""},{"type":"item","level":1,"content":"When the AI agent makes edits, Zed creates a restore checkpoint for the pre-edit state and surfaces a \"Restore Checkpoint\" action on the message so you can revert the workspace to the state before the AI change. Checkpoints appear even if an edit was interrupted mid-change, offering a safety net for agentic editing workflows.","plainChildren":""}]}]},{"type":"header","level":2,"content":"SpecDrivenDevelopment","children":[{"type":"list","level":2,"children":[{"type":"item","level":1,"content":"Other","plainChildren":""},{"type":"item","level":1,"content":"Zed itself does not ship a built-in spec-driven development framework (none of the listed frameworks are bundled with the editor). Zed is an extensible editor and can be used alongside spec-driven workflows or external tools (including Tessl, SpecKit, or custom tooling) via its extension system, Agent Panel tools, or external integrations, but no first-class, editor-native SDD framework is documented in the available sources.","plainChildren":""}]}]}],"sourcePath":"zed.md"}]