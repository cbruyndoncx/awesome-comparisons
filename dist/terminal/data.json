[{"type":"header","level":1,"content":"Aider - https://aider.chat","children":[{"type":"text","content":"Aider is the first popular AI Coding CLI, with a fairly recently added webbased gui.\nAider is a python package and frequently updated with a mass following and an active Discord community."},{"type":"header","level":2,"content":"General Info","children":[{"type":"header","level":3,"content":"Classification","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Code/Terminal","plainChildren":""}]}]},{"type":"header","level":3,"content":"Version","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Unknown (2025-10-18)","plainChildren":""},{"type":"item","level":3,"content":"Actively maintained open-source project; check https://github.com/Aider-AI/aider for current version","plainChildren":""}]}]},{"type":"header","level":3,"content":"Repo","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"https://github.com/Aider-AI/aider","plainChildren":""}]}]},{"type":"header","level":3,"content":"Rating","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"[4] Popular, actively maintained OSS CLI with a large community","plainChildren":""},{"type":"item","level":3,"content":"[4] Strong Git integration and multi-LLM support; good for whole-repo edits","plainChildren":""}]}]},{"type":"header","level":3,"content":"Short Description","children":[{"type":"text","content":"A terminal-first AI pair-programming CLI (with optional browser UI) that provides repo-aware, multi-file edits, automatic Git commits, and support for multiple remote and local LLM backends."}]},{"type":"header","level":3,"content":"Description","children":[{"type":"text","content":"Aider is an open-source AI pair-programming tool focused on the terminal-first developer workflow. It allows developers to chat with LLMs, make multi-file edits, run linters/tests, and commit changes automatically via Git — all from the CLI (with an optional web GUI). Aider works across languages and large codebases by building and using a code-map of the repository to provide context-aware edits. It supports multiple remote LLM providers and local models, enabling private and offline workflows."}]},{"type":"header","level":3,"content":"Languages","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Any","plainChildren":""}]}]},{"type":"header","level":3,"content":"Notes","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"BYOK model: users supply API keys for whichever LLM provider they choose (OpenAI, Anthropic, DeepSeek, etc.), allowing control over costs and provider choice.","plainChildren":""},{"type":"item","level":3,"content":"Local/model support: Aider can connect to local LLMs (self-hosted or via local runtimes), enabling fully offline workflows and private model usage.","plainChildren":""},{"type":"item","level":3,"content":"Cost optimization: Supports prompt-caching patterns and lets you choose cheaper models or local models to reduce usage costs.","plainChildren":""},{"type":"item","level":3,"content":"Workflow strengths: deep Git integration (auto-commit with sensible commit messages, undo commit, diff), in-chat file management (/add, /drop), lint/test runs, and automatic retries/fixes when tests fail.","plainChildren":""},{"type":"item","level":3,"content":"UX features: terminal-first chat, optional web GUI, voice input, ability to ingest web pages/images for context, and pointing to CONVENTIONS.md to enforce project-specific rules.","plainChildren":""},{"type":"item","level":3,"content":"Installation: pip-based installer (e.g., python -m pip install aider-install; then run aider-install), then run aider in a repo with your chosen model and API key.","plainChildren":""},{"type":"item","level":3,"content":"Good fit for: teams wanting repo-aware AI edits, those requiring private/local model runs, developers who prefer CLI workflows and Git-backed safety for AI edits.","plainChildren":""},{"type":"item","level":3,"content":"Limitations/considerations: Aider is a thin orchestration layer — actual model behavior, costs, and availability depend on chosen LLM provider or local runtime; evaluate model performance and token costs for your use case before large-scale adoption.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Last Update","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"2025-10-18","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Licensing","children":[{"type":"header","level":3,"content":"Opensource","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"License","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"MIT","plainChildren":""}]}]},{"type":"header","level":3,"content":"FreeTrial","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"N/A","plainChildren":""},{"type":"item","level":3,"content":"Open-source tool (permanently free); users pay their own LLM provider for API usage, not a time-limited trial","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"header","level":3,"content":"MCP-Client","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]},{"type":"header","level":3,"content":"Prompts","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Supports configurable prompt templates, system-level prompts, and prompt caching to reduce costs and speed up repeated tasks.","plainChildren":""},{"type":"item","level":3,"content":"Prompts can be adjusted during chat and model selection is switchable in-session.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Tools","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"In-chat commands and workflow tooling: runs linters/tests, shows diffs, and commits changes to Git automatically.","plainChildren":""},{"type":"item","level":3,"content":"Common in-chat commands include: /add (include files), /drop (remove files from context), /model (switch model), /undo (revert last AI change), and /reasoning-effort (control model reasoning depth).","plainChildren":""}]}]},{"type":"header","level":3,"content":"Resources","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Builds a repo code-map for contextual awareness and can ingest files, folders, URLs and images to provide rich contextual resources to the model.","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Deployment","children":[{"type":"header","level":3,"content":"BYOK","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"LocalOffline","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Supports local model usage via adapters (community integrations exist for local runtimes such as Ollama and other self-hosted LLMs)","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Developer Experience","children":[{"type":"header","level":3,"content":"ContextManagement","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Maintains a repository code-map to provide broad context and supports targeted context injection via @file, @folder, URLs, and by adding files to the chat.","plainChildren":""},{"type":"item","level":3,"content":"Supports prompt caching and selective file inclusion to manage token usage and focus the model.","plainChildren":""}]}]},{"type":"header","level":3,"content":"DirectFileReferences","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Use @file / @folder references and the in-chat /add command to include specific files or folders in the session for precise edits.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Checkpoints","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Uses Git commits as checkpoints; Aider auto-commits changes with sensible messages and provides /undo and standard git tooling to revert or inspect history.","plainChildren":""}]}]},{"type":"header","level":3,"content":"GitSupport","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"header","level":3,"content":"Extensible","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Supports multiple LLM backends and local model adapters; configurable via model adapters and API-key settings","plainChildren":""}]}]},{"type":"header","level":3,"content":"Plugins","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""},{"type":"item","level":3,"content":"No formal plugin marketplace or plugin API; extensibility is achieved through model adapters, configuration, and local runtime integrations.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Hooks","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""},{"type":"item","level":3,"content":"No documented lifecycle hooks API for third-party plugins; automation is typically handled via configuration, scripts and Git workflows.","plainChildren":""}]}]},{"type":"header","level":3,"content":"SlashCommands","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Provides reusable in-chat slash commands for workflow control (e.g., /add, /drop, /model, /undo, /reasoning-effort, /help).","plainChildren":""}]}]},{"type":"header","level":3,"content":"CustomModes","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Built-in chat modes to tailor behavior: code (direct edits), architect (design/planning), ask (questions about code), help (explain Aider features).","plainChildren":""}]}]},{"type":"header","level":3,"content":"Subagents","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""},{"type":"item","level":3,"content":"Does not expose a named subagent framework; supports autonomous execution modes (auto-approve) but not first-class subagent definitions.","plainChildren":""}]}]}]}],"sourcePath":"aider.md"},{"type":"header","level":1,"content":"Claude Code - https://claude.ai/code","children":[{"type":"text","content":"Claude Code is Anthropic's command-line, agentic developer assistant that integrates Claude models into terminal workflows to help write, refactor, and manage code across repositories."},{"type":"header","level":2,"content":"General Info","children":[{"type":"header","level":3,"content":"Classification","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Code/Terminal","plainChildren":""}]}]},{"type":"header","level":3,"content":"Version","children":[{"type":"text","content":"v1.0 (2025-10-18)"}]},{"type":"header","level":3,"content":"Repo","children":[{"type":"text","content":"-"}]},{"type":"header","level":3,"content":"Rating","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"[4] Strong reasoning and long-context handling","plainChildren":""},{"type":"item","level":3,"content":"[3] Can be costly at the highest-capability model tiers","plainChildren":""},{"type":"item","level":3,"content":"[4] Excellent for multi-file refactors and end-to-end developer workflows","plainChildren":""}]}]},{"type":"header","level":3,"content":"Short Description","children":[{"type":"text","content":"Claude Code is a terminal-first CLI that exposes Anthropic's Claude models to developer workflows for interactive code generation, multi-file refactors, automated testing, and scripted agentic tasks. It lets developers run prompts, apply edits, execute shell commands, and integrate with git from the terminal while preserving interactive safeguards (permission prompts and commit/checkpoint workflows).\n\n-"}]},{"type":"header","level":3,"content":"Description","children":[{"type":"text","content":"Claude Code is a low-level, terminal-first developer tool from Anthropic that exposes Claude family models (Opus, Sonnet, Haiku tiers) to developer workflows. It is intentionally unopinionated and scriptable: it runs in the terminal, integrates with Git and other CLI tools, and can be wired into CI/CD, deployment systems, and custom automation. Claude Code asks permission before making file edits or running commands, and it can be configured to use Anthropic's public API, cloud-hosted model endpoints (e.g., Bedrock, Vertex AI), or organization-managed keys.\n\nThe tool is focused on large-context reasoning, multi-file code transformations, automated testing and verification, and agentic workflows where the assistant can run sequences of commands, apply patches, and validate results. It is suitable for both single developers and teams; for the latter it is offered as part of Anthropic's Team/Enterprise plans with central administration and enhanced security controls."}]},{"type":"header","level":3,"content":"Languages","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Any","plainChildren":""}]}]},{"type":"header","level":3,"content":"Notes","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Models: Offers multiple model tiers (commonly referenced as Opus (highest capability), Sonnet (workhorse), and Haiku (cost-efficient)). Opus is aimed at deep reasoning and large refactors; Sonnet balances cost and capability; Haiku is optimized for high-volume, lower-complexity tasks.","plainChildren":""},{"type":"item","level":3,"content":"Pricing: Available as seat-based subscriptions (Pro, Max tiers) and pay-as-you-go API token pricing. High-capability models (Opus) carry premium token costs; Sonnet often provides a better cost/performance tradeoff for everyday coding.","plainChildren":""},{"type":"item","level":3,"content":"Context window: Claude-family models marketed with very large context windows (useful for large repositories and multi-file edits).","plainChildren":""},{"type":"item","level":3,"content":"Platform support: macOS, Linux, Windows (CLI-first). Windows usage commonly requires Git for Windows for full CLI feature parity.","plainChildren":""},{"type":"item","level":3,"content":"Use cases: automated refactors, multi-file PR generation, test generation and repair, code review assistance, automated CI hooks, developer productivity automation.","plainChildren":""},{"type":"item","level":3,"content":"Safety & controls: interactive permission prompts, enterprise controls for data handling, and options to route through organization-managed endpoints.","plainChildren":""},{"type":"item","level":3,"content":"Ecosystem: community tooling and integrations exist (context engineers, wrappers, \"awesome\" lists) though the official product is closed-source.","plainChildren":""},{"type":"item","level":3,"content":"Further reading: consult the official Claude documentation at <https://claude.ai/> and the Claude Code overview at <https://claude.ai/code> for up-to-date pricing, model names, and deployment options.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Last Update","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"2025-11-16","plainChildren":""},{"type":"item","level":3,"content":"Note: This date may reflect documentation update; actively maintained product from Anthropic","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Licensing","children":[{"type":"header","level":3,"content":"Opensource","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]},{"type":"header","level":3,"content":"License","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Proprietary","plainChildren":""}]}]},{"type":"header","level":3,"content":"FreeTrial","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"header","level":3,"content":"MCP-Client","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"Prompts","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Claude Code is prompt-driven and exposes CLI flags and short-form prompts for interactive and scripted use. The root project file (CLAUDE.md) is automatically included in session context and is used to encode project conventions, common commands, and guardrails. See: <https://claude.ai/code>","plainChildren":""}]}]},{"type":"header","level":3,"content":"Tools","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"The CLI supports running shell commands, file edits, git operations, and configurable \"allowed tools\" for scripted agent runs. It can be configured to allow or require confirmation before making changes.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Resources","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Official documentation and overview: <https://claude.ai/code>","plainChildren":""},{"type":"item","level":3,"content":"Anthropic developer docs and API references: <https://www.anthropic.com/> and the Anthropic docs pages","plainChildren":""},{"type":"item","level":3,"content":"Community examples and third-party wrappers are available in blog posts and community repos (search \"Claude Code CLI\").","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Deployment","children":[{"type":"header","level":3,"content":"BYOK","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"LocalOffline","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""},{"type":"item","level":3,"content":"Claude Code relies on remote model endpoints by default. Anthropic and enterprise customers can route requests through cloud provider-hosted model deployments or organization-managed endpoints, but a fully offline/local model runtime is not provided as a standard option.","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Developer Experience","children":[{"type":"header","level":3,"content":"ContextManagement","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Claude Code manages context via large-model context windows, automatic inclusion of a repository-level CLAUDE.md, and explicit file-injection/piping. Users can also supply files via stdin or configure the CLI to read specific paths into the session context.","plainChildren":""}]}]},{"type":"header","level":3,"content":"DirectFileReferences","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"The CLI can read files from the working tree, and its workflow includes asking permission to edit files or run commands. Project conventions (CLAUDE.md and .claude command files) are used to teach the assistant about frequently referenced files and commands.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Checkpoints","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Claude Code integrates with git workflows and presents interactive prompts before making edits; typical usage includes creating commits, reviewable patches, or requiring user confirmation to apply changes so that git history acts as a checkpoint/undo mechanism.","plainChildren":""}]}]},{"type":"header","level":3,"content":"GitSupport","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"header","level":3,"content":"Extensible","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"Plugins","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Claude Code supports project-level extensibility via the .claude directory (custom commands and scripts). Users can author reusable command files that become slash-style commands in the CLI, enabling repeatable automations.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Hooks","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Project configuration and command files allow lifecycle-like behaviors (preflight instructions and custom scripts) that the CLI will surface during interactive sessions. Users can document expected behaviors in CLAUDE.md and trigger scripted sequences via custom commands.","plainChildren":""}]}]},{"type":"header","level":3,"content":"SlashCommands","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Custom project commands placed under .claude/commands are surfaced as slash-style commands and can be invoked from the CLI to run specialized workflows (for example, /project:fix-github-issue).","plainChildren":""}]}]},{"type":"header","level":3,"content":"CustomModes","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"The CLI allows model selection and configurable behaviors (e.g., read-only analysis, aggressive edit mode, or restricted tool sets). Users can create and store project-specific command templates and flags to emulate specialist modes for common tasks.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Subagents","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Claude Code supports agentic, multi-step workflows where the assistant can run sequences of commands, apply edits, run tests, and re-evaluate results. Project scripts and MCP-style integrations can be used to orchestrate more complex subagent behaviors.","plainChildren":""}]}]}]}],"sourcePath":"claude-code.md"},{"type":"header","level":1,"content":"Codex CLI - https://github.com/openai/codex/","children":[{"type":"text","content":"Codex CLI is an open-source command-line interface for interacting with OpenAI's Codex model and other compatible LLM providers."},{"type":"header","level":2,"content":"General Info","children":[{"type":"header","level":3,"content":"Classification","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Code/Terminal","plainChildren":""}]}]},{"type":"header","level":3,"content":"Version","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Unknown (2025-10-19)","plainChildren":""},{"type":"item","level":3,"content":"Version information not available for OpenAI Codex CLI","plainChildren":""}]}]},{"type":"header","level":3,"content":"Repo","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"https://github.com/openai/codex","plainChildren":""}]}]},{"type":"header","level":3,"content":"Rating","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"[4] Strong community and practitioner assessments","plainChildren":""},{"type":"item","level":3,"content":"[4] Effective terminal-first coding agent with configurable approval modes","plainChildren":""}]}]},{"type":"header","level":3,"content":"Short Description","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"A terminal-first coding agent that reads, edits, and executes code using LLMs with configurable approval/sandbox modes and provider gateways.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Description","children":[{"type":"text","content":"Codex CLI provides a lightweight, terminal-first agent that lets developers read, modify, and execute code using large language models. It runs tasks in sandboxed environments, can run linters/tests, propose edits, and integrate changes back into a local repository or create pull requests. The CLI supports multiple operation modes (suggest, auto-edit, full-auto) which control how much automation is allowed without user approval."}]},{"type":"header","level":3,"content":"Languages","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Any","plainChildren":""}]}]},{"type":"header","level":3,"content":"Notes","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Supports multiple model providers (OpenAI, OpenRouter, Gemini, Ollama, Mistral, DeepSeek, xAI, Groq and other OpenAI-compatible endpoints) via configuration and gateways.","plainChildren":""},{"type":"item","level":3,"content":"Configuration stored in ~/.codex/config.toml; users can create reusable prompts and agent settings per-repo.","plainChildren":""},{"type":"item","level":3,"content":"Operational modes:","plainChildren":""},{"type":"item","level":3,"content":"Suggest (default): proposes edits and commands; requires user approval before applying changes.","plainChildren":""},{"type":"item","level":3,"content":"Auto Edit: autonomously reads/writes files, but asks before executing shell commands.","plainChildren":""},{"type":"item","level":3,"content":"Full Auto: performs reads, writes, and executes commands in a sandboxed, network-disabled environment without additional prompts.","plainChildren":""},{"type":"item","level":3,"content":"AGENTS.md: repository-level guidance files can be added to help the agent understand project structure, test commands, and conventions.","plainChildren":""},{"type":"item","level":3,"content":"Useful for exploratory code tasks, automated refactors, running test-fix cycles, and generating PR-ready diffs; best results when the repository includes clear tests and documentation.","plainChildren":""}]},{"type":"text","content":"Sources: GitHub repository (https://github.com/openai/codex) and project documentation/examples aggregated from public write-ups about Codex CLI and its configuration."}]},{"type":"header","level":3,"content":"Last Update","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"2025-10-19","plainChildren":""},{"type":"item","level":3,"content":"Date reflects the most recent project metadata checked during this update.","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Licensing","children":[{"type":"header","level":3,"content":"Opensource","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"License","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"MIT","plainChildren":""}]}]},{"type":"header","level":3,"content":"FreeTrial","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Availability depends on chosen model provider (OpenAI, Ollama, etc.)","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"header","level":3,"content":"MCP-Client","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"Prompts","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Codex CLI supports reusable prompts, per-repo agent settings and prompt templates via configuration files (e.g., ~/.codex/config.toml and repository AGENTS.md).","plainChildren":""}]}]},{"type":"header","level":3,"content":"Tools","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Integrates with local tools (linters, test runners, build commands) and can propose/execute shell commands (subject to approval mode and sandboxing).","plainChildren":""}]}]},{"type":"header","level":3,"content":"Resources","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Can ingest repository files, AGENTS.md guidance, and external web search or provider-specific context when configured.","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Deployment","children":[{"type":"header","level":3,"content":"BYOK","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Uses API keys for model providers; supports configuring different gateways and provider endpoints.","plainChildren":""}]}]},{"type":"header","level":3,"content":"LocalOffline","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""},{"type":"item","level":3,"content":"Primarily uses remote model providers, though configurations and gateways (e.g., Ollama, LiteLLM proxies) can enable local model endpoints in some setups.","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Developer Experience","children":[{"type":"header","level":3,"content":"ContextManagement","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Supports persistent guidance via AGENTS.md, per-repo config, and prompt templates; can manage context window by ingesting specified files and project documentation.","plainChildren":""}]}]},{"type":"header","level":3,"content":"DirectFileReferences","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Agents operate directly on repository files, can read and propose edits to specific files, and support passing file content or paths into prompts for context.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Checkpoints","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Typical workflow uses git commits/diffs and can prepare commits or PRs; interactive modes ask for approval before applying changes, enabling easy rollback via git.","plainChildren":""}]}]},{"type":"header","level":3,"content":"GitSupport","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Can produce commits and prepare PR diffs (behavior depends on config and approval mode).","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"header","level":3,"content":"Extensible","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes (via provider gateways and config)","plainChildren":""}]}]},{"type":"header","level":3,"content":"Plugins","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""},{"type":"item","level":3,"content":"The project exposes provider gateways and integrations but does not provide a formal \"plugin\" packaging system in the core CLI (as of last review).","plainChildren":""}]}]},{"type":"header","level":3,"content":"Hooks","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""},{"type":"item","level":3,"content":"There is no documented, generic plugin-hook lifecycle API; repository-level AGENTS.md and config provide the primary customization points.","plainChildren":""}]}]},{"type":"header","level":3,"content":"SlashCommands","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"The interactive interface supports internal commands (for example switching models or toggling behavior) and the CLI exposes flags and subcommands to control operation modes.","plainChildren":""}]}]},{"type":"header","level":3,"content":"CustomModes","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Built-in modes (suggest, auto-edit, full-auto) and approval/sandbox configurations let teams tailor agent autonomy and safety boundaries.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Subagents","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Workflows often include specialized agent roles (e.g., review agents, testing agents) and the CLI supports multi-step plans that can incorporate distinct agent behaviors.","plainChildren":""}]}]}]}],"sourcePath":"codex-cli.md"},{"type":"header","level":1,"content":"Gemini CLI - https://aistudio.google.com/","children":[{"type":"text","content":"Command-line assistant for Gemini coding workflows, providing terminal-based AI assistance powered by Google's Gemini models. Launched in 2025 to bring AI coding capabilities directly to the command line."},{"type":"header","level":2,"content":"General Info","children":[{"type":"header","level":3,"content":"Classification","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Code/Terminal","plainChildren":""}]}]},{"type":"header","level":3,"content":"Version","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"2025","plainChildren":""}]}]},{"type":"header","level":3,"content":"Repo","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"-","plainChildren":""}]}]},{"type":"header","level":3,"content":"Rating","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"-","plainChildren":""}]}]},{"type":"header","level":3,"content":"Short Description","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Command-line interface for Gemini-powered coding assistance, enabling AI-driven development workflows directly from the terminal.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Description","children":[{"type":"text","content":"Gemini CLI is Google's command-line interface for AI-assisted coding, bringing the power of Gemini models to terminal-based development workflows. It allows developers to interact with Gemini's coding capabilities without leaving their terminal environment, making it ideal for CLI-focused developers and automation workflows. The tool supports natural language prompts for code generation, debugging, and other development tasks."}]},{"type":"header","level":3,"content":"Languages","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Any","plainChildren":""}]}]},{"type":"header","level":3,"content":"Notes","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Terminal-native: Designed specifically for command-line workflows and terminal-based development.","plainChildren":""},{"type":"item","level":3,"content":"Gemini-powered: Leverages Google's Gemini model family for AI capabilities.","plainChildren":""},{"type":"item","level":3,"content":"Developer automation: Particularly useful for scripting and automated development workflows.","plainChildren":""},{"type":"item","level":3,"content":"Launched in 2025 as part of Google's expanded AI coding tools portfolio.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Last Update","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"2025","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Licensing","children":[{"type":"header","level":3,"content":"Opensource","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]},{"type":"header","level":3,"content":"License","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Proprietary","plainChildren":""}]}]},{"type":"header","level":3,"content":"FreeTrial","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"header","level":3,"content":"MCP-Client","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]},{"type":"header","level":3,"content":"Prompts","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"Tools","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"Resources","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Deployment","children":[{"type":"header","level":3,"content":"BYOK","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]},{"type":"header","level":3,"content":"LocalOffline","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Developer Experience","children":[{"type":"header","level":3,"content":"ContextManagement","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"DirectFileReferences","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"Checkpoints","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]},{"type":"header","level":3,"content":"GitSupport","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"header","level":3,"content":"Plugins","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]},{"type":"header","level":3,"content":"Hooks","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]},{"type":"header","level":3,"content":"SlashCommands","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"CustomModes","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]},{"type":"header","level":3,"content":"Subagents","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]}]}],"sourcePath":"gemini-cli.md"},{"type":"header","level":1,"content":"Kiro - https://kiro.run/","children":[{"type":"text","content":"Fast, lightweight CLI coding utility that brings AI-powered development assistance to the terminal. A new terminal-focused coding tool emphasizing speed and developer productivity."},{"type":"header","level":2,"content":"General Info","children":[{"type":"header","level":3,"content":"Classification","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Code/Terminal","plainChildren":""}]}]},{"type":"header","level":3,"content":"Version","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"2025","plainChildren":""}]}]},{"type":"header","level":3,"content":"Repo","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"-","plainChildren":""}]}]},{"type":"header","level":3,"content":"Rating","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"-","plainChildren":""}]}]},{"type":"header","level":3,"content":"Short Description","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Fast, lightweight CLI coding utility designed for terminal-based AI-assisted development workflows.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Description","children":[{"type":"text","content":"Kiro is a new command-line coding utility that focuses on speed and simplicity for terminal-based developers. It provides AI-powered coding assistance directly in the terminal environment, making it easy to generate code, debug issues, and perform development tasks without leaving the command line. Kiro emphasizes a minimal footprint and fast response times, making it ideal for developers who prefer terminal-based workflows."}]},{"type":"header","level":3,"content":"Languages","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Any","plainChildren":""}]}]},{"type":"header","level":3,"content":"Notes","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Speed-focused: Designed for fast response times and minimal latency.","plainChildren":""},{"type":"item","level":3,"content":"Lightweight: Minimal resource footprint for quick startup and operation.","plainChildren":""},{"type":"item","level":3,"content":"Terminal-native: Built specifically for command-line development workflows.","plainChildren":""},{"type":"item","level":3,"content":"New tool released in 2025 targeting CLI-focused developers.","plainChildren":""},{"type":"item","level":3,"content":"Emphasizes developer productivity through simplicity and speed.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Last Update","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"2025","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Licensing","children":[{"type":"header","level":3,"content":"Opensource","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]},{"type":"header","level":3,"content":"License","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Proprietary","plainChildren":""}]}]},{"type":"header","level":3,"content":"FreeTrial","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"header","level":3,"content":"MCP-Client","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]},{"type":"header","level":3,"content":"Prompts","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"Tools","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"Resources","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Deployment","children":[{"type":"header","level":3,"content":"BYOK","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]},{"type":"header","level":3,"content":"LocalOffline","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Developer Experience","children":[{"type":"header","level":3,"content":"ContextManagement","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"DirectFileReferences","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"Checkpoints","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]},{"type":"header","level":3,"content":"GitSupport","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"header","level":3,"content":"Plugins","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]},{"type":"header","level":3,"content":"Hooks","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]},{"type":"header","level":3,"content":"SlashCommands","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"CustomModes","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]},{"type":"header","level":3,"content":"Subagents","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]}]}],"sourcePath":"kiro.md"},{"type":"header","level":1,"content":"OpenCode - https://opencode.ai","children":[{"type":"text","content":"A terminal-native, open-source AI coding assistant that brings LLM-powered code understanding, generation and editing directly into the developer's terminal. OpenCode focuses on privacy (local-first model support), extensibility (custom actions/skills), and deep integration with developer workflows (git, LSP, shell)."},{"type":"header","level":2,"content":"General Info","children":[{"type":"header","level":3,"content":"Classification","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Code/Terminal","plainChildren":""}]}]},{"type":"header","level":3,"content":"Version","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Unknown (2025-10-19)","plainChildren":""},{"type":"item","level":3,"content":"Version information not available; check repository for current version","plainChildren":""}]}]},{"type":"header","level":3,"content":"Repo","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"https://github.com/sst/opencode","plainChildren":""}]}]},{"type":"header","level":3,"content":"Rating","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"[5] Terminal-native, privacy-first design","plainChildren":""},{"type":"item","level":3,"content":"[5] Broad LLM provider support (Models.dev)","plainChildren":""},{"type":"item","level":3,"content":"[4] Rich toolset for file, shell, and repo operations","plainChildren":""}]}]},{"type":"header","level":3,"content":"Short Description","children":[{"type":"text","content":"A terminal-native, local-first AI coding assistant with a TUI for interactive planning and building; supports local and cloud LLMs, LSP integration, git-aware editing, and extensible skills/actions."}]},{"type":"header","level":3,"content":"Description","children":[{"type":"text","content":"OpenCode is an open-source AI assistant designed for use from the terminal. It provides a conversational interface and a suite of programmatic tools (file operations, grep/glob, patch/apply, diagnostics, shell execution, fetch, Sourcegraph search, etc.) that allow the assistant to read, explain, modify and create code in the context of a repository. OpenCode supports both cloud and local LLMs (through Models.dev and adapters such as Ollama), can initialize project context, produce implementation plans, and then switch to a build mode to apply edits. Its architecture supports extensible actions/skills and hierarchical agents for complex tasks."}]},{"type":"header","level":3,"content":"Languages","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Any","plainChildren":""}]}]},{"type":"header","level":3,"content":"Notes","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Strong privacy posture: can run entirely with local models so source code does not need to be uploaded to third-party APIs.","plainChildren":""},{"type":"item","level":3,"content":"Rich tool set that mirrors common CLI developer actions (ls, grep, view, write, edit, patch, bash) so it can operate robustly on repositories.","plainChildren":""},{"type":"item","level":3,"content":"Useful workflow modes: Plan mode (no edits, design/strategy) and Build mode (apply changes). Includes undo/redo for edits.","plainChildren":""},{"type":"item","level":3,"content":"Integrates with LSP/diagnostics for precise error detection and fixes.","plainChildren":""},{"type":"item","level":3,"content":"Extensible via custom actions/skills and supports spawning sub-agents for task decomposition.","plainChildren":""},{"type":"item","level":3,"content":"Good fit for polyglot environments and CI/CD automation where a terminal-first interface and scriptability are advantages.","plainChildren":""},{"type":"item","level":3,"content":"Main website: https://opencode.ai — repo and docs live at https://github.com/sst/opencode","plainChildren":""}]}]},{"type":"header","level":3,"content":"Last Update","children":[{"type":"text","content":"2025-10-19"}]}]},{"type":"header","level":2,"content":"Licensing","children":[{"type":"header","level":3,"content":"Opensource","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"License","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"MIT","plainChildren":""}]}]},{"type":"header","level":3,"content":"FreeTrial","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"N/A","plainChildren":""},{"type":"item","level":3,"content":"Open-source software (permanently free), not a time-limited trial","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"header","level":3,"content":"MCP-Client","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"Prompts","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Includes built-in prompt templates and system prompts used by agents (Plan, Build) and subagents.","plainChildren":""},{"type":"item","level":3,"content":"Supports user-customizable prompts/skills and slash-style commands for common workflows (e.g. /init, /undo, /redo).","plainChildren":""},{"type":"item","level":3,"content":"Prompts and agent configurations can be saved and reused as part of session state.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Tools","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Provides a programmatic toolset for repository operations: file read/write/patch, grep/glob, shell execution, diagnostics via LSP, fetch/http, Sourcegraph search, and git-aware actions.","plainChildren":""},{"type":"item","level":3,"content":"Tools are exposed to the assistant for robust, repeatable edits and automated workflows.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Resources","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Official docs and usage guides: https://opencode.ai/docs","plainChildren":""},{"type":"item","level":3,"content":"Repository with examples, configuration and adapters: https://github.com/sst/opencode","plainChildren":""},{"type":"item","level":3,"content":"Community and changelog available via the repo's issues and releases pages.","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Deployment","children":[{"type":"header","level":3,"content":"BYOK","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"LocalOffline","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Supports running with local model backends (e.g. Ollama) and Models.dev adapters.","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Developer Experience","children":[{"type":"header","level":3,"content":"ContextManagement","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"OpenCode builds and maintains repository-aware context by scanning and indexing the project (repository analysis via `/init`) and persisting session state and conversation history in SQLite. It exposes project-scoped sessions, keeps file associations, and uses LSP and file-system reads to surface relevant snippets when answering questions or generating changes. See: https://github.com/sst/opencode and https://opencode.ai/docs","plainChildren":""}]}]},{"type":"header","level":3,"content":"DirectFileReferences","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Files can be directly referenced and manipulated via the CLI/TUI: file explorer panels, explicit read/view/edit actions, patch/apply operations, and path-based prompts. The assistant can open specific files, show diffs, write changes, and apply/revert patches programmatically.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Checkpoints","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"OpenCode supports undo/redo for edits, persistent session history (SQLite), and shows diffs/patches to review before applying. It also integrates with Git workflows so developers can rely on VCS history as an additional checkpoint mechanism.","plainChildren":""}]}]},{"type":"header","level":3,"content":"GitSupport","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"header","level":3,"content":"Extensible","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]},{"type":"header","level":3,"content":"Plugins","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Extensible via actions/skills, model adapters, and custom commands. Developers can add new \"skills\" or adapters (e.g., Ollama, Models.dev connectors) and script bespoke tool integrations. There is no single centralized marketplace documented; extensibility is file- and config-driven in the repo.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Hooks","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""},{"type":"item","level":3,"content":"There are no widely-documented lifecycle \"hook\" events for agent-generated actions similar to webhooks or lifecycle callbacks. Extensibility is provided via custom actions/skills and command extensions rather than a formal lifecycle hook system (see actions/skills and custom commands in the docs/repo).","plainChildren":""}]}]},{"type":"header","level":3,"content":"SlashCommands","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"OpenCode provides slash-style commands for common workflows (examples include `/init` to analyze a repo, `/undo` and `/redo` to revert or restore changes). Users can create custom commands/prompts to speed repetitive interactions.","plainChildren":""}]}]},{"type":"header","level":3,"content":"CustomModes","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"OpenCode provides at least two explicit modes: Plan Mode (read-only design/planning) and Build Mode (apply edits). Modes can be toggled in the TUI (Tab key), enabling different agent behaviours (e.g., generate a plan vs. make changes).","plainChildren":""}]}]},{"type":"header","level":3,"content":"Subagents","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"The architecture supports hierarchical agents and the spawning of sub-agents (subtasks/skills) for decomposing complex work into smaller steps; custom actions/skills can act as specialized subagents for domain tasks.","plainChildren":""}]}]}]}],"sourcePath":"opencode.md"},{"type":"header","level":1,"content":"Warp - https://www.warp.dev","children":[{"type":"text","content":"Modern AI-powered terminal and agentic development environment focused on unifying natural-language agents, terminal commands, and collaborative \"Drive\" features for teams."},{"type":"header","level":2,"content":"General Info","children":[{"type":"header","level":3,"content":"Classification","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Code/Terminal","plainChildren":""}]}]},{"type":"header","level":3,"content":"Version","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"v2.0","plainChildren":""},{"type":"item","level":3,"content":"Specific release date unavailable; major v2.0 release occurred in September 2025","plainChildren":""}]}]},{"type":"header","level":3,"content":"Repo","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"https://www.warp.dev","plainChildren":""}]}]},{"type":"header","level":3,"content":"Rating","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"[5] Best-in-class terminal + AI integration (Agent Mode, Drive, Warp Code)","plainChildren":""},{"type":"item","level":3,"content":"[4] Commercial/proprietary product; some enterprise privacy controls but limited public BYOK/local-offline detail","plainChildren":""}]}]},{"type":"header","level":3,"content":"Short Description","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"AI-powered terminal and Agentic Development Environment (ADE) that combines natural-language Agent Mode, Warp Code (live diffing and stepwise code edits), and Warp Drive (shared Workflows, Notebooks, prompts and environment variables) to enable collaborative, model-driven development workflows within the terminal.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Description","children":[{"type":"text","content":"Warp is a modern terminal that has evolved into an \"Agentic Development Environment\" (ADE). It tightly integrates large language models and agent workflows with the command line, providing natural-language command generation, an interactive chat/agent interface (Agent Mode), collaborative Drive features (Workflows, Notebooks, shared Environment Variables), and code-focused tooling (Warp Code with diff-tracking). Warp's interface lets developers mix prompts and shell commands in a single input, run multi-step agent plans, review and accept diffs produced by agents, and share/run parameterized Workflows across teams."}]},{"type":"header","level":3,"content":"Languages","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Any","plainChildren":""}]}]},{"type":"header","level":3,"content":"Notes","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Key features: Agent Mode (natural language -> commands), Warp Code (diff-tracking and stepwise code edits by agents), Drive (shared Workflows and Notebooks), Planning Mode and multi-agent orchestration.","plainChildren":""},{"type":"item","level":3,"content":"Privacy controls: granular autonomy settings (allowlists/denylists, pause/approve diffs, control file access), network logging, and zero-data-retention guarantees for enterprise customers.","plainChildren":""},{"type":"item","level":3,"content":"Strengths: Unified UX for prompt + shell input, native diff review for agent-made changes, strong collaboration primitives for teams.","plainChildren":""},{"type":"item","level":3,"content":"Limitations / unknowns: public documentation is limited on BYOK (bring-your-own-key) and fully offline local LLM operation; product is proprietary which may limit on-premise customization for some organizations.","plainChildren":""},{"type":"item","level":3,"content":"Recommended when: you want a first-class terminal with integrated AI agents and team sharing (Drive), and you prefer an opinionated, commercial product with enterprise privacy controls rather than an open-source self-hosted solution.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Last Update","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"2025-11-16","plainChildren":""},{"type":"item","level":3,"content":"Note: This date may reflect documentation update; actively maintained commercial product","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Licensing","children":[{"type":"header","level":3,"content":"Opensource","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""}]}]},{"type":"header","level":3,"content":"License","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Proprietary","plainChildren":""}]}]},{"type":"header","level":3,"content":"FreeTrial","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"MCP-Client","children":[{"type":"header","level":3,"content":"MCP-Client","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Warp supports selecting/modeling different hosted LLM providers and includes enterprise features like zero-data-retention guarantees and proxying; it exposes autonomy controls for when agents may call MCP servers without human approval.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Prompts","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Supports natural-language input as the primary interface; stored prompt templates and reusable prompts are persisted in Warp Drive and can seed Workflows and agents. Agents present a plan before execution and prompts can be edited or parameterized per Workflow.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Tools","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Agents can invoke shell commands as tools, interact with Git, run code edits via Warp Code, call selected LLM providers via configured MCP/model integrations, and execute Drive Workflows.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Resources","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Warp Drive stores shared resources (Workflows, Notebooks, commands, prompts, and environment variables) that agents can access as contextual artifacts.","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Deployment","children":[{"type":"header","level":3,"content":"BYOK","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Warp allows configuration of LLM providers and supports enterprise proxy/BYOK arrangements (customer-supplied API keys or proxying) in enterprise plans. Public documentation is limited on fully self-hosted/on-prem BYOK flows; contact sales/enterprise docs for details.","plainChildren":""}]}]},{"type":"header","level":3,"content":"LocalOffline","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""},{"type":"item","level":3,"content":"Note: Warp runs a local classifier to detect natural-language input, and some metadata/local processing happens on-device, but AI requests are typically proxied to selected LLM providers (OpenAI, Anthropic/Claude variants) unless explicitly configured via enterprise arrangements. There is no broadly-documented fully-offline LLM mode for the AI assistant as of the latest public releases.","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Developer Experience","children":[{"type":"header","level":3,"content":"ContextManagement","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Methods include attaching files and images, referencing file paths, persisting Drive artifacts (Workflows/Notebooks/Env vars), and allowing agents to request additional context interactively during multi-step plans.","plainChildren":""}]}]},{"type":"header","level":3,"content":"DirectFileReferences","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"You can reference and attach specific files/paths as context for agents; Warp Code surfaces file-level diffs and agents can propose edits to particular files which are shown in the live diff UI.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Checkpoints","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Warp provides live diff review and approval before applying changes; edits from agents can be accepted, rejected or modified and then committed to Git. Drive artifacts also provide shared versions and history for collaborative workflows.","plainChildren":""}]}]},{"type":"header","level":3,"content":"GitSupport","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Git workflows are supported via the terminal and Warp's code/diff UX; the tool is used to author and review code diffs produced by agents.","plainChildren":""}]}]}]},{"type":"header","level":2,"content":"Extensible","children":[{"type":"header","level":3,"content":"Extensible","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Support for Workflows, Notebooks, Drive-based sharing and agent configuration enables extensibility of team knowledge and repeatable automation patterns.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Plugins","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""},{"type":"item","level":3,"content":"No public plugin marketplace or documented plugin API; extensibility is primarily via Drive Workflows, Notebook artifacts, and model/agent configuration.","plainChildren":""}]}]},{"type":"header","level":3,"content":"Hooks","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""},{"type":"item","level":3,"content":"No documented lifecycle hook API for agents; control is provided via agent permissions, allowlists/denylists and approval workflows.","plainChildren":""}]}]},{"type":"header","level":3,"content":"SlashCommands","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"No","plainChildren":""},{"type":"item","level":3,"content":"No public global slash-command system documented; parameterized Workflows serve as invocable shortcuts and templates.","plainChildren":""}]}]},{"type":"header","level":3,"content":"CustomModes","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Built-in modes include Command Mode, Agent Mode, and Planning Mode. Agent autonomy and behavior can be tuned per agent/Workflow (pause-for-approval, review diffs, allowlists/denylists).","plainChildren":""}]}]},{"type":"header","level":3,"content":"Subagents","children":[{"type":"list","level":3,"children":[{"type":"item","level":3,"content":"Yes","plainChildren":""},{"type":"item","level":3,"content":"Warp supports running multiple agents and orchestrating multi-agent workflows. While there is multi-agent orchestration and task chaining, there is no widely-published \"subagent API\" name — orchestration is handled via the agent management UI and planning features.","plainChildren":""}]}]}]}],"sourcePath":"warp.md"}]